{"ast":null,"code":"/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n * @author dxq613@gmail.com\n */\nimport { __assign } from \"tslib\";\nimport { deepMix, mix, each, isNil } from '@antv/util';\nimport { getLabelPosition, getLoopCfgs } from '../util/graphic';\nimport { distance, getCircleCenterByPoints } from '../util/math';\nimport { getControlPoint, getSpline } from '../util/path';\nimport Global from '../global';\nimport Shape from './shape';\nimport { shapeBase, CLS_LABEL_BG_SUFFIX } from './shapeBase';\nimport isArray from '@antv/util/lib/is-array';\nimport isNumber from '@antv/util/lib/is-number';\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = mix({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || Global.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = mix({}, Global.defaultEdge.style, {\n      stroke: Global.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var shape = group.find(function (element) {\n      return element.get('className') === 'edge-shape';\n    }) || item.getKeyShape();\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var previousStyle = mix({}, strokeStyle, shape.attr(), cfg.style);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = mix(strokeStyle, shape.attr(), {\n      lineWidth: size,\n      path: path\n    }, cfg.style);\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n\n    var style = __assign(__assign({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      return style;\n    }\n\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX - backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    var rad = offsetStyle.angle;\n\n    if (rad > 1 / 2 * Math.PI && rad < 3 * 1 / 2 * Math.PI) {\n      offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX + backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    }\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n\n    if (rotate) {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    if (rotate) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\n\nvar singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);\n\nShape.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\nShape.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\nShape.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = getSpline(points);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if (isArray(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = distance(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if (isArray(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if (isArray(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[0] + startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[1] + startPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[0] + startPoint.x,\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[1] + startPoint.x,\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\nShape.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return getLoopCfgs(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');","map":{"version":3,"sources":["C:/Users/vietn/Desktop/AppEnegry2020/frontend/node_modules/@antv/g6/es/shape/edge.js"],"names":["__assign","deepMix","mix","each","isNil","getLabelPosition","getLoopCfgs","distance","getCircleCenterByPoints","getControlPoint","getSpline","Global","Shape","shapeBase","CLS_LABEL_BG_SUFFIX","isArray","isNumber","CLS_SHAPE","revertAlign","labelPosition","textAlign","singleEdge","itemType","refX","refY","labelAutoRotate","getPath","points","path","point","index","push","x","y","getShapeStyle","cfg","defaultStyle","options","style","strokeStyle","stroke","color","size","defaultEdge","getPathPoints","startPoint","endPoint","controlPoints","getControlPoints","concat","styles","lineWidth","updateShapeStyle","item","group","getContainer","shape","find","element","get","getKeyShape","previousStyle","attr","source","sourceNode","target","targetNode","routeCfg","radius","offset","getLabelStyleByPosition","labelCfg","position","pathShape","pointPercent","offsetX","offsetY","text","label","autoRotate","offsetStyle","rotate","_getTextAlign","angle","getLabelBgStyleByPosition","bbox","getBBox","backgroundStyle","background","padding","backgroundWidth","width","backgroundHeight","height","minX","minY","rad","Math","PI","drawShape","shapeStyle","addShape","className","name","attrs","drawLabel","defaultLabelCfg","labelStyle","getLabelStyle","rotateAtStart","rect","drawLabelBg","labelBgClassname","set","toFront","singleEdgeDef","registerEdge","undefined","curveOffset","clockwise","midPoint","center","arcPoint","vec","edgeAngle","atan2","cos","sin","length","curvePosition","innerPoint","innerPoint1","innerPoint2","afterDraw","afterUpdate"],"mappings":"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","sourcesContent":["/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n * @author dxq613@gmail.com\n */\nimport { __assign } from \"tslib\";\nimport { deepMix, mix, each, isNil } from '@antv/util';\nimport { getLabelPosition, getLoopCfgs } from '../util/graphic';\nimport { distance, getCircleCenterByPoints } from '../util/math';\nimport { getControlPoint, getSpline } from '../util/path';\nimport Global from '../global';\nimport Shape from './shape';\nimport { shapeBase, CLS_LABEL_BG_SUFFIX } from './shapeBase';\nimport isArray from '@antv/util/lib/is-array';\nimport isNumber from '@antv/util/lib/is-number';\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = mix({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || Global.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = mix({}, Global.defaultEdge.style, {\n      stroke: Global.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var shape = group.find(function (element) {\n      return element.get('className') === 'edge-shape';\n    }) || item.getKeyShape();\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var previousStyle = mix({}, strokeStyle, shape.attr(), cfg.style);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = mix(strokeStyle, shape.attr(), {\n      lineWidth: size,\n      path: path\n    }, cfg.style);\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n\n    var style = __assign(__assign({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      return style;\n    }\n\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX - backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    var rad = offsetStyle.angle;\n\n    if (rad > 1 / 2 * Math.PI && rad < 3 * 1 / 2 * Math.PI) {\n      offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX + backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    }\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n\n    if (rotate) {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    if (rotate) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\n\nvar singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);\n\nShape.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\nShape.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\nShape.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = getSpline(points);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if (isArray(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = distance(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if (isArray(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if (isArray(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[0] + startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[1] + startPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[0] + startPoint.x,\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[1] + startPoint.x,\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\nShape.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return getLoopCfgs(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');"]},"metadata":{},"sourceType":"module"}