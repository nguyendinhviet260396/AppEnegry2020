{"ast":null,"code":"import { each, clone, get } from '@antv/util';\nimport textHide from './text-hide';\nexport default function nodesResamplingByState(shape, option, index, cfg) {\n  var nodes = cfg.nodes.nodes;\n  var current = nodes[index];\n\n  if (current.line) {\n    current.line.remove();\n  }\n\n  var data = cfg.plot.initialOptions.data;\n  var plotCfg = cfg.plot[cfg.plot.type] || cfg.plot[cfg.plot.baseType];\n  var field = get(plotCfg, ['label', 'fields', 0], get(plotCfg, ['position', 'fields', 1]));\n  var stateNodes = getStateNodes(data, field, nodes);\n  var isState = false;\n  each(stateNodes, function (node) {\n    // @ts-ignore\n    if (node.shape.get('origin') === current.shape.get('origin')) {\n      isState = true;\n    }\n  });\n\n  if (isState) {\n    if (current.origin_position) {\n      var _a = current.origin_position,\n          x = _a.x,\n          y = _a.y;\n      shape.attr('x', x);\n      shape.attr('y', y);\n    }\n  } else {\n    textHide(shape);\n  }\n}\n\nfunction getStateNodes(data, field, nodes) {\n  var extract_data = [];\n  each(data, function (d) {\n    extract_data.push(d[field]);\n  });\n  extract_data.sort(function (a, b) {\n    return a - b;\n  });\n  var min = extract_data[0];\n  var min_node = getNodeByNumber(nodes, field, min);\n  var max = extract_data[extract_data.length - 1];\n  var max_node = getNodeByNumber(nodes, field, max);\n  var median = getMedian(extract_data);\n  var median_node = getNodeByNumber(nodes, field, median);\n  return {\n    min: min_node,\n    max: max_node,\n    median: median_node\n  };\n}\n\nfunction getMedian(array) {\n  var list = clone(array);\n  list.sort(function (a, b) {\n    return a - b;\n  });\n  var half = Math.floor(list.length / 2);\n\n  if (list.length % 2) {\n    return list[half];\n  }\n\n  return list[half];\n}\n\nfunction getNodeByNumber(nodes, field, num) {\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    var d = node.shape.get('origin')['_origin'];\n\n    if (d[field] === num) {\n      return node;\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/util/responsive/rules/nodes-resampling-by-state.ts"],"names":[],"mappings":"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","sourcesContent":["import { IShape } from '@antv/g-base';\nimport { each, clone, get } from '@antv/util';\nimport textHide from './text-hide';\n\nexport default function nodesResamplingByState(shape: IShape, option, index, cfg) {\n  const nodes = cfg.nodes.nodes;\n  const current = nodes[index];\n  if (current.line) {\n    current.line.remove();\n  }\n\n  const data = cfg.plot.initialOptions.data;\n  const plotCfg = cfg.plot[cfg.plot.type] || cfg.plot[cfg.plot.baseType];\n  const field = get(plotCfg, ['label', 'fields', 0], get(plotCfg, ['position', 'fields', 1]));\n  const stateNodes = getStateNodes(data, field, nodes);\n\n  let isState = false;\n  each(stateNodes, (node) => {\n    // @ts-ignore\n    if (node.shape.get('origin') === current.shape.get('origin')) {\n      isState = true;\n    }\n  });\n  if (isState) {\n    if (current.origin_position) {\n      const { x, y } = current.origin_position;\n      shape.attr('x', x);\n      shape.attr('y', y);\n    }\n  } else {\n    textHide(shape);\n  }\n}\n\nfunction getStateNodes(data, field, nodes) {\n  const extract_data = [];\n  each(data, (d) => {\n    extract_data.push(d[field]);\n  });\n  extract_data.sort((a, b) => {\n    return a - b;\n  });\n  const min = extract_data[0];\n  const min_node = getNodeByNumber(nodes, field, min);\n  const max = extract_data[extract_data.length - 1];\n  const max_node = getNodeByNumber(nodes, field, max);\n  const median = getMedian(extract_data);\n  const median_node = getNodeByNumber(nodes, field, median);\n\n  return { min: min_node, max: max_node, median: median_node };\n}\n\nfunction getMedian(array) {\n  const list = clone(array);\n  list.sort((a, b) => {\n    return a - b;\n  });\n\n  const half = Math.floor(list.length / 2);\n\n  if (list.length % 2) {\n    return list[half];\n  }\n\n  return list[half];\n}\n\nfunction getNodeByNumber(nodes, field, num) {\n  for (const node of nodes) {\n    const d = node.shape.get('origin')['_origin'];\n    if (d[field] === num) {\n      return node;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}