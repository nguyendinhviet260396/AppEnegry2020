{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, map, isArray, last, each } from '@antv/util';\nimport { _ORIGIN } from '../../dependents';\nimport BaseLabel, { registerLabelComponent } from '../../components/label/base';\nimport { isBBoxIntersect } from '../../util/common';\n/**\n * 说明:\n * 适用于展示面积图和折线图上数据点的label\n * */\n\nvar PointLabel =\n/** @class */\nfunction (_super) {\n  __extends(PointLabel, _super);\n\n  function PointLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PointLabel.prototype.getDefaultOptions = function () {\n    var theme = this.layer.theme;\n    var _a = theme.label,\n        label = _a === void 0 ? {} : _a;\n    return __assign({\n      offsetX: 0,\n      offsetY: 0\n    }, label);\n  };\n\n  PointLabel.prototype.getLabelOffset = function () {\n    return this.getLabelOffsetByDimAndFactor('y', -1);\n  };\n\n  PointLabel.prototype.getLabelItemAttrs = function (element, index) {\n    var _this = this;\n\n    var _a = this.options,\n        style = _a.style,\n        formatter = _a.formatter;\n    var mappingData = get(element, 'model.mappingData', []);\n    return map(mappingData, function (datum, datumIndex) {\n      var _a;\n\n      var value = _this.getValue(datum);\n\n      return __assign(__assign(__assign({}, _this.getPosition(datum)), {\n        text: formatter ? formatter(value, (_a = {}, _a[_ORIGIN] = datum._origin, _a.mappingDatum = datum, _a.mappingDatumIndex = datumIndex, _a.element = element, _a.elementIndex = index, _a), index) : value,\n        textAlign: 'center',\n        textBaseline: 'middle'\n      }), style);\n    });\n  };\n\n  PointLabel.prototype.getValue = function (datum) {\n    return get(datum._origin, this.layer.options.yField);\n  };\n\n  PointLabel.prototype.getPosition = function (datum) {\n    var pos = {\n      x: isArray(datum.x) ? last(datum.x) : datum.x,\n      y: isArray(datum.y) ? last(datum.y) : datum.y\n    };\n    return pos;\n  };\n\n  PointLabel.prototype.layoutLabels = function (geometry, labels) {\n    var _this = this;\n\n    if (!this.options.adjustPosition) {\n      return;\n    }\n\n    var overlap = this.isOverlapped(labels); // 规则1：先横向，优先显示横向上变化趋势大的label\n\n    if (overlap) {\n      var tolerance_1 = this.getGlobalTolerance(labels);\n      each(labels, function (label, index) {\n        if (index > 1) {\n          _this.labelResamplingByChange(label, labels, index, tolerance_1);\n        }\n      });\n    }\n\n    overlap = this.isOverlapped(labels); // 规则2： 后纵向，优先保留纵向最高点label\n\n    if (overlap) {\n      each(labels, function (label, index) {\n        if (label.get('visible')) {\n          _this.clearOverlapping(label, labels, index);\n        }\n      });\n    }\n  };\n\n  PointLabel.prototype.adjustLabel = function () {\n    return;\n  };\n  /** 根据变化进行抽样，保留变化较大的点，类似于点简化算法 */\n\n\n  PointLabel.prototype.labelResamplingByChange = function (label, labels, index, tolerance) {\n    var previous = this.findPrevious(index, labels);\n    var currentCenter = this.getCenter(label);\n    var previousCenter = this.getCenter(previous);\n    var distX = previousCenter.x - currentCenter.x;\n    var distY = previousCenter.y - currentCenter.y;\n    var dist = Math.sqrt(distX * distX + distY * distY);\n\n    if (dist < tolerance) {\n      label.set('visible', false);\n    }\n  };\n\n  PointLabel.prototype.clearOverlapping = function (label, labels, index) {\n    // 找到所有与当前点overlap的node\n    var overlapped = [];\n\n    for (var i = 0; i < labels.length; i++) {\n      var current = labels[i];\n\n      if (i !== index && current.get('visible')) {\n        var isOverlap = isBBoxIntersect(label.getBBox(), current.getBBox());\n\n        if (isOverlap) {\n          overlapped.push(current);\n        }\n      }\n    } // 对overapped label进行处理\n\n\n    if (overlapped.length > 0) {\n      overlapped.push(label);\n      overlapped.sort(function (a, b) {\n        return b.minY - a.minY;\n      }); // 隐藏除最高点以外的label\n\n      each(overlapped, function (label, index) {\n        if (index > 0) {\n          label.set('visible', false);\n        }\n      });\n    }\n  };\n  /** 检测一组label中是否存在重叠 **/\n\n\n  PointLabel.prototype.isOverlapped = function (labels) {\n    for (var i = 0; i < labels.length; i++) {\n      if (labels[i].get('visible')) {\n        var labelABBox = labels[i].getBBox();\n\n        for (var j = 0; j < labels.length; j++) {\n          if (j !== i && labels[j].get('visible')) {\n            var labelBBBox = labels[j].getBBox();\n            var intersection = isBBoxIntersect(labelABBox, labelBBBox);\n\n            if (intersection) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  PointLabel.prototype.getGlobalTolerance = function (labels) {\n    var labelsClone = labels.slice();\n    labelsClone.sort(function (a, b) {\n      return b.getBBox().width - a.getBBox().width;\n    });\n    return Math.round(labelsClone[0].getBBox().width);\n  };\n\n  PointLabel.prototype.findPrevious = function (index, labels) {\n    for (var i = index - 1; i > 0; i--) {\n      if (labels[i].get('visible')) {\n        return labels[i];\n      }\n    }\n  };\n\n  PointLabel.prototype.getCenter = function (label) {\n    var _a = label.getBBox(),\n        minX = _a.minX,\n        maxX = _a.maxX,\n        minY = _a.minY,\n        maxY = _a.maxY;\n\n    return {\n      x: minX + (maxX - minX) / 2,\n      y: minY + (maxY - minY) / 2\n    };\n  };\n\n  return PointLabel;\n}(BaseLabel);\n\nexport default PointLabel;\nregisterLabelComponent('point', PointLabel);","map":{"version":3,"sources":["../../../src/components/label/point.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, map, isArray, last, each } from '@antv/util';\nimport { Element, MappingDatum, _ORIGIN } from '../../dependents';\nimport BaseLabel, { registerLabelComponent } from '../../components/label/base';\nimport { TextStyle, Label } from '../../interface/config';\nimport { IShape, Geometry } from '../../dependents';\nimport { isBBoxIntersect } from '../../util/common';\n\n/**\n * 说明:\n * 适用于展示面积图和折线图上数据点的label\n * */\n\nexport default class PointLabel<L extends Label = Label> extends BaseLabel<L> {\n  protected getDefaultOptions() {\n    const { theme } = this.layer;\n    const { label = {} } = theme;\n    return {\n      offsetX: 0,\n      offsetY: 0,\n      ...label,\n    };\n  }\n\n  protected getLabelOffset() {\n    return this.getLabelOffsetByDimAndFactor('y', -1);\n  }\n\n  protected getLabelItemAttrs(element: Element, index: number): TextStyle[] {\n    const { style, formatter } = this.options;\n    const mappingData: MappingDatum[] = get(element, 'model.mappingData', []);\n\n    return map(mappingData, (datum, datumIndex) => {\n      const value = this.getValue(datum);\n      return {\n        ...this.getPosition(datum),\n        text: formatter\n          ? formatter(\n              value,\n              {\n                [_ORIGIN]: datum._origin,\n                mappingDatum: datum,\n                mappingDatumIndex: datumIndex,\n                element,\n                elementIndex: index,\n              },\n              index\n            )\n          : value,\n        textAlign: 'center',\n        textBaseline: 'middle',\n        ...style,\n      };\n    });\n  }\n\n  protected getValue(datum: MappingDatum): number | undefined | null {\n    return get(datum._origin, this.layer.options.yField);\n  }\n\n  protected getPosition(datum: MappingDatum): { x: number; y: number } {\n    const pos = {\n      x: isArray(datum.x) ? last(datum.x) : datum.x,\n      y: isArray(datum.y) ? last(datum.y) : datum.y,\n    };\n    return pos;\n  }\n\n  protected layoutLabels(geometry: Geometry, labels: IShape[]): void {\n    if (!this.options.adjustPosition) {\n      return;\n    }\n    let overlap = this.isOverlapped(labels);\n    // 规则1：先横向，优先显示横向上变化趋势大的label\n    if (overlap) {\n      const tolerance = this.getGlobalTolerance(labels);\n      each(labels, (label, index) => {\n        if (index > 1) {\n          this.labelResamplingByChange(label, labels, index, tolerance);\n        }\n      });\n    }\n    overlap = this.isOverlapped(labels);\n    // 规则2： 后纵向，优先保留纵向最高点label\n    if (overlap) {\n      each(labels, (label, index) => {\n        if (label.get('visible')) {\n          this.clearOverlapping(label, labels, index);\n        }\n      });\n    }\n  }\n\n  protected adjustLabel() {\n    return;\n  }\n\n  /** 根据变化进行抽样，保留变化较大的点，类似于点简化算法 */\n  private labelResamplingByChange(label: IShape, labels: IShape[], index: number, tolerance: number) {\n    const previous = this.findPrevious(index, labels);\n    const currentCenter = this.getCenter(label);\n    const previousCenter = this.getCenter(previous);\n    const distX = previousCenter.x - currentCenter.x;\n    const distY = previousCenter.y - currentCenter.y;\n    const dist = Math.sqrt(distX * distX + distY * distY);\n    if (dist < tolerance) {\n      label.set('visible', false);\n    }\n  }\n\n  private clearOverlapping(label: IShape, labels: IShape[], index: number) {\n    // 找到所有与当前点overlap的node\n    const overlapped = [];\n    for (let i = 0; i < labels.length; i++) {\n      const current = labels[i];\n      if (i !== index && current.get('visible')) {\n        const isOverlap = isBBoxIntersect(label.getBBox(), current.getBBox());\n        if (isOverlap) {\n          overlapped.push(current);\n        }\n      }\n    }\n    // 对overapped label进行处理\n    if (overlapped.length > 0) {\n      overlapped.push(label);\n      overlapped.sort((a, b) => {\n        return b.minY - a.minY;\n      });\n      // 隐藏除最高点以外的label\n      each(overlapped, (label: IShape, index: number) => {\n        if (index > 0) {\n          label.set('visible', false);\n        }\n      });\n    }\n  }\n\n  /** 检测一组label中是否存在重叠 **/\n  private isOverlapped(labels: IShape[]) {\n    for (let i = 0; i < labels.length; i++) {\n      if (labels[i].get('visible')) {\n        const labelABBox = labels[i].getBBox();\n        for (let j = 0; j < labels.length; j++) {\n          if (j !== i && labels[j].get('visible')) {\n            const labelBBBox = labels[j].getBBox();\n            const intersection = isBBoxIntersect(labelABBox, labelBBBox);\n            if (intersection) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private getGlobalTolerance(labels: IShape[]) {\n    const labelsClone = labels.slice();\n    labelsClone.sort((a, b) => {\n      return b.getBBox().width - a.getBBox().width;\n    });\n    return Math.round(labelsClone[0].getBBox().width);\n  }\n\n  private findPrevious(index: number, labels: IShape[]) {\n    for (let i = index - 1; i > 0; i--) {\n      if (labels[i].get('visible')) {\n        return labels[i];\n      }\n    }\n  }\n\n  private getCenter(label: IShape) {\n    const { minX, maxX, minY, maxY } = label.getBBox();\n    return { x: minX + (maxX - minX) / 2, y: minY + (maxY - minY) / 2 };\n  }\n}\n\nregisterLabelComponent('point', PointLabel);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}