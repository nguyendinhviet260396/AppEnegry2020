{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractGroup } from '@antv/g-base';\nimport * as Shape from './shape';\nimport { applyAttrsToContext, drawChildren, refreshElement } from './util/draw';\n\nvar Group =\n/** @class */\nfunction (_super) {\n  __extends(Group, _super);\n\n  function Group() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n\n\n  Group.prototype.onCanvasChange = function (changeType) {\n    refreshElement(this, changeType);\n  };\n\n  Group.prototype.getShapeBase = function () {\n    return Shape;\n  };\n\n  Group.prototype.getGroupBase = function () {\n    return Group;\n  }; // 同 shape 中的方法重复了\n\n\n  Group.prototype._applyClip = function (context, clip) {\n    if (clip) {\n      context.save(); // 将 clip 的属性挂载到 context 上\n\n      applyAttrsToContext(context, clip); // 绘制 clip 路径\n\n      clip.createPath(context);\n      context.restore(); // 裁剪\n\n      context.clip();\n\n      clip._afterDraw();\n    }\n  };\n\n  Group.prototype.draw = function (context, region) {\n    var children = this.getChildren();\n\n    if (children.length) {\n      context.save(); // group 上的矩阵和属性也会应用到上下文上\n      // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n\n      applyAttrsToContext(context, this);\n\n      this._applyClip(context, this.getClip());\n\n      drawChildren(context, children, region);\n      context.restore();\n    } // 这里的成本比较大\n\n\n    this.set('cacheCanvasBBox', this.getCanvasBBox()); // 绘制后，消除更新标记\n\n    this.set('hasChanged', false);\n  }; // 绘制时被跳过，一般发生在分组隐藏时\n\n\n  Group.prototype.skipDraw = function () {\n    this.set('cacheCanvasBBox', null);\n    this.set('hasChanged', false);\n  };\n\n  return Group;\n}(AbstractGroup);\n\nexport default Group;","map":{"version":3,"sources":["../src/group.ts"],"names":[],"mappings":";AAAA,SAAS,aAAT,QAA8B,cAA9B;AAKA,OAAO,KAAK,KAAZ,MAAuB,SAAvB;AACA,SAAS,mBAAT,EAA8B,YAA9B,EAA4C,cAA5C,QAAkE,aAAlE;;AAEA,IAAA,KAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAoB,EAAA,SAAA,CAAA,KAAA,EAAA,MAAA,CAAA;;AAApB,WAAA,KAAA,GAAA;;AAqDC;AApDC;;;;;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,UAAf,EAAqC;AACnC,IAAA,cAAc,CAAC,IAAD,EAAO,UAAP,CAAd;AACD,GAFD;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,WAAO,KAAP;AACD,GAFD;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,WAAO,KAAP;AACD,GAFD,CAbF,CAiBE;;;AACA,EAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,OAAX,EAAoB,IAApB,EAAmC;AACjC,QAAI,IAAJ,EAAU;AACR,MAAA,OAAO,CAAC,IAAR,GADQ,CAER;;AACA,MAAA,mBAAmB,CAAC,OAAD,EAAU,IAAV,CAAnB,CAHQ,CAIR;;AACA,MAAA,IAAI,CAAC,UAAL,CAAgB,OAAhB;AACA,MAAA,OAAO,CAAC,OAAR,GANQ,CAOR;;AACA,MAAA,OAAO,CAAC,IAAR;;AACA,MAAA,IAAI,CAAC,UAAL;AACD;AACF,GAZD;;AAcA,EAAA,KAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,OAAL,EAAwC,MAAxC,EAAuD;AACrD,QAAM,QAAQ,GAAG,KAAK,WAAL,EAAjB;;AACA,QAAI,QAAQ,CAAC,MAAb,EAAqB;AACnB,MAAA,OAAO,CAAC,IAAR,GADmB,CAEnB;AACA;;AACA,MAAA,mBAAmB,CAAC,OAAD,EAAU,IAAV,CAAnB;;AACA,WAAK,UAAL,CAAgB,OAAhB,EAAyB,KAAK,OAAL,EAAzB;;AACA,MAAA,YAAY,CAAC,OAAD,EAAU,QAAV,EAAoB,MAApB,CAAZ;AACA,MAAA,OAAO,CAAC,OAAR;AACD,KAVoD,CAWrD;;;AACA,SAAK,GAAL,CAAS,iBAAT,EAA4B,KAAK,aAAL,EAA5B,EAZqD,CAarD;;AACA,SAAK,GAAL,CAAS,YAAT,EAAuB,KAAvB;AACD,GAfD,CAhCF,CAgDE;;;AACA,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,SAAK,GAAL,CAAS,iBAAT,EAA4B,IAA5B;AACA,SAAK,GAAL,CAAS,YAAT,EAAuB,KAAvB;AACD,GAHD;;AAIF,SAAA,KAAA;AAAC,CArDD,CAAoB,aAApB,CAAA;;AAuDA,eAAe,KAAf","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { AbstractGroup } from '@antv/g-base';\nimport * as Shape from './shape';\nimport { applyAttrsToContext, drawChildren, refreshElement } from './util/draw';\nvar Group = /** @class */ (function (_super) {\n    __extends(Group, _super);\n    function Group() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Group.prototype.onCanvasChange = function (changeType) {\n        refreshElement(this, changeType);\n    };\n    Group.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Group.prototype.getGroupBase = function () {\n        return Group;\n    };\n    // 同 shape 中的方法重复了\n    Group.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            // 将 clip 的属性挂载到 context 上\n            applyAttrsToContext(context, clip);\n            // 绘制 clip 路径\n            clip.createPath(context);\n            context.restore();\n            // 裁剪\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    Group.prototype.draw = function (context, region) {\n        var children = this.getChildren();\n        if (children.length) {\n            context.save();\n            // group 上的矩阵和属性也会应用到上下文上\n            // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n            applyAttrsToContext(context, this);\n            this._applyClip(context, this.getClip());\n            drawChildren(context, children, region);\n            context.restore();\n        }\n        // 这里的成本比较大\n        this.set('cacheCanvasBBox', this.getCanvasBBox());\n        // 绘制后，消除更新标记\n        this.set('hasChanged', false);\n    };\n    // 绘制时被跳过，一般发生在分组隐藏时\n    Group.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('hasChanged', false);\n    };\n    return Group;\n}(AbstractGroup));\nexport default Group;\n//# sourceMappingURL=group.js.map"]},"metadata":{},"sourceType":"module"}