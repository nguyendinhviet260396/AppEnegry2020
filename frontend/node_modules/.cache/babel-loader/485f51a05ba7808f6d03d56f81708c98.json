{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, uniq, keys, isFunction, isString, isArray, has, get, isObject } from '@antv/util';\nimport ElementParser from '../base';\n\nfunction getValuesByField(field, data) {\n  var values = [];\n  each(data, function (d) {\n    var v = d[field];\n    values.push(v);\n  });\n  return uniq(values);\n}\n\nvar COLOR_MAPPER = ['seriesField', 'stackField'];\n\nvar GuidePointParser =\n/** @class */\nfunction (_super) {\n  __extends(GuidePointParser, _super);\n\n  function GuidePointParser() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GuidePointParser.prototype.init = function () {\n    var props = this.plot.options;\n    this.style = props.point.style;\n\n    if (!props.xField || !props.yField) {\n      return;\n    }\n\n    this.config = {\n      type: 'point',\n      position: {\n        fields: [props.xField, props.yField]\n      },\n      tooltip: false\n    }; // if (this._needParseAttribute('color')) {\n\n    this.parseColor(); // }\n\n    if (this._needParseAttribute('size')) {\n      this.parseSize();\n    }\n\n    if (props.point.shape) {\n      this.parseShape(props.point.shape);\n    }\n\n    if (props.point.style) {\n      this.parseStyle();\n    }\n  };\n\n  GuidePointParser.prototype.parseColor = function () {\n    var props = this.plot.options;\n    var config = {};\n\n    var mappingField = this._getColorMappingField(props);\n\n    if (mappingField) {\n      this._parseColorByField(props, config, mappingField);\n    } else {\n      if (props.point && props.point.color) {\n        config.values = [props.point.color];\n      } else if (props.color) {\n        this._parseColor(props, config);\n      } else {\n        var theme = this.plot.getTheme();\n        config.values = [theme.defaultColor];\n      }\n    }\n\n    if (keys(config).length > 0) {\n      this.config.color = config;\n    }\n  };\n\n  GuidePointParser.prototype.parseSize = function () {\n    var props = this.plot.options;\n    var config = {};\n    config.values = [props.point.size];\n    this.config.size = config;\n  };\n\n  GuidePointParser.prototype.parseShape = function (shapeCfg) {\n    var config = {};\n\n    if (isString(shapeCfg)) {\n      config.values = [shapeCfg];\n    } else if (isObject(shapeCfg)) {\n      config.fields = shapeCfg.fields;\n      config.callback = shapeCfg.callback;\n    }\n\n    this.config.shape = config;\n  };\n\n  GuidePointParser.prototype.parseStyle = function () {\n    var props = this.plot.options;\n    var styleProps = props.point && props.point.style;\n    var config = {\n      fields: null,\n      callback: null,\n      cfg: null\n    };\n\n    var field = this._getColorMappingField(props);\n\n    if (isFunction(styleProps)) {\n      config.fields = [props.xField, props.yField];\n      config.callback = styleProps;\n\n      if (field) {\n        config.fields.unshift(field);\n      }\n    } else {\n      config.cfg = styleProps;\n    }\n\n    this.config.style = config;\n  };\n\n  GuidePointParser.prototype._parseColorByField = function (props, config, field) {\n    config.fields = [field];\n\n    if (props.point.color) {\n      var count = getValuesByField(field, props.data).length;\n      var values = [];\n\n      for (var i = 0; i < count; i++) {\n        values.push(props.point.color);\n      }\n\n      config.values = values;\n    } else if (props.color) {\n      this._parseColor(props, config);\n    }\n  };\n\n  GuidePointParser.prototype._parseColor = function (props, config) {\n    var field = this._getColorMappingField(props);\n\n    if (isString(props.color)) {\n      config.values = [props.color];\n    } else if (isFunction(props.color)) {\n      config.callback = props.color;\n    } else if (isArray(props.color)) {\n      if (field) {\n        config.values = props.color;\n      } else {\n        if (props.color.length > 0) {\n          config.values = [props.color[0]];\n        }\n      }\n    }\n  };\n\n  GuidePointParser.prototype._needParseAttribute = function (attr) {\n    var props = this.plot.options;\n    var condition = props.point && has(props.point, attr);\n    return condition; // const condition = !this.style || this.style[attr];\n    // return condition;\n  };\n\n  GuidePointParser.prototype._getColorMappingField = function (props) {\n    for (var _i = 0, COLOR_MAPPER_1 = COLOR_MAPPER; _i < COLOR_MAPPER_1.length; _i++) {\n      var m = COLOR_MAPPER_1[_i];\n\n      if (get(props, m)) {\n        return [props[m]];\n      }\n    }\n  };\n\n  return GuidePointParser;\n}(ElementParser);\n\nexport default GuidePointParser;","map":{"version":3,"sources":["../../../src/geoms/point/guide.ts"],"names":[],"mappings":"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","sourcesContent":["import { LooseObject } from '../../dependents';\nimport { each, uniq, keys, isFunction, isString, isArray, has, get, isObject } from '@antv/util';\nimport ElementParser from '../base';\n\nfunction getValuesByField(field, data) {\n  const values = [];\n  each(data, (d) => {\n    const v = d[field];\n    values.push(v);\n  });\n  return uniq(values);\n}\n\nconst COLOR_MAPPER = ['seriesField', 'stackField'];\n\ntype PointShape = string | { fields?: []; callback: () => string };\n\nexport default class GuidePointParser extends ElementParser {\n  public init() {\n    const props = this.plot.options;\n    this.style = props.point.style;\n    if (!props.xField || !props.yField) {\n      return;\n    }\n    this.config = {\n      type: 'point',\n      position: {\n        fields: [props.xField, props.yField],\n      },\n      tooltip: false,\n    };\n    // if (this._needParseAttribute('color')) {\n    this.parseColor();\n    // }\n    if (this._needParseAttribute('size')) {\n      this.parseSize();\n    }\n    if (props.point.shape) {\n      this.parseShape(props.point.shape);\n    }\n    if (props.point.style) {\n      this.parseStyle();\n    }\n  }\n\n  public parseColor() {\n    const props = this.plot.options;\n    const config: LooseObject = {};\n    const mappingField = this._getColorMappingField(props);\n    if (mappingField) {\n      this._parseColorByField(props, config, mappingField);\n    } else {\n      if (props.point && props.point.color) {\n        config.values = [props.point.color];\n      } else if (props.color) {\n        this._parseColor(props, config);\n      } else {\n        const theme = this.plot.getTheme();\n        config.values = [theme.defaultColor];\n      }\n    }\n    if (keys(config).length > 0) {\n      this.config.color = config;\n    }\n  }\n\n  public parseSize() {\n    const props = this.plot.options;\n    const config: LooseObject = {};\n    config.values = [props.point.size];\n    this.config.size = config;\n  }\n\n  public parseShape(shapeCfg: PointShape) {\n    const config: LooseObject = {};\n    if (isString(shapeCfg)) {\n      config.values = [shapeCfg];\n    } else if (isObject(shapeCfg)) {\n      config.fields = shapeCfg.fields;\n      config.callback = shapeCfg.callback;\n    }\n    this.config.shape = config;\n  }\n\n  public parseStyle() {\n    const props = this.plot.options;\n    const styleProps = props.point && props.point.style;\n    const config = {\n      fields: null,\n      callback: null,\n      cfg: null,\n    };\n    const field = this._getColorMappingField(props);\n    if (isFunction(styleProps)) {\n      config.fields = [props.xField, props.yField];\n      config.callback = styleProps;\n      if (field) {\n        config.fields.unshift(field);\n      }\n    } else {\n      config.cfg = styleProps;\n    }\n    this.config.style = config;\n  }\n\n  private _parseColorByField(props, config, field) {\n    config.fields = [field];\n    if (props.point.color) {\n      const count = getValuesByField(field, props.data).length;\n      const values = [];\n      for (let i = 0; i < count; i++) {\n        values.push(props.point.color);\n      }\n      config.values = values;\n    } else if (props.color) {\n      this._parseColor(props, config);\n    }\n  }\n\n  private _parseColor(props, config) {\n    const field = this._getColorMappingField(props);\n    if (isString(props.color)) {\n      config.values = [props.color];\n    } else if (isFunction(props.color)) {\n      config.callback = props.color;\n    } else if (isArray(props.color)) {\n      if (field) {\n        config.values = props.color;\n      } else {\n        if (props.color.length > 0) {\n          config.values = [props.color[0]];\n        }\n      }\n    }\n  }\n\n  private _needParseAttribute(attr) {\n    const props = this.plot.options;\n    const condition = props.point && has(props.point, attr);\n    return condition;\n    // const condition = !this.style || this.style[attr];\n    // return condition;\n  }\n\n  private _getColorMappingField(props) {\n    for (const m of COLOR_MAPPER) {\n      if (get(props, m)) {\n        return [props[m]];\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}