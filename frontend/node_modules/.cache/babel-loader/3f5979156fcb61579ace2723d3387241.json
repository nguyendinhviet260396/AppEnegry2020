{"ast":null,"code":"var dijkstra = function dijkstra(graph, source, directed, weightPropertyName) {\n  var nodes = graph.getNodes();\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.getID();\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodId = minNode.get('id');\n    marks[minNodId] = true;\n    if (D[minNodId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (!directed) relatedEdges = minNode.getOutEdges();else relatedEdges = minNode.getEdges();\n    relatedEdges.forEach(function (e) {\n      var w = e.getTarget().getID();\n      var weight = weightPropertyName && e.getModel()[weightPropertyName] ? e.getModel()[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.get('id')] + weight) {\n        D[w] = D[minNode.get('id')] + weight;\n        prevs[w] = minNode.get('id');\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  var path = {};\n\n  for (var target in D) {\n    path[target] = [target];\n    var prev = prevs[target];\n\n    while (prev !== undefined) {\n      path[target].unshift(prev);\n      prev = prevs[prev];\n    }\n  }\n\n  return {\n    length: D,\n    path: path\n  };\n};\n\nfunction minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].get('id');\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n}\n\nexport default dijkstra;","map":{"version":3,"sources":["C:/Users/vietn/Desktop/AppEnegry2020/frontend/node_modules/@antv/g6/es/algorithm/dijkstra.js"],"names":["dijkstra","graph","source","directed","weightPropertyName","nodes","getNodes","nodeIds","marks","D","prevs","forEach","node","i","id","getID","push","Infinity","nodeNum","length","_loop_1","minNode","minVertex","minNodId","get","relatedEdges","getOutEdges","getEdges","e","w","getTarget","weight","getModel","path","target","prev","undefined","unshift","minDis","nodeId"],"mappings":"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","sourcesContent":["var dijkstra = function dijkstra(graph, source, directed, weightPropertyName) {\n  var nodes = graph.getNodes();\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.getID();\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodId = minNode.get('id');\n    marks[minNodId] = true;\n    if (D[minNodId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (!directed) relatedEdges = minNode.getOutEdges();else relatedEdges = minNode.getEdges();\n    relatedEdges.forEach(function (e) {\n      var w = e.getTarget().getID();\n      var weight = weightPropertyName && e.getModel()[weightPropertyName] ? e.getModel()[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.get('id')] + weight) {\n        D[w] = D[minNode.get('id')] + weight;\n        prevs[w] = minNode.get('id');\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  var path = {};\n\n  for (var target in D) {\n    path[target] = [target];\n    var prev = prevs[target];\n\n    while (prev !== undefined) {\n      path[target].unshift(prev);\n      prev = prevs[prev];\n    }\n  }\n\n  return {\n    length: D,\n    path: path\n  };\n};\n\nfunction minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].get('id');\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n}\n\nexport default dijkstra;"]},"metadata":{},"sourceType":"module"}