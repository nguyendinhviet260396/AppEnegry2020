{"ast":null,"code":"import { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport { PaddingCal } from './padding-cal';\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\n\nexport function calculatePadding(view) {\n  var padding = view.padding; // 如果不是 auto padding，那么直接解析之后返回\n\n  if (!isAutoPadding(padding)) {\n    return parsePadding(padding);\n  } // 是 auto padding，根据组件的情况，来计算 padding\n\n\n  var viewBBox = view.viewBBox,\n      autoPadding = view.autoPadding;\n  var paddingCal = new PaddingCal();\n  each(view.getComponents(), function (co) {\n    var component = co.component,\n        type = co.type; // grid, tooltip 不参入 padding 布局\n\n    if (type === COMPONENT_TYPE.GRID || type === COMPONENT_TYPE.TOOLTIP) {\n      return;\n    }\n\n    var bboxObject = component.getLayoutBBox();\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n\n    if (type === COMPONENT_TYPE.AXIS) {\n      var exceed = componentBBox.exceed(viewBBox);\n      paddingCal.shrink(exceed);\n    } else {\n      // 按照方向计算 padding\n      var direction = co.direction; // const direction =\n      //   type === COMPONENT_TYPE.AXIS ? getTranslateDirection(co.direction, view.getCoordinate()) : co.direction;\n\n      paddingCal.inc(componentBBox, direction);\n    }\n  });\n  var calculatedPadding = paddingCal.getPadding();\n\n  if (autoPadding) {\n    var appendPadding = parsePadding(view.appendPadding); // 取上一次以及当前计算结果的最大区间\n\n    return [Math.max(autoPadding[0] - appendPadding[0], calculatedPadding[0]), Math.max(autoPadding[1] - appendPadding[1], calculatedPadding[1]), Math.max(autoPadding[2] - appendPadding[2], calculatedPadding[2]), Math.max(autoPadding[3] - appendPadding[3], calculatedPadding[3])];\n  }\n\n  return calculatedPadding;\n}","map":{"version":3,"sources":["../../../src/chart/layout/auto.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAqB,YAArB;AACA,SAAS,cAAT,QAA+B,gBAA/B;AAEA,SAAS,IAAT,QAAqB,iBAArB;AACA,SAAS,aAAT,EAAwB,YAAxB,QAA4C,oBAA5C;AAEA,SAAS,UAAT,QAA2B,eAA3B;AAEA;;;;;;AAKA,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAAqC;AACzC,MAAM,OAAO,GAAG,IAAI,CAAC,OAArB,CADyC,CAGzC;;AACA,MAAI,CAAC,aAAa,CAAC,OAAD,CAAlB,EAA6B;AAC3B,WAAO,YAAY,CAAC,OAAD,CAAnB;AACD,GANwC,CAQzC;;;AACQ,MAAA,QAAQ,GAAkB,IAAI,CAAtB,QAAR;AAAA,MAAU,WAAW,GAAK,IAAI,CAAT,WAArB;AAER,MAAM,UAAU,GAAG,IAAI,UAAJ,EAAnB;AAEA,EAAA,IAAI,CAAC,IAAI,CAAC,aAAL,EAAD,EAAuB,UAAC,EAAD,EAAoB;AACrC,QAAA,SAAS,GAAW,EAAE,CAAb,SAAT;AAAA,QAAW,IAAI,GAAK,EAAE,CAAP,IAAf,CADqC,CAG7C;;AACA,QAAI,IAAI,KAAK,cAAc,CAAC,IAAxB,IAAgC,IAAI,KAAK,cAAc,CAAC,OAA5D,EAAqE;AACnE;AACD;;AAED,QAAM,UAAU,GAAG,SAAS,CAAC,aAAV,EAAnB;AACA,QAAM,aAAa,GAAG,IAAI,IAAJ,CAAS,UAAU,CAAC,CAApB,EAAuB,UAAU,CAAC,CAAlC,EAAqC,UAAU,CAAC,KAAhD,EAAuD,UAAU,CAAC,MAAlE,CAAtB;;AAEA,QAAI,IAAI,KAAK,cAAc,CAAC,IAA5B,EAAkC;AAChC,UAAM,MAAM,GAAG,aAAa,CAAC,MAAd,CAAqB,QAArB,CAAf;AACA,MAAA,UAAU,CAAC,MAAX,CAAkB,MAAlB;AACD,KAHD,MAGO;AACL;AACA,UAAM,SAAS,GAAG,EAAE,CAAC,SAArB,CAFK,CAIL;AACA;;AACA,MAAA,UAAU,CAAC,GAAX,CAAe,aAAf,EAA8B,SAA9B;AACD;AACF,GAtBG,CAAJ;AAwBA,MAAM,iBAAiB,GAAG,UAAU,CAAC,UAAX,EAA1B;;AAEA,MAAI,WAAJ,EAAiB;AACf,QAAM,aAAa,GAAG,YAAY,CAAC,IAAI,CAAC,aAAN,CAAlC,CADe,CAEf;;AACA,WAAO,CACL,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAD,CAAX,GAAiB,aAAa,CAAC,CAAD,CAAvC,EAA4C,iBAAiB,CAAC,CAAD,CAA7D,CADK,EAEL,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAD,CAAX,GAAiB,aAAa,CAAC,CAAD,CAAvC,EAA4C,iBAAiB,CAAC,CAAD,CAA7D,CAFK,EAGL,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAD,CAAX,GAAiB,aAAa,CAAC,CAAD,CAAvC,EAA4C,iBAAiB,CAAC,CAAD,CAA7D,CAHK,EAIL,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAD,CAAX,GAAiB,aAAa,CAAC,CAAD,CAAvC,EAA4C,iBAAiB,CAAC,CAAD,CAA7D,CAJK,CAAP;AAMD;;AAED,SAAO,iBAAP;AACD","sourcesContent":["import { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { ComponentOption, Padding } from '../../interface';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport View from '../view';\nimport { PaddingCal } from './padding-cal';\n\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\nexport function calculatePadding(view: View): Padding {\n  const padding = view.padding;\n\n  // 如果不是 auto padding，那么直接解析之后返回\n  if (!isAutoPadding(padding)) {\n    return parsePadding(padding);\n  }\n\n  // 是 auto padding，根据组件的情况，来计算 padding\n  const { viewBBox, autoPadding } = view;\n\n  const paddingCal = new PaddingCal();\n\n  each(view.getComponents(), (co: ComponentOption) => {\n    const { component, type } = co;\n\n    // grid, tooltip 不参入 padding 布局\n    if (type === COMPONENT_TYPE.GRID || type === COMPONENT_TYPE.TOOLTIP) {\n      return;\n    }\n\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n\n    if (type === COMPONENT_TYPE.AXIS) {\n      const exceed = componentBBox.exceed(viewBBox);\n      paddingCal.shrink(exceed);\n    } else {\n      // 按照方向计算 padding\n      const direction = co.direction;\n\n      // const direction =\n      //   type === COMPONENT_TYPE.AXIS ? getTranslateDirection(co.direction, view.getCoordinate()) : co.direction;\n      paddingCal.inc(componentBBox, direction);\n    }\n  });\n\n  const calculatedPadding = paddingCal.getPadding();\n\n  if (autoPadding) {\n    const appendPadding = parsePadding(view.appendPadding);\n    // 取上一次以及当前计算结果的最大区间\n    return [\n      Math.max(autoPadding[0] - appendPadding[0], calculatedPadding[0]),\n      Math.max(autoPadding[1] - appendPadding[1], calculatedPadding[1]),\n      Math.max(autoPadding[2] - appendPadding[2], calculatedPadding[2]),\n      Math.max(autoPadding[3] - appendPadding[3], calculatedPadding[3]),\n    ];\n  }\n\n  return calculatedPadding;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}