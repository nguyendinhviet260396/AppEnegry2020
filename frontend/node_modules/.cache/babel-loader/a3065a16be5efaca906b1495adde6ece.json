{"ast":null,"code":"import { head, filter, map, some } from '@antv/util';\nimport { ORIGIN } from '../dependents';\nexport function getAllGeometryByType(view, type) {\n  return filter(view.geometries, function (geometry) {\n    return geometry.type === type;\n  });\n}\nexport function getGeometryByType(view, type) {\n  return head(getAllGeometryByType(view, type));\n}\nexport function getGeometryShapes(geometry) {\n  return map(geometry.elements, function (element) {\n    return element.shape;\n  });\n}\nexport function forEachGeometry(view, callback) {\n  view.geometries.forEach(callback);\n}\nexport function forEachElement(view, callback) {\n  view.geometries.forEach(function (geometry) {\n    geometry.elements.forEach(function (element) {\n      callback(element);\n    });\n  });\n}\n/** 检测是否有和已存在的Shape数据`相等`的情况 */\n\nexport function checkOriginEqual(cur, dones, compare) {\n  return some(dones, function (done) {\n    return compare(done.get(ORIGIN), cur.get(ORIGIN));\n  });\n}\n/** 将label调整到panel内 */\n\nexport function moveInPanel(shape, panel) {\n  var box = shape.getBBox();\n  var deltaX = 0;\n  var deltaY = 0;\n\n  if (box.minX < panel.minX) {\n    deltaX = box.minX - panel.minX;\n  } else if (box.maxX > panel.maxX) {\n    deltaX = box.maxX - panel.maxX;\n  }\n\n  if (deltaX) {\n    shape.attr('x', shape.attr('x') - deltaX);\n  }\n\n  if (box.minY < panel.minY) {\n    deltaY = box.minY - panel.minY;\n  } else if (box.maxY > panel.maxY) {\n    deltaY = box.maxY - panel.maxY;\n  }\n\n  if (deltaY) {\n    shape.attr('y', shape.attr('y') - deltaY);\n  }\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\n\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\n\nexport function checkShapeOverlap(cur, dones) {\n  var box = cur.getBBox();\n  return some(dones, function (done) {\n    var target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}","map":{"version":3,"sources":["../../src/util/view.ts"],"names":[],"mappings":"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","sourcesContent":["import { head, filter, map, some } from '@antv/util';\nimport { View, Geometry, Element, IShape, IGroup, IElement, MappingDatum, ORIGIN } from '../dependents';\nimport BBox from '../util/bbox';\n\nexport function getAllGeometryByType(view: View, type: string): Geometry[] {\n  return filter(view.geometries, (geometry: Geometry) => geometry.type === type);\n}\n\nexport function getGeometryByType(view: View, type: string): Geometry | undefined {\n  return head(getAllGeometryByType(view, type));\n}\n\nexport function getGeometryShapes(geometry: Geometry): (IShape | IGroup)[] {\n  return map(geometry.elements, (element: Element) => element.shape);\n}\n\nexport function forEachGeometry(view: View, callback: (geometry: Geometry) => void) {\n  view.geometries.forEach(callback);\n}\n\nexport function forEachElement(view: View, callback: (element: Element) => void) {\n  view.geometries.forEach((geometry: Geometry) => {\n    geometry.elements.forEach((element) => {\n      callback(element);\n    });\n  });\n}\n\n/** 检测是否有和已存在的Shape数据`相等`的情况 */\nexport function checkOriginEqual(\n  cur: IElement,\n  dones: IElement[],\n  compare: (a: MappingDatum, b: MappingDatum) => boolean\n) {\n  return some(dones, (done) => {\n    return compare(done.get(ORIGIN), cur.get(ORIGIN));\n  });\n}\n\n/** 将label调整到panel内 */\nexport function moveInPanel(shape: IElement, panel: BBox) {\n  const box = shape.getBBox();\n  let deltaX = 0;\n  let deltaY = 0;\n\n  if (box.minX < panel.minX) {\n    deltaX = box.minX - panel.minX;\n  } else if (box.maxX > panel.maxX) {\n    deltaX = box.maxX - panel.maxX;\n  }\n  if (deltaX) {\n    shape.attr('x', shape.attr('x') - deltaX);\n  }\n\n  if (box.minY < panel.minY) {\n    deltaY = box.minY - panel.minY;\n  } else if (box.maxY > panel.maxY) {\n    deltaY = box.maxY - panel.maxY;\n  }\n  if (deltaY) {\n    shape.attr('y', shape.attr('y') - deltaY);\n  }\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}