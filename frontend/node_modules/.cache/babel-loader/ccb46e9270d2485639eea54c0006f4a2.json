{"ast":null,"code":"import { each } from '@antv/util';\nimport { isNodeOverlap } from './clear-overlapping';\n/** 图形向上抖开并拉线 */\n// todo 允许设置offset和拉线样式\n\nexport default function nodeJitterUpward(shape, option, index, cfg) {\n  var nodes = cfg.nodes.nodes;\n\n  if (index === 0) {\n    return;\n  }\n\n  var current = nodes[index];\n  var previous = nodes[index - 1];\n\n  if (isNodeOverlap(current, previous)) {\n    var element = cfg.plot.view.geometries[0].elements[0];\n    var y = previous.top - current.height / 2;\n    var offset = 10;\n\n    if (y - offset > cfg.region.top) {\n      // 取到label对应的element-shape\n      var origin_1 = current.shape.get('origin');\n      var shapeId = element.getShapeId(origin_1);\n      var shapes = element.getShapes();\n      var shapeBbox = getShapeById(shapeId, shapes).get('box');\n      var originX = shapeBbox.left + shapeBbox.width / 2;\n      var originY = shapeBbox.top; // 拉线\n\n      var container = element.get('labelController').labelsContainer;\n      var labelLine = container.addShape('path', {\n        attrs: {\n          path: [['M', originX, originY], ['L', current.shape.attr('x'), y]],\n          stroke: '#ccc',\n          lineWidth: 1\n        }\n      });\n      /** 保存labelLine和label初始位置信息 */\n\n      var origin_position = {\n        x: shape.attr('x'),\n        y: shape.attr('y')\n      }; // 更新标签位置，同步更新node\n\n      current.shape.attr('y', y - offset);\n      nodes[index] = cfg.nodes.measure(current.shape);\n      nodes[index].line = labelLine;\n      nodes[index].origin_position = origin_position;\n    }\n  }\n}\n\nfunction getShapeById(shapeId, shapes) {\n  var target;\n  each(shapes, function (shape) {\n    var s = shape;\n    var id = s.get('id');\n\n    if (id === shapeId) {\n      target = s;\n    }\n  });\n  return target;\n}","map":{"version":3,"sources":["../../../../src/util/responsive/rules/node-jitter-upward.ts"],"names":[],"mappings":"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","sourcesContent":["import { IShape } from '@antv/g-base';\nimport { each } from '@antv/util';\nimport { isNodeOverlap } from './clear-overlapping';\n\n/** 图形向上抖开并拉线 */\n// todo 允许设置offset和拉线样式\nexport default function nodeJitterUpward(shape: IShape, option, index, cfg) {\n  const nodes = cfg.nodes.nodes;\n  if (index === 0) {\n    return;\n  }\n  const current = nodes[index];\n  const previous = nodes[index - 1];\n  if (isNodeOverlap(current, previous)) {\n    const element = cfg.plot.view.geometries[0].elements[0];\n    const y = previous.top - current.height / 2;\n    const offset = 10;\n    if (y - offset > cfg.region.top) {\n      // 取到label对应的element-shape\n      const origin = current.shape.get('origin');\n      const shapeId = element.getShapeId(origin);\n      const shapes = element.getShapes();\n      const shapeBbox = getShapeById(shapeId, shapes).get('box');\n      const originX = shapeBbox.left + shapeBbox.width / 2;\n      const originY = shapeBbox.top;\n      // 拉线\n      const container = element.get('labelController').labelsContainer;\n      const labelLine = container.addShape('path', {\n        attrs: {\n          path: [\n            ['M', originX, originY],\n            ['L', current.shape.attr('x'), y],\n          ],\n          stroke: '#ccc',\n          lineWidth: 1,\n        },\n      });\n      /** 保存labelLine和label初始位置信息 */\n      const origin_position = { x: shape.attr('x'), y: shape.attr('y') };\n      // 更新标签位置，同步更新node\n      current.shape.attr('y', y - offset);\n      nodes[index] = cfg.nodes.measure(current.shape);\n      nodes[index].line = labelLine;\n      nodes[index].origin_position = origin_position;\n    }\n  }\n}\n\nfunction getShapeById(shapeId, shapes) {\n  let target;\n  each(shapes, (shape) => {\n    const s = shape as IShape;\n    const id = s.get('id');\n    if (id === shapeId) {\n      target = s;\n    }\n  });\n  return target;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}