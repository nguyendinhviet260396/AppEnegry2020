{"ast":null,"code":"import { __extends } from \"tslib\";\n/** 简化折线点 */\n\nimport { registerShape } from '../../dependents';\nimport { deepMix, mix } from '@antv/util';\nimport { lineSimplification } from '../../util/math';\nimport { getSplinePath } from '../../util/path';\nimport LineParser from './main';\nimport { getGlobalTheme } from '../../theme';\nregisterShape('line', 'miniLine', {\n  draw: function (cfg, container) {\n    var points = lineSimplification(cfg.points);\n    var path = [];\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var flag = i === 0 ? 'M' : 'L';\n      path.push([flag, p.x, p.y]);\n    }\n\n    var style = deepMix({}, {\n      lineJoin: 'round',\n      lineCap: 'round'\n    }, cfg.style);\n    var shape = container.addShape('path', {\n      attrs: mix({\n        path: path,\n        stroke: cfg.color || getGlobalTheme().defaultColor,\n        lineWidth: cfg.size || 2\n      }, style)\n    });\n    return shape;\n  }\n});\nregisterShape('line', 'miniLineSmooth', {\n  draw: function (cfg, container) {\n    var points = lineSimplification(cfg.points);\n    var constraint = [[0, 0], [1, 1]];\n    var path = getSplinePath(points, false, constraint);\n    var shape = container.addShape('path', {\n      attrs: mix({\n        path: path,\n        stroke: cfg.color || getGlobalTheme().defaultColor,\n        lineWidth: cfg.size || 2\n      }, cfg.style)\n    });\n    return shape;\n  }\n});\n\nvar MiniLineParser =\n/** @class */\nfunction (_super) {\n  __extends(MiniLineParser, _super);\n\n  function MiniLineParser() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MiniLineParser.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.parseShape();\n  };\n\n  MiniLineParser.prototype.parseShape = function () {\n    var props = this.plot.options;\n\n    if (props.smooth) {\n      this.config.shape = {\n        values: ['miniLineSmooth']\n      };\n    } else {\n      this.config.shape = {\n        values: ['miniLine']\n      };\n    }\n  };\n\n  return MiniLineParser;\n}(LineParser);\n\nexport default MiniLineParser;","map":{"version":3,"sources":["../../../src/geoms/line/mini.ts"],"names":[],"mappings":";AAAA;;AACA,SAAS,aAAT,QAA8B,kBAA9B;AACA,SAAS,OAAT,EAAkB,GAAlB,QAA6B,YAA7B;AACA,SAAS,kBAAT,QAAmC,iBAAnC;AACA,SAAS,aAAT,QAA8B,iBAA9B;AACA,OAAO,UAAP,MAAuB,QAAvB;AACA,SAAS,cAAT,QAA+B,aAA/B;AAEA,aAAa,CAAC,MAAD,EAAS,UAAT,EAAqB;AAChC,EAAA,IAAI,EAAA,UAAC,GAAD,EAAM,SAAN,EAAe;AACjB,QAAM,MAAM,GAAG,kBAAkB,CAAC,GAAG,CAAC,MAAL,CAAjC;AACA,QAAM,IAAI,GAAG,EAAb;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,UAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAhB;AACA,UAAM,IAAI,GAAG,CAAC,KAAK,CAAN,GAAU,GAAV,GAAgB,GAA7B;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,CAAC,IAAD,EAAO,CAAC,CAAC,CAAT,EAAY,CAAC,CAAC,CAAd,CAAV;AACD;;AACD,QAAM,KAAK,GAAG,OAAO,CACnB,EADmB,EAEnB;AACE,MAAA,QAAQ,EAAE,OADZ;AAEE,MAAA,OAAO,EAAE;AAFX,KAFmB,EAMnB,GAAG,CAAC,KANe,CAArB;AAQA,QAAM,KAAK,GAAG,SAAS,CAAC,QAAV,CAAmB,MAAnB,EAA2B;AACvC,MAAA,KAAK,EAAE,GAAG,CACR;AACE,QAAA,IAAI,EAAA,IADN;AAEE,QAAA,MAAM,EAAE,GAAG,CAAC,KAAJ,IAAa,cAAc,GAAG,YAFxC;AAGE,QAAA,SAAS,EAAE,GAAG,CAAC,IAAJ,IAAY;AAHzB,OADQ,EAMR,KANQ;AAD6B,KAA3B,CAAd;AAUA,WAAO,KAAP;AACD;AA5B+B,CAArB,CAAb;AA+BA,aAAa,CAAC,MAAD,EAAS,gBAAT,EAA2B;AACtC,EAAA,IAAI,EAAA,UAAC,GAAD,EAAM,SAAN,EAAe;AACjB,QAAM,MAAM,GAAG,kBAAkB,CAAC,GAAG,CAAC,MAAL,CAAjC;AACA,QAAM,UAAU,GAAG,CACjB,CAAC,CAAD,EAAI,CAAJ,CADiB,EAEjB,CAAC,CAAD,EAAI,CAAJ,CAFiB,CAAnB;AAIA,QAAM,IAAI,GAAG,aAAa,CAAC,MAAD,EAAS,KAAT,EAAgB,UAAhB,CAA1B;AACA,QAAM,KAAK,GAAG,SAAS,CAAC,QAAV,CAAmB,MAAnB,EAA2B;AACvC,MAAA,KAAK,EAAE,GAAG,CACR;AACE,QAAA,IAAI,EAAA,IADN;AAEE,QAAA,MAAM,EAAE,GAAG,CAAC,KAAJ,IAAa,cAAc,GAAG,YAFxC;AAGE,QAAA,SAAS,EAAE,GAAG,CAAC,IAAJ,IAAY;AAHzB,OADQ,EAMR,GAAG,CAAC,KANI;AAD6B,KAA3B,CAAd;AAUA,WAAO,KAAP;AACD;AAnBqC,CAA3B,CAAb;;AAsBA,IAAA,cAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA4C,EAAA,SAAA,CAAA,cAAA,EAAA,MAAA,CAAA;;AAA5C,WAAA,cAAA,GAAA;;AAcC;;AAbQ,EAAA,cAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AACE,IAAA,MAAA,CAAA,SAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV;;AACA,SAAK,UAAL;AACD,GAHM;;AAKC,EAAA,cAAA,CAAA,SAAA,CAAA,UAAA,GAAR,YAAA;AACE,QAAM,KAAK,GAAG,KAAK,IAAL,CAAU,OAAxB;;AACA,QAAI,KAAK,CAAC,MAAV,EAAkB;AAChB,WAAK,MAAL,CAAY,KAAZ,GAAoB;AAAE,QAAA,MAAM,EAAE,CAAC,gBAAD;AAAV,OAApB;AACD,KAFD,MAEO;AACL,WAAK,MAAL,CAAY,KAAZ,GAAoB;AAAE,QAAA,MAAM,EAAE,CAAC,UAAD;AAAV,OAApB;AACD;AACF,GAPO;;AAQV,SAAA,cAAA;AAAC,CAdD,CAA4C,UAA5C,CAAA","sourcesContent":["/** 简化折线点 */\nimport { registerShape } from '../../dependents';\nimport { deepMix, mix } from '@antv/util';\nimport { lineSimplification } from '../../util/math';\nimport { getSplinePath } from '../../util/path';\nimport LineParser from './main';\nimport { getGlobalTheme } from '../../theme';\n\nregisterShape('line', 'miniLine', {\n  draw(cfg, container) {\n    const points = lineSimplification(cfg.points);\n    const path = [];\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i];\n      const flag = i === 0 ? 'M' : 'L';\n      path.push([flag, p.x, p.y]);\n    }\n    const style = deepMix(\n      {},\n      {\n        lineJoin: 'round',\n        lineCap: 'round',\n      },\n      cfg.style\n    );\n    const shape = container.addShape('path', {\n      attrs: mix(\n        {\n          path,\n          stroke: cfg.color || getGlobalTheme().defaultColor,\n          lineWidth: cfg.size || 2,\n        },\n        style\n      ),\n    });\n    return shape;\n  },\n});\n\nregisterShape('line', 'miniLineSmooth', {\n  draw(cfg, container) {\n    const points = lineSimplification(cfg.points);\n    const constraint = [\n      [0, 0],\n      [1, 1],\n    ];\n    const path = getSplinePath(points, false, constraint);\n    const shape = container.addShape('path', {\n      attrs: mix(\n        {\n          path,\n          stroke: cfg.color || getGlobalTheme().defaultColor,\n          lineWidth: cfg.size || 2,\n        },\n        cfg.style\n      ),\n    });\n    return shape;\n  },\n});\n\nexport default class MiniLineParser extends LineParser {\n  public init() {\n    super.init();\n    this.parseShape();\n  }\n\n  private parseShape() {\n    const props = this.plot.options;\n    if (props.smooth) {\n      this.config.shape = { values: ['miniLineSmooth'] };\n    } else {\n      this.config.shape = { values: ['miniLine'] };\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}