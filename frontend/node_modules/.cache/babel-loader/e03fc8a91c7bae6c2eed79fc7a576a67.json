{"ast":null,"code":"import { vec3 } from '@antv/matrix-util';\nimport { each, clone } from '@antv/util';\n\nfunction magnitude(v) {\n  var sum = 0;\n  each(v, function (value) {\n    sum += value * value;\n  });\n  return Math.sqrt(sum);\n}\n\nfunction dotProduct2D(va, vb) {\n  return va.x * vb.y + va.y * vb.x;\n}\n\nfunction angleTo(va, vb) {\n  var magA = magnitude(va);\n  var magB = magnitude(vb);\n  var dot = dotProduct2D(va, vb);\n  var angle = Math.acos(dot / magA / magB);\n  return angle;\n}\n\nfunction crossProduct2D(va, vb) {\n  var magA = magnitude(va);\n  var magB = magnitude(vb);\n  var dot = dotProduct2D(va, vb);\n  var angle = Math.acos(dot / magA / magB);\n  return magA * magB * Math.sin(angle);\n}\n\nfunction crossProduct3D(va, vb) {\n  var ax = va.x,\n      ay = va.y,\n      az = va.z;\n  var bx = vb.x,\n      by = vb.y,\n      bz = vb.z;\n  var x = ay * bz - az * by;\n  var y = az * bx - ax * bz;\n  var z = ax * by - ay * bx;\n  return {\n    x: x,\n    y: y,\n    z: z\n  };\n}\n\nfunction sub2D(va, vb) {\n  return {\n    x: va.x - vb.x,\n    y: va.y - vb.y\n  };\n}\n\nfunction applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n}\n\nfunction isBetween(value, min, max) {\n  return value >= min && value <= max;\n}\n\nvar tolerance = 0.001;\n\nfunction getLineIntersect(p0, p1, p2, p3) {\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n  var point = null;\n\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) / kross;\n    var t = (E.x * D0.y - E.y * D0.x) / kross;\n\n    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {\n      point = {\n        x: p0.x + s * D0.x,\n        y: p0.y + s * D0.y\n      };\n    }\n  }\n\n  return point;\n}\n\nfunction isPointInPolygon(p, polygon) {\n  /** 射线法 */\n  var inside = false;\n\n  for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    var xi = polygon[i].x;\n    var yi = polygon[i].y;\n    var xj = polygon[j].x;\n    var yj = polygon[j].y;\n    var intersect = yi > p.y !== yj > p.y && p.x <= (xj - xi) * (p.y - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\nfunction sqr(v) {\n  return v * v;\n}\n\nfunction dist2(a, b) {\n  return Math.sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nfunction distBetweenPoints(a, b) {\n  return Math.sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nfunction distBetweenPointLine(p, p1, p2) {\n  var l2 = dist2(p1, p2);\n\n  if (l2 === 0) {\n    return dist2(p, p1);\n  }\n\n  var t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / l2;\n  t = Math.max(0, Math.min(1, t));\n  var distSquare = dist2(p, {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  });\n  return Math.sqrt(distSquare);\n} // todo：待优化 https://blog.csdn.net/WilliamSun0122/article/details/77994526\n\n\nfunction minDistBetweenPointPolygon(p, polygon) {\n  var min = Infinity;\n  /** vertice to vertice */\n\n  each(polygon, function (v) {\n    var dist = Math.sqrt(dist2(v, p));\n\n    if (min > dist) {\n      min = dist;\n    }\n  });\n  /** vertice to edge */\n\n  for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    var xi = polygon[i].x;\n    var yi = polygon[i].y;\n    var xj = polygon[j].x;\n    var yj = polygon[j].y;\n    var dist = distBetweenPointLine(p, {\n      x: xi,\n      y: yi\n    }, {\n      x: xj,\n      y: yj\n    });\n\n    if (min > dist) {\n      min = dist;\n    }\n  }\n\n  return min;\n}\n\nfunction isPolygonIntersection(polyA, polyB) {\n  for (var _i = 0, polyA_1 = polyA; _i < polyA_1.length; _i++) {\n    var p = polyA_1[_i];\n    var inside = isPointInPolygon(p, polyB);\n\n    if (inside) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction minDistBetweenConvexPolygon(polyA, polyB) {\n  if (isPolygonIntersection(polyA, polyB)) {\n    return 0;\n  }\n\n  var minA = Infinity;\n  var minB = Infinity;\n  each(polyA, function (v) {\n    var localMin = minDistBetweenPointPolygon(v, polyB);\n\n    if (minA > localMin) {\n      minA = localMin;\n    }\n  });\n  each(polyB, function (v) {\n    var localMin = minDistBetweenPointPolygon(v, polyA);\n\n    if (minB > localMin) {\n      minB = localMin;\n    }\n  });\n  return Math.min(minA, minB);\n}\n\nfunction bboxOnRotate(shape) {\n  var bbox = shape.getBBox();\n  var x = bbox.minX;\n  var y = bbox.minY;\n  /*\n   * step1: 获得旋转后的shape包围盒\n   * 将包围盒对齐到原点，apply旋转矩阵\n   * 移回原来的位置\n   */\n\n  var bboxWidth = bbox.maxX - bbox.minX;\n  var bboxHeight = bbox.maxY - bbox.minY; // const matrix = shape.getTotalMatrix();\n\n  var matrix = shape.attr('matrix');\n  var ulMatrix;\n\n  if (matrix) {\n    ulMatrix = [matrix[0], matrix[1], 0, matrix[3], matrix[4], 0, 0, 0, 1];\n  } else {\n    ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var top_left = applyMatrix({\n    x: 0,\n    y: 0\n  }, ulMatrix);\n  top_left.x += x;\n  top_left.y += y;\n  var top_right = applyMatrix({\n    x: bboxWidth,\n    y: 0\n  }, ulMatrix);\n  top_right.x += x;\n  top_right.y += y;\n  var bottom_left = applyMatrix({\n    x: 0,\n    y: bboxHeight\n  }, ulMatrix);\n  bottom_left.x += x;\n  bottom_left.y += y;\n  var bottom_right = applyMatrix({\n    x: bboxWidth,\n    y: bboxHeight\n  }, ulMatrix);\n  bottom_right.x += x;\n  bottom_right.y += y;\n  /** step2：根据旋转后的画布位置重新计算包围盒，以免图形进行旋转后上下颠倒 */\n\n  var points = [top_left, top_right, bottom_left, bottom_right];\n  points.sort(function (a, b) {\n    return a.y - b.y;\n  });\n  var minY = points[0].y;\n  var maxY = points[points.length - 1].y;\n  var tops = [points[0], points[1]];\n  var bottoms = [points[2], points[3]];\n  var topLeft = tops[0].x < tops[1].x ? tops[0] : tops[1];\n  var topRight = tops[0].x < tops[1].x ? tops[1] : tops[0];\n  var bottomLeft = bottoms[0].x < bottoms[1].x ? bottoms[0] : bottoms[1];\n  var bottomRight = bottoms[0].x < bottoms[1].x ? bottoms[1] : bottoms[0];\n  points.sort(function (a, b) {\n    return a.x - b.x;\n  });\n  var minX = points[0].x;\n  var maxX = points[points.length - 1].x;\n  var node = {\n    width: maxX - minX,\n    height: maxY - minY,\n    left: minX,\n    right: maxX,\n    top: minY,\n    bottom: maxY,\n    topLeft: topLeft,\n    topRight: topRight,\n    bottomLeft: bottomLeft,\n    bottomRight: bottomRight,\n    centerX: minX + (maxX - minX) / 2,\n    centerY: minY + (maxY - minY) / 2\n  };\n  return node;\n}\n/**\n * 线简化算法\n */\n\n\nvar THRESHOLD = 2;\n\nfunction lineSimplification(points) {\n  if (points.length < 5) {\n    return points;\n  }\n\n  return DouglasPeucker(points, THRESHOLD);\n} // https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n\n\nfunction DouglasPeucker(points, threshold) {\n  var result;\n  var max = -Infinity;\n  var index = 0;\n  var endIndex = points.length - 1;\n\n  for (var i = 1; i < endIndex; i++) {\n    var point = points[i];\n    var line = {\n      start: points[0],\n      end: points[endIndex]\n    };\n    var dist = distBetweenPointLine(point, line.start, line.end);\n\n    if (dist > max) {\n      max = dist;\n      index = i;\n    }\n  }\n\n  if (max > threshold) {\n    var list1 = DouglasPeucker(points.slice(0, index + 1), threshold);\n    var list2 = DouglasPeucker(points.slice(index, points.length), threshold);\n    result = list1.concat(list2);\n  } else {\n    result = [points[0], points[points.length - 1]];\n  }\n\n  return result;\n}\n/** 统计的以后迁出去，暂时先放这里 */\n\n\nfunction getMedian(array) {\n  var list = clone(array);\n  list.sort(function (a, b) {\n    return a - b;\n  });\n  var half = Math.floor(list.length / 2);\n\n  if (list.length % 2) {\n    return list[half];\n  }\n\n  return (list[half - 1] + list[half]) / 2.0;\n}\n\nfunction getMean(array) {\n  var sum = 0;\n  each(array, function (num) {\n    sum += num;\n  });\n  return sum / array.length;\n}\n\nfunction sturges(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n\nexport { applyMatrix, isBetween, getLineIntersect, isPointInPolygon, distBetweenPoints, distBetweenPointLine, isPolygonIntersection, minDistBetweenConvexPolygon, bboxOnRotate, dotProduct2D, crossProduct2D, crossProduct3D, sub2D, angleTo, lineSimplification, getMedian, getMean, sturges, dist2 };\n/**\n * 获取 x/y/width/height指定的BBox边界上的所有点，由step抽样\n * @param x\n * @param y\n * @param width\n * @param height\n * @param step\n */\n\nexport function getStrokePoints(x, y, width, height, step) {\n  if (step === void 0) {\n    step = 2;\n  }\n\n  var points = []; // top\n\n  for (var curX = x; curX <= x + width; curX += step) {\n    points.push([curX, y]);\n  } // right\n\n\n  for (var curY = y; curY <= y + height; curY += step) {\n    points.push([x + width, curY]);\n  } // bottom\n\n\n  for (var curX = x + width; curX >= x; curX -= step) {\n    points.push([curX, y + height]);\n  } // left\n\n\n  for (var curY = y + height; curY >= y; curY -= step) {\n    points.push([x, curY]);\n  }\n\n  return points;\n}","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourcesContent":["import { vec3 } from '@antv/matrix-util';\nimport { each, clone } from '@antv/util';\n\nfunction magnitude(v) {\n  let sum = 0;\n  each(v, (value) => {\n    sum += value * value;\n  });\n  return Math.sqrt(sum);\n}\n\nfunction dotProduct2D(va, vb) {\n  return va.x * vb.y + va.y * vb.x;\n}\n\nfunction angleTo(va, vb) {\n  const magA = magnitude(va);\n  const magB = magnitude(vb);\n  const dot = dotProduct2D(va, vb);\n  const angle = Math.acos(dot / magA / magB);\n  return angle;\n}\n\nfunction crossProduct2D(va, vb) {\n  const magA = magnitude(va);\n  const magB = magnitude(vb);\n  const dot = dotProduct2D(va, vb);\n  const angle = Math.acos(dot / magA / magB);\n  return magA * magB * Math.sin(angle);\n}\n\nfunction crossProduct3D(va, vb) {\n  const ax = va.x,\n    ay = va.y,\n    az = va.z;\n  const bx = vb.x,\n    by = vb.y,\n    bz = vb.z;\n\n  const x = ay * bz - az * by;\n  const y = az * bx - ax * bz;\n  const z = ax * by - ay * bx;\n\n  return { x, y, z };\n}\n\nfunction sub2D(va, vb) {\n  return { x: va.x - vb.x, y: va.y - vb.y };\n}\n\nfunction applyMatrix(point, matrix, tag = 1) {\n  const vector: [number, number, number] = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1],\n  };\n}\n\nfunction isBetween(value, min, max) {\n  return value >= min && value <= max;\n}\n\nconst tolerance = 0.001;\n\nfunction getLineIntersect(p0, p1, p2, p3) {\n  const E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y,\n  };\n  const D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y,\n  };\n  const D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y,\n  };\n  const kross = D0.x * D1.y - D0.y * D1.x;\n  const sqrKross = kross * kross;\n  const sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  const sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n  let point = null;\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    const s = (E.x * D1.y - E.y * D1.x) / kross;\n    const t = (E.x * D0.y - E.y * D0.x) / kross;\n    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {\n      point = {\n        x: p0.x + s * D0.x,\n        y: p0.y + s * D0.y,\n      };\n    }\n  }\n  return point;\n}\n\nfunction isPointInPolygon(p, polygon) {\n  /** 射线法 */\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    const intersect = yi > p.y !== yj > p.y && p.x <= ((xj - xi) * (p.y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n  return inside;\n}\n\nfunction sqr(v) {\n  return v * v;\n}\n\nfunction dist2(a, b) {\n  return Math.sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nfunction distBetweenPoints(a, b) {\n  return Math.sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nfunction distBetweenPointLine(p, p1, p2) {\n  const l2 = dist2(p1, p2);\n  if (l2 === 0) {\n    return dist2(p, p1);\n  }\n  let t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / l2;\n  t = Math.max(0, Math.min(1, t));\n  const distSquare = dist2(p, { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) });\n  return Math.sqrt(distSquare);\n}\n\n// todo：待优化 https://blog.csdn.net/WilliamSun0122/article/details/77994526\nfunction minDistBetweenPointPolygon(p, polygon) {\n  let min = Infinity;\n  /** vertice to vertice */\n  each(polygon, (v) => {\n    const dist = Math.sqrt(dist2(v, p));\n    if (min > dist) {\n      min = dist;\n    }\n  });\n  /** vertice to edge */\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    const dist = distBetweenPointLine(p, { x: xi, y: yi }, { x: xj, y: yj });\n    if (min > dist) {\n      min = dist;\n    }\n  }\n\n  return min;\n}\n\nfunction isPolygonIntersection(polyA, polyB) {\n  for (const p of polyA) {\n    const inside = isPointInPolygon(p, polyB);\n    if (inside) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction minDistBetweenConvexPolygon(polyA, polyB) {\n  if (isPolygonIntersection(polyA, polyB)) {\n    return 0;\n  }\n  let minA = Infinity;\n  let minB = Infinity;\n  each(polyA, (v) => {\n    const localMin = minDistBetweenPointPolygon(v, polyB);\n    if (minA > localMin) {\n      minA = localMin;\n    }\n  });\n  each(polyB, (v) => {\n    const localMin = minDistBetweenPointPolygon(v, polyA);\n    if (minB > localMin) {\n      minB = localMin;\n    }\n  });\n\n  return Math.min(minA, minB);\n}\n\nfunction bboxOnRotate(shape) {\n  const bbox = shape.getBBox();\n  const x = bbox.minX;\n  const y = bbox.minY;\n  /*\n   * step1: 获得旋转后的shape包围盒\n   * 将包围盒对齐到原点，apply旋转矩阵\n   * 移回原来的位置\n   */\n  const bboxWidth = bbox.maxX - bbox.minX;\n  const bboxHeight = bbox.maxY - bbox.minY;\n  // const matrix = shape.getTotalMatrix();\n  const matrix = shape.attr('matrix');\n  let ulMatrix;\n  if (matrix) {\n    ulMatrix = [matrix[0], matrix[1], 0, matrix[3], matrix[4], 0, 0, 0, 1];\n  } else {\n    ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  const top_left = applyMatrix({ x: 0, y: 0 }, ulMatrix);\n  top_left.x += x;\n  top_left.y += y;\n  const top_right = applyMatrix({ x: bboxWidth, y: 0 }, ulMatrix);\n  top_right.x += x;\n  top_right.y += y;\n  const bottom_left = applyMatrix({ x: 0, y: bboxHeight }, ulMatrix);\n  bottom_left.x += x;\n  bottom_left.y += y;\n  const bottom_right = applyMatrix({ x: bboxWidth, y: bboxHeight }, ulMatrix);\n  bottom_right.x += x;\n  bottom_right.y += y;\n  /** step2：根据旋转后的画布位置重新计算包围盒，以免图形进行旋转后上下颠倒 */\n  const points = [top_left, top_right, bottom_left, bottom_right];\n  points.sort((a, b) => {\n    return a.y - b.y;\n  });\n  const minY = points[0].y;\n  const maxY = points[points.length - 1].y;\n  const tops = [points[0], points[1]];\n  const bottoms = [points[2], points[3]];\n  const topLeft = tops[0].x < tops[1].x ? tops[0] : tops[1];\n  const topRight = tops[0].x < tops[1].x ? tops[1] : tops[0];\n  const bottomLeft = bottoms[0].x < bottoms[1].x ? bottoms[0] : bottoms[1];\n  const bottomRight = bottoms[0].x < bottoms[1].x ? bottoms[1] : bottoms[0];\n  points.sort((a, b) => {\n    return a.x - b.x;\n  });\n  const minX = points[0].x;\n  const maxX = points[points.length - 1].x;\n  const node = {\n    width: maxX - minX,\n    height: maxY - minY,\n    left: minX,\n    right: maxX,\n    top: minY,\n    bottom: maxY,\n    topLeft,\n    topRight,\n    bottomLeft,\n    bottomRight,\n    centerX: minX + (maxX - minX) / 2,\n    centerY: minY + (maxY - minY) / 2,\n    // shape\n  };\n  return node;\n}\n\n/**\n * 线简化算法\n */\n\nconst THRESHOLD = 2;\n\nfunction lineSimplification(points) {\n  if (points.length < 5) {\n    return points;\n  }\n  return DouglasPeucker(points, THRESHOLD);\n}\n\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction DouglasPeucker(points, threshold) {\n  let result;\n  let max = -Infinity;\n  let index = 0;\n  const endIndex = points.length - 1;\n  for (let i = 1; i < endIndex; i++) {\n    const point = points[i];\n    const line = { start: points[0], end: points[endIndex] };\n    const dist = distBetweenPointLine(point, line.start, line.end);\n    if (dist > max) {\n      max = dist;\n      index = i;\n    }\n  }\n\n  if (max > threshold) {\n    const list1 = DouglasPeucker(points.slice(0, index + 1), threshold);\n    const list2 = DouglasPeucker(points.slice(index, points.length), threshold);\n    result = list1.concat(list2);\n  } else {\n    result = [points[0], points[points.length - 1]];\n  }\n  return result;\n}\n\n/** 统计的以后迁出去，暂时先放这里 */\nfunction getMedian(array) {\n  const list = clone(array);\n  list.sort((a, b) => {\n    return a - b;\n  });\n\n  const half = Math.floor(list.length / 2);\n\n  if (list.length % 2) {\n    return list[half];\n  }\n\n  return (list[half - 1] + list[half]) / 2.0;\n}\n\nfunction getMean(array) {\n  let sum: number = 0;\n  each(array, (num: number) => {\n    sum += num;\n  });\n  return sum / array.length;\n}\n\nfunction sturges(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n\nexport {\n  applyMatrix,\n  isBetween,\n  getLineIntersect,\n  isPointInPolygon,\n  distBetweenPoints,\n  distBetweenPointLine,\n  isPolygonIntersection,\n  minDistBetweenConvexPolygon,\n  bboxOnRotate,\n  dotProduct2D,\n  crossProduct2D,\n  crossProduct3D,\n  sub2D,\n  angleTo,\n  lineSimplification,\n  getMedian,\n  getMean,\n  sturges,\n  dist2,\n};\n\n/**\n * 获取 x/y/width/height指定的BBox边界上的所有点，由step抽样\n * @param x\n * @param y\n * @param width\n * @param height\n * @param step\n */\nexport function getStrokePoints(x: number, y: number, width: number, height: number, step = 2) {\n  const points: Array<[number, number]> = [];\n  // top\n  for (let curX = x; curX <= x + width; curX += step) {\n    points.push([curX, y]);\n  }\n  // right\n  for (let curY = y; curY <= y + height; curY += step) {\n    points.push([x + width, curY]);\n  }\n  // bottom\n  for (let curX = x + width; curX >= x; curX -= step) {\n    points.push([curX, y + height]);\n  }\n  // left\n  for (let curY = y + height; curY >= y; curY -= step) {\n    points.push([x, curY]);\n  }\n  return points;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}