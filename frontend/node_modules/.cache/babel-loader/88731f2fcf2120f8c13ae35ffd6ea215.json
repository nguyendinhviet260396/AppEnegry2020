{"ast":null,"code":"import { assign } from '@antv/util';\nimport { constraintsLib } from './constraints/index';\nimport { rulesLib } from './rules/index';\n\nvar Responsive =\n/** @class */\nfunction () {\n  function Responsive(cfg) {\n    this.iterationTime = 10;\n    this.iterationIndex = 0;\n    this.rulesLocker = [];\n    this.constraintIndex = 0;\n    assign(this, cfg);\n    this.currentConstraint = this.constraints[0];\n\n    if (this.rules) {\n      this.iterationTime = this.rules[this.currentConstraint.name].length;\n    }\n\n    this._start();\n\n    this._run();\n\n    this._end();\n  }\n\n  Responsive.prototype._start = function () {\n    if (this.onStart) {\n      this.onStart(this.nodes);\n    }\n  };\n\n  Responsive.prototype._iteration = function () {\n    var nodes;\n\n    if (this.nodes.type === 'shape') {\n      nodes = this.nodes;\n    } else {\n      nodes = this.nodes;\n    }\n\n    if (nodes.type === 'shape') {\n      nodes.measureNodes();\n    }\n\n    if (this.rules) {\n      this._applyRules();\n    }\n\n    if (nodes.type === 'shape') {\n      nodes.measureNodes();\n    }\n\n    if (this.onIteration) {\n      this.onIteration(this.nodes);\n    }\n  };\n\n  Responsive.prototype._end = function () {\n    if (this.onEnd) {\n      this.onEnd(this.nodes);\n    }\n  };\n\n  Responsive.prototype._run = function () {\n    var constraintPassed = this._constraintsTest();\n\n    while (!constraintPassed) {\n      if (this.iterationIndex > this.iterationTime - 1) {\n        break;\n      }\n\n      this._iteration();\n\n      constraintPassed = this._constraintsTest();\n      this.iterationIndex++;\n    }\n\n    if (this.constraintIndex < this.constraints.length - 1) {\n      this.constraintIndex++;\n      this.currentConstraint = this.constraints[this.constraintIndex];\n      this.iterationTime = this.rules ? this.rules[this.currentConstraint.name].length : 1;\n      this.iterationIndex = 0;\n\n      this._run();\n    }\n  };\n\n  Responsive.prototype._constraintsTest = function () {\n    var constraint = constraintsLib[this.currentConstraint.name];\n    var constraintOption = this.currentConstraint.option;\n\n    if (constraint.usage === 'compare') {\n      return this._constraintCompare(constraint, constraintOption);\n    }\n\n    return this._constraintAssignment(constraint, constraintOption);\n  };\n\n  Responsive.prototype._constraintCompare = function (constraint, option) {\n    var type = constraint.type,\n        expression = constraint.expression;\n    var nodes = this.nodes.nodes;\n\n    if (type === 'chain') {\n      return this._chainConstraintCompare(expression, nodes, option);\n    }\n\n    if (type === 'padding') {\n      return this._paddingConstraintCompare(expression, this.region, nodes, option);\n    }\n\n    if (type === 'group') {\n      return this._groupConstraintCompare(expression, nodes, option);\n    }\n  };\n\n  Responsive.prototype._chainConstraintCompare = function (expression, nodes, option) {\n    for (var i = 0; i < nodes.length - 1; i++) {\n      var a = nodes[i];\n      var b = nodes[i + 1];\n\n      if (expression(a, b, option) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Responsive.prototype._paddingConstraintCompare = function (expression, region, nodes, option) {\n    if (region) {\n      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n\n        if (expression(node, region, option) === false) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  Responsive.prototype._groupConstraintCompare = function (expression, nodes, option) {\n    for (var i = 0; i < nodes.length; i++) {\n      var a = nodes[i];\n\n      for (var j = 0; j < nodes.length; j++) {\n        if (j !== i) {\n          var b = nodes[j];\n\n          if (expression(a, b, option) === false) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  Responsive.prototype._constraintAssignment = function (constraint, option) {\n    var type = constraint.type,\n        expression = constraint.expression;\n    var nodes = this.nodes.nodes;\n\n    if (type === 'chain') {\n      return this._chainConstraintAssign();\n    }\n\n    if (type === 'padding') {\n      return this._paddingConstraintAssign(expression, this.region, nodes, option);\n    }\n  };\n\n  Responsive.prototype._chainConstraintAssign = function () {\n    return true;\n  };\n\n  Responsive.prototype._paddingConstraintAssign = function (expression, region, nodes, option) {\n    if (region) {\n      for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n        var node = nodes_2[_i];\n        var value = expression(node, region, option);\n        node.value = value;\n      }\n    }\n\n    return true;\n  };\n\n  Responsive.prototype._applyRules = function () {\n    var ruleCfg = this.rules[this.currentConstraint.name][this.iterationIndex]; // if (this.rulesLocker.indexOf(ruleCfg) < 0) {\n\n    var rule = rulesLib[ruleCfg.name];\n    var option = ruleCfg.option ? ruleCfg.option : {};\n    var nodes = this.nodes.nodes;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      /** apply rule上下文 */\n\n      this._applyRule(node.shape, rule, option, i);\n    } // this.rulesLocker.push(ruleCfg);\n    // }\n\n  };\n\n  Responsive.prototype._applyRule = function (shape, rule, option, index) {\n    var cfg = {\n      nodes: this.nodes,\n      region: this.region,\n      plot: this.plot\n    }; // rule(shape, option, index, this);\n\n    rule(shape, option, index, cfg);\n  };\n\n  return Responsive;\n}();\n\nexport default Responsive;","map":{"version":3,"sources":["../../../src/util/responsive/responsive.ts"],"names":[],"mappings":"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","sourcesContent":["/** 可插拔的responsive模块 */\nimport { IShape, BBox } from '@antv/g-base';\nimport { assign } from '@antv/util';\nimport { constraintsLib } from './constraints/index';\nimport ShapeNodes, { IShapeNode } from './node/shape-nodes';\nimport VariableNodes from './node/variable-node';\nimport { rulesLib } from './rules/index';\nimport { LooseMap } from '../../interface/types';\n\ninterface IConstraint {\n  name: string;\n  option?: any;\n}\n\ninterface IRule {\n  name: string;\n  method?: (...args: any[]) => any;\n  option?: any;\n}\n\ninterface ResponsiveCfg {\n  plot: any;\n  region?: any;\n  nodes: ShapeNodes | VariableNodes;\n  constraints: IConstraint[];\n  rules?: any;\n  iterationTime?: number;\n  onStart?: (...args: any[]) => any;\n  onIteration?: (...args: any[]) => any;\n  onEnd?: (...args: any[]) => any;\n  cfg?: LooseMap;\n}\n\nexport default class Responsive {\n  public plot: any;\n  public region: BBox;\n  public nodes: ShapeNodes | VariableNodes;\n  public constraints: any[];\n  public rules: any[];\n  public iterationTime: number = 10;\n  public iterationIndex: number = 0;\n  public rulesLocker: any[] = [];\n  public currentConstraint: IConstraint;\n  public constraintIndex: number = 0;\n  public onStart: (nodes: ShapeNodes | VariableNodes) => void;\n  public onIteration: (nodes: ShapeNodes | VariableNodes) => void;\n  public onEnd: (nodes: ShapeNodes | VariableNodes) => void;\n\n  constructor(cfg: ResponsiveCfg) {\n    assign(this, cfg);\n    this.currentConstraint = this.constraints[0];\n    if (this.rules) {\n      this.iterationTime = this.rules[this.currentConstraint.name].length;\n    }\n    this._start();\n    this._run();\n    this._end();\n  }\n\n  private _start() {\n    if (this.onStart) {\n      this.onStart(this.nodes);\n    }\n  }\n\n  private _iteration() {\n    let nodes;\n    if (this.nodes.type === 'shape') {\n      nodes = this.nodes as ShapeNodes;\n    } else {\n      nodes = this.nodes as VariableNodes;\n    }\n    if (nodes.type === 'shape') {\n      nodes.measureNodes();\n    }\n    if (this.rules) {\n      this._applyRules();\n    }\n    if (nodes.type === 'shape') {\n      nodes.measureNodes();\n    }\n    if (this.onIteration) {\n      this.onIteration(this.nodes);\n    }\n  }\n\n  private _end() {\n    if (this.onEnd) {\n      this.onEnd(this.nodes);\n    }\n  }\n\n  private _run() {\n    let constraintPassed = this._constraintsTest();\n    while (!constraintPassed) {\n      if (this.iterationIndex > this.iterationTime - 1) {\n        break;\n      }\n      this._iteration();\n      constraintPassed = this._constraintsTest();\n      this.iterationIndex++;\n    }\n    if (this.constraintIndex < this.constraints.length - 1) {\n      this.constraintIndex++;\n      this.currentConstraint = this.constraints[this.constraintIndex];\n      this.iterationTime = this.rules ? this.rules[this.currentConstraint.name].length : 1;\n      this.iterationIndex = 0;\n      this._run();\n    }\n  }\n\n  private _constraintsTest(): boolean {\n    const constraint = constraintsLib[this.currentConstraint.name];\n    const constraintOption = this.currentConstraint.option;\n    if (constraint.usage === 'compare') {\n      return this._constraintCompare(constraint, constraintOption);\n    }\n    return this._constraintAssignment(constraint, constraintOption);\n  }\n\n  private _constraintCompare(constraint, option) {\n    const { type, expression } = constraint;\n    const nodes = this.nodes.nodes;\n    if (type === 'chain') {\n      return this._chainConstraintCompare(expression, nodes, option);\n    }\n    if (type === 'padding') {\n      return this._paddingConstraintCompare(expression, this.region, nodes, option);\n    }\n    if (type === 'group') {\n      return this._groupConstraintCompare(expression, nodes, option);\n    }\n  }\n\n  private _chainConstraintCompare(expression, nodes, option) {\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const a = nodes[i];\n      const b = nodes[i + 1];\n      if (expression(a, b, option) === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _paddingConstraintCompare(expression, region, nodes, option) {\n    if (region) {\n      for (const node of nodes) {\n        if (expression(node, region, option) === false) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  private _groupConstraintCompare(expression, nodes, option) {\n    for (let i = 0; i < nodes.length; i++) {\n      const a = nodes[i];\n      for (let j = 0; j < nodes.length; j++) {\n        if (j !== i) {\n          const b = nodes[j];\n          if (expression(a, b, option) === false) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  private _constraintAssignment(constraint, option) {\n    const { type, expression } = constraint;\n    const nodes = this.nodes.nodes;\n    if (type === 'chain') {\n      return this._chainConstraintAssign();\n    }\n    if (type === 'padding') {\n      return this._paddingConstraintAssign(expression, this.region, nodes, option);\n    }\n  }\n\n  private _chainConstraintAssign() {\n    return true;\n  }\n\n  private _paddingConstraintAssign(expression, region, nodes, option) {\n    if (region) {\n      for (const node of nodes) {\n        const value = expression(node, region, option);\n        node.value = value;\n      }\n    }\n    return true;\n  }\n\n  private _applyRules() {\n    const ruleCfg = this.rules[this.currentConstraint.name][this.iterationIndex];\n    // if (this.rulesLocker.indexOf(ruleCfg) < 0) {\n    const rule = rulesLib[ruleCfg.name];\n    const option = ruleCfg.option ? ruleCfg.option : {};\n    const nodes = this.nodes.nodes as IShapeNode[];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      /** apply rule上下文 */\n      this._applyRule(node.shape, rule, option, i);\n    }\n    // this.rulesLocker.push(ruleCfg);\n    // }\n  }\n\n  private _applyRule(shape: IShape, rule, option, index) {\n    const cfg = {\n      nodes: this.nodes,\n      region: this.region,\n      plot: this.plot,\n    };\n    // rule(shape, option, index, this);\n    rule(shape, option, index, cfg);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}