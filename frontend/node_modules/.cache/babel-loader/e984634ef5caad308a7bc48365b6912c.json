{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar base_1 = require(\"./base\");\n\nvar PRESS_DELAY = 250; // 计算滑动的方向\n\nvar calcDirection = function calcDirection(start, end) {\n  var xDistance = end.x - start.x;\n  var yDistance = end.y - start.y; // x 的距离大于y 说明是横向，否则就是纵向\n\n  if (Math.abs(xDistance) > Math.abs(yDistance)) {\n    return xDistance > 0 ? 'right' : 'left';\n  }\n\n  return yDistance > 0 ? 'down' : 'up';\n}; // 计算2点之间的距离\n\n\nvar calcDistance = function calcDistance(point1, point2) {\n  var xDistance = Math.abs(point2.x - point1.x);\n  var yDistance = Math.abs(point2.y - point1.y);\n  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n};\n\nvar getCenter = function getCenter(point1, point2) {\n  var x = (point1.x + point2.x) / 2;\n  var y = (point1.y + point2.y) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar convertPoints = function convertPoints(touches, canvas) {\n  if (!touches) {\n    return;\n  }\n\n  var points = [];\n  var len = touches.length;\n\n  for (var i = 0; i < len; i++) {\n    var touch = touches[i]; // x, y: 相对canvas原点的位置，clientX, clientY 相对于可视窗口的位置\n\n    var clientX = touch.clientX,\n        clientY = touch.clientY;\n    var point = canvas.getPointByClient(clientX, clientY);\n    points.push(point);\n  }\n\n  return points;\n};\n\nvar GestureController =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(GestureController, _super);\n\n  function GestureController(view) {\n    var _this = _super.call(this, view) || this;\n\n    _this.processEvent = {};\n\n    _this.touchStart = function (ev) {\n      var points = convertPoints(ev.originalEvent.touches, _this.canvas);\n\n      if (!points) {\n        return;\n      }\n\n      ev.points = points; // 防止上次的内容没有清理掉，重新reset下\n\n      _this.reset(); // 记录touch start 的时间\n\n\n      _this.startTime = Date.now(); // 记录touch start 的点\n\n      _this.startPoints = points;\n\n      if (points.length > 1) {\n        _this.startDistance = calcDistance(points[0], points[1]);\n        _this.center = getCenter(points[0], points[1]);\n      } else {\n        // 如果touchstart后停顿250ms, 则也触发press事件\n        _this.pressTimeout = setTimeout(function () {\n          // 这里固定触发press事件\n          var eventType = 'press';\n          ev.direction = 'none';\n\n          _this.emitStart(eventType, ev);\n\n          _this.emitEvent(eventType, ev);\n\n          _this.eventType = eventType;\n        }, PRESS_DELAY);\n      }\n    };\n\n    _this.touchMove = function (ev) {\n      var points = convertPoints(ev.originalEvent.touches, _this.canvas);\n\n      if (!points) {\n        return;\n      }\n\n      _this.clearPressTimeout();\n\n      ev.points = points;\n      var startPoints = _this.startPoints;\n\n      if (!startPoints) {\n        return;\n      } // 多指触控\n\n\n      if (points.length > 1) {\n        // touchstart的距离\n        var startDistance = _this.startDistance;\n        var currentDistance = calcDistance(points[0], points[1]);\n        ev.zoom = currentDistance / startDistance;\n        ev.center = _this.center; // 触发缩放事件\n\n        _this.emitStart('pinch', ev);\n\n        _this.emitEvent('pinch', ev);\n      } else {\n        var deltaX = points[0].x - startPoints[0].x;\n        var deltaY = points[0].y - startPoints[0].y;\n        var direction = _this.direction || calcDirection(startPoints[0], points[0]);\n        _this.direction = direction; // 获取press或者pan的事件类型\n        // press 按住滑动, pan表示平移\n        // 如果start后立刻move，则触发pan, 如果有停顿，则触发press\n\n        var eventType = _this.getEventType(points);\n\n        ev.direction = direction;\n        ev.deltaX = deltaX;\n        ev.deltaY = deltaY;\n\n        _this.emitStart(eventType, ev);\n\n        _this.emitEvent(eventType, ev); // 记录最后2次move的时间和坐标，为了给swipe事件用\n\n\n        var prevMoveTime = _this.lastMoveTime;\n        var now = Date.now(); // 最后2次的时间间隔一定要大于0，否则swipe没发计算\n\n        if (now - prevMoveTime > 0) {\n          _this.prevMoveTime = prevMoveTime;\n          _this.prevMovePoints = _this.lastMovePoints;\n          _this.lastMoveTime = now;\n          _this.lastMovePoints = points;\n        }\n      }\n    };\n\n    _this.touchEnd = function (ev) {\n      _this.emitEnd(ev); // swipe事件处理, 在touchend之后触发\n\n\n      var lastMoveTime = _this.lastMoveTime;\n      var now = Date.now(); // 做这个判断是为了最后一次touchmove后到end前，还有一个停顿的过程\n      // 100 是拍的一个值，理论这个值会很短，一般不卡顿的话在10ms以内\n\n      if (now - lastMoveTime < 100) {\n        var prevMoveTime = _this.prevMoveTime || _this.startTime;\n        var intervalTime = lastMoveTime - prevMoveTime; // 时间间隔一定要大于0, 否则计算没意义\n\n        if (intervalTime > 0) {\n          var prevMovePoints = _this.prevMovePoints || _this.startPoints;\n          var lastMovePoints = _this.lastMovePoints; // move速率\n\n          var velocity = calcDistance(prevMovePoints[0], lastMovePoints[0]) / intervalTime; // 0.3 是参考hammerjs的设置\n\n          if (velocity > 0.3) {\n            ev.velocity = velocity;\n            ev.direction = calcDirection(prevMovePoints[0], lastMovePoints[0]);\n\n            _this.emitEvent('swipe', ev);\n          }\n        }\n      }\n\n      _this.reset();\n\n      var touches = ev.touches; // 当多指只释放了1指时也会触发end, 这时重新触发一次start\n\n      if (touches && touches.length > 0) {\n        _this.touchStart(ev);\n      }\n    };\n\n    _this.canvas = view.getCanvas();\n\n    _this.delegateEvent(); // 用来记录当前触发的事件\n\n\n    _this.processEvent = {};\n    return _this;\n  }\n\n  Object.defineProperty(GestureController.prototype, \"name\", {\n    get: function get() {\n      return 'gesture';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  GestureController.prototype.init = function () {};\n\n  GestureController.prototype.render = function () {};\n\n  GestureController.prototype.layout = function () {};\n\n  GestureController.prototype.update = function () {};\n\n  GestureController.prototype.destroy = function () {\n    this.reset();\n    this.offEvent();\n    this.processEvent = null;\n  };\n\n  GestureController.prototype.delegateEvent = function () {\n    // 代理这几个事件\n    this.canvas.on('touchstart', this.touchStart);\n    this.canvas.on('touchmove', this.touchMove);\n    this.canvas.on('touchend', this.touchEnd);\n  };\n\n  GestureController.prototype.offEvent = function () {\n    this.canvas.off('touchstart', this.touchStart);\n    this.canvas.off('touchmove', this.touchMove);\n    this.canvas.off('touchend', this.touchEnd);\n  };\n\n  GestureController.prototype.emitEvent = function (type, ev) {\n    var view = this.view;\n    view.emit(type, ev);\n  }; // 触发start事件\n\n\n  GestureController.prototype.emitStart = function (type, ev) {\n    if (this.isProcess(type)) {\n      return;\n    }\n\n    this.enable(type);\n    this.emitEvent(type + \"start\", ev);\n  }; // 触发end事件\n\n\n  GestureController.prototype.emitEnd = function (ev) {\n    var _this = this;\n\n    var processEvent = this.processEvent;\n    Object.keys(processEvent).forEach(function (type) {\n      _this.emitEvent(type + \"end\", ev);\n\n      delete processEvent[type];\n    });\n  };\n\n  GestureController.prototype.enable = function (eventType) {\n    this.processEvent[eventType] = true;\n  }; // 是否进行中的事件\n\n\n  GestureController.prototype.isProcess = function (eventType) {\n    return this.processEvent[eventType];\n  };\n\n  GestureController.prototype.reset = function () {\n    this.clearPressTimeout();\n    this.startTime = 0;\n    this.startPoints = null;\n    this.startDistance = 0;\n    this.direction = null;\n    this.eventType = null;\n    this.prevMoveTime = 0;\n    this.prevMovePoints = null;\n    this.lastMoveTime = 0;\n    this.lastMovePoints = null;\n  };\n\n  GestureController.prototype.clearPressTimeout = function () {\n    if (this.pressTimeout) {\n      clearTimeout(this.pressTimeout);\n      this.pressTimeout = 0;\n    }\n  };\n\n  GestureController.prototype.getEventType = function (points) {\n    var _a = this,\n        eventType = _a.eventType,\n        view = _a.view,\n        startTime = _a.startTime,\n        startPoints = _a.startPoints;\n\n    if (eventType) {\n      return eventType;\n    }\n\n    var type;\n    var panEventListeners = view.getEvents().pan; // 如果 view 上没有 pan 事件的监听，默认都是 press\n\n    if (!panEventListeners || !panEventListeners.length) {\n      type = 'press';\n    } else {\n      // 如果有pan事件的处理，press则需要停顿250ms, 且移动距离小于10\n      var now = Date.now();\n\n      if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], points[0]) < 10) {\n        type = 'press';\n      } else {\n        type = 'pan';\n      }\n    }\n\n    this.eventType = type;\n    return type;\n  };\n\n  return GestureController;\n}(base_1.Controller);\n\nexports.default = GestureController;","map":{"version":3,"sources":["../../../src/chart/controller/gesture.ts"],"names":[],"mappings":"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","sourcesContent":["import { ICanvas } from '../../dependents';\nimport { Point } from '../../interface';\nimport { View } from '../view';\nimport { Controller } from './base';\n\nconst PRESS_DELAY = 250;\n\n// 计算滑动的方向\nconst calcDirection = (start: Point, end: Point) => {\n  const xDistance = end.x - start.x;\n  const yDistance = end.y - start.y;\n  // x 的距离大于y 说明是横向，否则就是纵向\n  if (Math.abs(xDistance) > Math.abs(yDistance)) {\n    return xDistance > 0 ? 'right' : 'left';\n  }\n  return yDistance > 0 ? 'down' : 'up';\n};\n\n// 计算2点之间的距离\nconst calcDistance = (point1: Point, point2: Point) => {\n  const xDistance = Math.abs(point2.x - point1.x);\n  const yDistance = Math.abs(point2.y - point1.y);\n  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n};\n\nconst getCenter = (point1, point2) => {\n  const x = (point1.x + point2.x) / 2;\n  const y = (point1.y + point2.y) / 2;\n  return { x, y };\n};\n\nconst convertPoints = (touches, canvas: ICanvas) => {\n  if (!touches) {\n    return;\n  }\n  const points = [];\n  const len = touches.length;\n  for (let i = 0; i < len; i++) {\n    const touch = touches[i];\n    // x, y: 相对canvas原点的位置，clientX, clientY 相对于可视窗口的位置\n    const { clientX, clientY } = touch;\n    const point = canvas.getPointByClient(clientX, clientY);\n    points.push(point);\n  }\n  return points;\n};\n\nexport default class GestureController extends Controller {\n  private canvas: ICanvas;\n  private processEvent = {};\n\n  private startTime: number;\n  private startPoints: Point[];\n  private startDistance: number;\n  private center: Point;\n  private pressTimeout;\n  private direction: string;\n  private prevMoveTime: number;\n  private prevMovePoints: Point[];\n  private lastMoveTime: number;\n  private lastMovePoints: Point[];\n  private eventType: string;\n\n  constructor(view: View) {\n    super(view);\n\n    this.canvas = view.getCanvas();\n\n    this.delegateEvent();\n\n    // 用来记录当前触发的事件\n    this.processEvent = {};\n  }\n\n  public get name(): string {\n    return 'gesture';\n  }\n\n  public init() {}\n\n  public render() {}\n\n  public layout() {}\n\n  public update() {}\n\n  public destroy() {\n    this.reset();\n    this.offEvent();\n    this.processEvent = null;\n  }\n\n  private delegateEvent() {\n    // 代理这几个事件\n    this.canvas.on('touchstart', this.touchStart);\n    this.canvas.on('touchmove', this.touchMove);\n    this.canvas.on('touchend', this.touchEnd);\n  }\n\n  private offEvent() {\n    this.canvas.off('touchstart', this.touchStart);\n    this.canvas.off('touchmove', this.touchMove);\n    this.canvas.off('touchend', this.touchEnd);\n  }\n\n  private touchStart = (ev): void => {\n    const points = convertPoints(ev.originalEvent.touches, this.canvas);\n    if (!points) {\n      return;\n    }\n    ev.points = points;\n    // 防止上次的内容没有清理掉，重新reset下\n    this.reset();\n    // 记录touch start 的时间\n    this.startTime = Date.now();\n    // 记录touch start 的点\n    this.startPoints = points;\n    if (points.length > 1) {\n      this.startDistance = calcDistance(points[0], points[1]);\n      this.center = getCenter(points[0], points[1]);\n    } else {\n      // 如果touchstart后停顿250ms, 则也触发press事件\n      this.pressTimeout = setTimeout(() => {\n        // 这里固定触发press事件\n        const eventType = 'press';\n        ev.direction = 'none';\n        this.emitStart(eventType, ev);\n        this.emitEvent(eventType, ev);\n        this.eventType = eventType;\n      }, PRESS_DELAY);\n    }\n  };\n\n  private touchMove = (ev): void => {\n    const points = convertPoints(ev.originalEvent.touches, this.canvas);\n    if (!points) {\n      return;\n    }\n    this.clearPressTimeout();\n    ev.points = points;\n\n    const startPoints = this.startPoints;\n    if (!startPoints) {\n      return;\n    }\n    // 多指触控\n    if (points.length > 1) {\n      // touchstart的距离\n      const startDistance = this.startDistance;\n      const currentDistance = calcDistance(points[0], points[1]);\n      ev.zoom = currentDistance / startDistance;\n      ev.center = this.center;\n      // 触发缩放事件\n      this.emitStart('pinch', ev);\n      this.emitEvent('pinch', ev);\n    } else {\n      const deltaX = points[0].x - startPoints[0].x;\n      const deltaY = points[0].y - startPoints[0].y;\n      const direction = this.direction || calcDirection(startPoints[0], points[0]);\n      this.direction = direction;\n\n      // 获取press或者pan的事件类型\n      // press 按住滑动, pan表示平移\n      // 如果start后立刻move，则触发pan, 如果有停顿，则触发press\n      const eventType = this.getEventType(points);\n\n      ev.direction = direction;\n      ev.deltaX = deltaX;\n      ev.deltaY = deltaY;\n      this.emitStart(eventType, ev);\n      this.emitEvent(eventType, ev);\n\n      // 记录最后2次move的时间和坐标，为了给swipe事件用\n      const prevMoveTime = this.lastMoveTime;\n      const now = Date.now();\n      // 最后2次的时间间隔一定要大于0，否则swipe没发计算\n      if (now - prevMoveTime > 0) {\n        this.prevMoveTime = prevMoveTime;\n        this.prevMovePoints = this.lastMovePoints;\n        this.lastMoveTime = now;\n        this.lastMovePoints = points;\n      }\n    }\n  };\n\n  private touchEnd = (ev): void => {\n    this.emitEnd(ev);\n\n    // swipe事件处理, 在touchend之后触发\n    const lastMoveTime = this.lastMoveTime;\n    const now = Date.now();\n    // 做这个判断是为了最后一次touchmove后到end前，还有一个停顿的过程\n    // 100 是拍的一个值，理论这个值会很短，一般不卡顿的话在10ms以内\n    if (now - lastMoveTime < 100) {\n      const prevMoveTime = this.prevMoveTime || this.startTime;\n      const intervalTime = lastMoveTime - prevMoveTime;\n      // 时间间隔一定要大于0, 否则计算没意义\n      if (intervalTime > 0) {\n        const prevMovePoints = this.prevMovePoints || this.startPoints;\n        const lastMovePoints = this.lastMovePoints;\n        // move速率\n        const velocity = calcDistance(prevMovePoints[0], lastMovePoints[0]) / intervalTime;\n        // 0.3 是参考hammerjs的设置\n        if (velocity > 0.3) {\n          ev.velocity = velocity;\n          ev.direction = calcDirection(prevMovePoints[0], lastMovePoints[0]);\n          this.emitEvent('swipe', ev);\n        }\n      }\n    }\n\n    this.reset();\n\n    const touches = ev.touches;\n    // 当多指只释放了1指时也会触发end, 这时重新触发一次start\n    if (touches && touches.length > 0) {\n      this.touchStart(ev);\n    }\n  };\n\n  private emitEvent(type, ev) {\n    const view = this.view;\n    view.emit(type, ev);\n  }\n\n  // 触发start事件\n  private emitStart(type, ev) {\n    if (this.isProcess(type)) {\n      return;\n    }\n    this.enable(type);\n    this.emitEvent(`${type}start`, ev);\n  }\n  // 触发end事件\n  private emitEnd(ev) {\n    const processEvent = this.processEvent;\n    Object.keys(processEvent).forEach((type) => {\n      this.emitEvent(`${type}end`, ev);\n      delete processEvent[type];\n    });\n  }\n\n  private enable(eventType: string) {\n    this.processEvent[eventType] = true;\n  }\n  // 是否进行中的事件\n  private isProcess(eventType: string) {\n    return this.processEvent[eventType];\n  }\n\n  private reset() {\n    this.clearPressTimeout();\n    this.startTime = 0;\n    this.startPoints = null;\n    this.startDistance = 0;\n    this.direction = null;\n    this.eventType = null;\n    this.prevMoveTime = 0;\n    this.prevMovePoints = null;\n    this.lastMoveTime = 0;\n    this.lastMovePoints = null;\n  }\n\n  private clearPressTimeout() {\n    if (this.pressTimeout) {\n      clearTimeout(this.pressTimeout);\n      this.pressTimeout = 0;\n    }\n  }\n\n  private getEventType(points) {\n    const { eventType, view, startTime, startPoints } = this;\n    if (eventType) {\n      return eventType;\n    }\n    let type;\n    const panEventListeners = view.getEvents().pan;\n    // 如果 view 上没有 pan 事件的监听，默认都是 press\n    if (!panEventListeners || !panEventListeners.length) {\n      type = 'press';\n    } else {\n      // 如果有pan事件的处理，press则需要停顿250ms, 且移动距离小于10\n      const now = Date.now();\n      if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], points[0]) < 10) {\n        type = 'press';\n      } else {\n        type = 'pan';\n      }\n    }\n    this.eventType = type;\n    return type;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}