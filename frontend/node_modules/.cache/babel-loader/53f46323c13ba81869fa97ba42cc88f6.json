{"ast":null,"code":"import { isObject, each, get } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\n/** label text和line距离 4px */\n\nvar MARGIN = 4;\n\nfunction antiCollision(labelShapes, labels, labelHeight, plotRange, center, radius, isRight) {\n  // sorted by y, mutable\n  labels.sort(function (a, b) {\n    return a.y - b.y;\n  }); // adjust y position of labels to avoid overlapping\n\n  var start = plotRange.start;\n  var end = plotRange.end;\n  var startY = Math.min(start.y, end.y);\n  var endY = Math.max(start.y, end.y);\n  var i;\n  var boxes = labels.map(function (label) {\n    return {\n      content: label.content,\n      size: labelHeight,\n      pos: label.y,\n      targets: [label.y]\n    };\n  });\n  var maxPos = Math.max.apply(Math, boxes.map(function (b) {\n    return b.pos;\n  }));\n  var minPos = Math.min.apply(Math, boxes.map(function (b) {\n    return b.pos;\n  }));\n  /**\n   * when in right, shift from up to down\n   */\n\n  if (isRight) {\n    var minY = Math.min(minPos, endY - (boxes.length - 1) * labelHeight);\n    var maxY = Math.max(minY + boxes.length * labelHeight, maxPos + labelHeight);\n    var overlapping = true;\n\n    while (overlapping) {\n      // detect overlapping and join boxes\n      overlapping = false;\n      i = boxes.length;\n\n      while (i--) {\n        if (i > 0) {\n          var previousBox = boxes[i - 1];\n          var box = boxes[i]; // overlap\n\n          if (previousBox.pos + previousBox.size > box.pos) {\n            if (box.pos + i * labelHeight < maxY) {\n              // join boxes\n              previousBox.size += box.size;\n              previousBox.targets = previousBox.targets.concat(box.targets); // removing box\n\n              boxes.splice(i, 1);\n            } else {\n              previousBox.pos = box.pos - previousBox.size;\n            }\n\n            overlapping = true;\n          }\n        }\n      }\n    }\n  } else {\n    var maxY = Math.max(startY + (boxes.length - 1) * labelHeight, maxPos);\n    var minY = Math.min(minPos, maxY - (boxes.length - 1) * labelHeight);\n    var overlapping = true;\n\n    while (overlapping) {\n      // detect overlapping and join boxes\n      overlapping = false;\n      i = boxes.length;\n\n      while (i--) {\n        if (i > 0) {\n          var previousBox = boxes[i - 1];\n          var box = boxes[i]; // overlap\n\n          if (previousBox.pos + previousBox.size > box.pos) {\n            if (previousBox.pos - minY > i * labelHeight) {\n              previousBox.pos -= previousBox.size;\n            } else {\n              // join boxes\n              previousBox.size += box.size;\n              previousBox.targets = previousBox.targets.concat(box.targets); // removing box\n\n              boxes.splice(i, 1);\n            }\n\n            overlapping = true;\n          }\n        }\n      }\n    }\n  } // step 4: normalize y and adjust x\n\n\n  i = 0;\n  boxes.forEach(function (b) {\n    var posInCompositeBox = b.pos;\n    b.targets.forEach(function () {\n      labels[i].y = posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n  var labelsMap = {};\n\n  for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {\n    var labelShape = labelShapes_1[_i];\n    labelsMap[labelShape.get('id')] = labelShape;\n  } // (x - cx)^2 + (y - cy)^2 = totalR^2\n\n\n  var totalR = (Math.max.apply(Math, labels.map(function (l) {\n    return l.y;\n  })) - Math.min.apply(Math, labels.map(function (l) {\n    return l.y;\n  }))) / 2;\n  totalR = Math.max(totalR, radius);\n  labels.forEach(function (label) {\n    var labelShape = labelsMap[label.id]; // because group could not effect text-shape, should set text-shape position manually\n\n    var textShape = labelShape.find(function (child) {\n      return child.get('type') === 'text';\n    }); // textShape 发生过调整\n\n    if (textShape && textShape.attr('y') !== label.y) {\n      var rPow2 = totalR * totalR;\n      var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n\n      if (rPow2 < dyPow2) {\n        label.x = center.x;\n      } else {\n        var dx = Math.sqrt(rPow2 - dyPow2);\n\n        if (!isRight) {\n          // left\n          label.x = center.x - dx;\n        } else {\n          // right\n          label.x = center.x + dx;\n        }\n      }\n    } // adjust labelShape\n\n\n    labelShape.attr('x', label.x);\n    labelShape.attr('y', label.y); // @ts-ignore\n\n    if (textShape) {\n      textShape.attr('y', label.y);\n      textShape.attr('x', label.x);\n    }\n  });\n}\n\nexport function pieOuterLabelLayout(items, labels, shapes, region) {\n  var offset = items[0] ? items[0].offset : 0;\n  var coordinate = labels[0].get('coordinate');\n  var radius = coordinate.getRadius();\n  var center = coordinate.getCenter();\n\n  if (offset > 0) {\n    // note labelHeight 可以控制 label 的行高\n    var lineHeight_1 = get(items[0], 'labelHeight', 14);\n    var totalR_1 = radius + offset;\n    var totalHeight_1 = totalR_1 * 2 + lineHeight_1 * 2;\n    var plotRange_1 = {\n      start: coordinate.start,\n      end: coordinate.end\n    }; // step 1: separate labels\n\n    var halves_1 = [[], []];\n    items.forEach(function (labelItem) {\n      if (!labelItem) {\n        return;\n      }\n\n      if (labelItem.x < center.x) {\n        // left\n        halves_1[0].push(labelItem);\n      } else {\n        // right or center will be put on the right side\n        halves_1[1].push(labelItem);\n      }\n    });\n    halves_1.forEach(function (half, index) {\n      // step 2: reduce labels\n      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;\n\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort(function (a, b) {\n          // sort by percentage DESC\n          // fixme-xinming 目前还获取不到，需要使用 scale 去获取 percent\n          return b['data.percent'] - a['data.percent'];\n        });\n        var hidden = half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide + 1);\n        hidden.forEach(function (l) {\n          var idx = labels.findIndex(function (item) {\n            return item.get('id') === l.id;\n          });\n\n          if (labels[idx]) {\n            labels[idx].remove(true); // 同时移除\n\n            labels.splice(idx, 1);\n          }\n        });\n      }\n\n      antiCollision(labels, half, lineHeight_1, plotRange_1, center, totalR_1, index === 1);\n    });\n  } // 配置 labelLine\n\n\n  each(items, function (item) {\n    if (item && item.labelLine) {\n      var angle = item.angle; // 贴近圆周\n\n      var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n      var itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n      var itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n      var endPoint = {\n        x: itemX - Math.cos(angle) * MARGIN,\n        y: itemY - Math.sin(angle) * MARGIN\n      };\n      var smoothConnector = item.labelLine.smooth;\n      var path = [];\n      var dx = endPoint.x - center.x;\n      var dy = endPoint.y - center.y;\n      var endAngle = Math.atan(dy / dx); // 第三象限 & 第四象限\n\n      if (dx < 0) {\n        endAngle += Math.PI;\n      } // 默认 smooth, undefined 也为 smooth\n\n\n      if (smoothConnector === false) {\n        if (!isObject(item.labelLine)) {\n          // labelLine: true\n          item.labelLine = {};\n        } // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n\n\n        var sweepFlag = 0; // 第一象限\n\n        if (angle < 0 && angle > -Math.PI / 2 || angle > Math.PI * 1.5) {\n          if (endPoint.y > startPoint.y) {\n            sweepFlag = 1;\n          }\n        } // 第二象限\n\n\n        if (angle >= 0 && angle < Math.PI / 2) {\n          if (endPoint.y > startPoint.y) {\n            sweepFlag = 1;\n          }\n        } // 第三象限\n\n\n        if (angle >= Math.PI / 2 && angle < Math.PI) {\n          if (startPoint.y > endPoint.y) {\n            sweepFlag = 1;\n          }\n        } // 第四象限\n\n\n        if (angle < -Math.PI / 2 || angle >= Math.PI && angle < Math.PI * 1.5) {\n          if (startPoint.y > endPoint.y) {\n            sweepFlag = 1;\n          }\n        }\n\n        var distance = offset / 2 > 4 ? 4 : Math.max(offset / 2 - 1, 0);\n        var breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle); // 圆弧的结束点\n\n        var breakPoint3 = polarToCartesian(center.x, center.y, radius + offset / 2, endAngle);\n        /**\n         * @example\n         * M 100 100 L100 90 A 50 50 0 0 0 150 50\n         * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n         * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n         * 第 5 个参数: 是否顺时针绘制\n         */\n        // 默认小弧\n\n        var largeArcFlag = 0; // step1: 移动至起点\n\n        path.push(\"M \" + startPoint.x + \" \" + startPoint.y); // step2: 连接拐点\n\n        path.push(\"L \" + breakPoint.x + \" \" + breakPoint.y); // step3: 绘制圆弧 至 结束点\n\n        path.push(\"A \" + center.x + \" \" + center.y + \" 0 \" + largeArcFlag + \" \" + sweepFlag + \" \" + breakPoint3.x + \" \" + breakPoint3.y); // step4: 连接结束点\n\n        path.push(\"L \" + endPoint.x + \" \" + endPoint.y);\n      } else {\n        var breakPoint = polarToCartesian(center.x, center.y, radius + (offset / 2 > 4 ? 4 : Math.max(offset / 2 - 1, 0)), angle); // G2 旧的拉线\n        // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n\n        var xSign = startPoint.x < center.x ? 1 : -1; // step1: 连接结束点\n\n        path.push(\"M \" + endPoint.x + \" \" + endPoint.y);\n        var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n        var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n\n        if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n          // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n          path.push.apply(path, ['C', endPoint.x + xSign * 4, endPoint.y, 2 * breakPoint.x - startPoint.x, 2 * breakPoint.y - startPoint.y, startPoint.x, startPoint.y]);\n        } // step3: 连接至起点\n\n\n        path.push(\"L \" + startPoint.x + \" \" + startPoint.y);\n      }\n\n      item.labelLine.path = path.join(' ');\n    }\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/pie/outer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { BBox, IGroup, IShape, IElement } from '@antv/g-base';\nimport { isObject, each, find, get } from '@antv/util';\nimport { Point } from '../../../../interface';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem } from '../../interface';\n\n/** label text和line距离 4px */\nconst MARGIN = 4;\n\nfunction antiCollision(\n  labelShapes: IGroup[],\n  labels: LabelItem[],\n  labelHeight: number,\n  plotRange,\n  center: Point,\n  radius: number,\n  isRight\n) {\n  // sorted by y, mutable\n  labels.sort((a, b) => a.y - b.y);\n\n  // adjust y position of labels to avoid overlapping\n  const start = plotRange.start;\n  const end = plotRange.end;\n  const startY = Math.min(start.y, end.y);\n  const endY = Math.max(start.y, end.y);\n  let i;\n\n  const boxes = labels.map((label) => {\n    return {\n      content: label.content,\n      size: labelHeight,\n      pos: label.y,\n      targets: [label.y],\n    };\n  });\n\n  const maxPos = Math.max(...boxes.map((b) => b.pos));\n  const minPos = Math.min(...boxes.map((b) => b.pos));\n  /**\n   * when in right, shift from up to down\n   */\n  if (isRight) {\n    const minY = Math.min(minPos, endY - (boxes.length - 1) * labelHeight);\n    const maxY = Math.max(minY + boxes.length * labelHeight, maxPos + labelHeight);\n    let overlapping = true;\n    while (overlapping) {\n      // detect overlapping and join boxes\n      overlapping = false;\n      i = boxes.length;\n      while (i--) {\n        if (i > 0) {\n          const previousBox = boxes[i - 1];\n          const box = boxes[i];\n          // overlap\n          if (previousBox.pos + previousBox.size > box.pos) {\n            if (box.pos + i * labelHeight < maxY) {\n              // join boxes\n              previousBox.size += box.size;\n              previousBox.targets = previousBox.targets.concat(box.targets);\n              // removing box\n              boxes.splice(i, 1);\n            } else {\n              previousBox.pos = box.pos - previousBox.size;\n            }\n            overlapping = true;\n          }\n        }\n      }\n    }\n  } else {\n    const maxY = Math.max(startY + (boxes.length - 1) * labelHeight, maxPos);\n    const minY = Math.min(minPos, maxY - (boxes.length - 1) * labelHeight);\n    let overlapping = true;\n    while (overlapping) {\n      // detect overlapping and join boxes\n      overlapping = false;\n      i = boxes.length;\n      while (i--) {\n        if (i > 0) {\n          const previousBox = boxes[i - 1];\n          const box = boxes[i];\n          // overlap\n          if (previousBox.pos + previousBox.size > box.pos) {\n            if (previousBox.pos - minY > i * labelHeight) {\n              previousBox.pos -= previousBox.size;\n            } else {\n              // join boxes\n              previousBox.size += box.size;\n              previousBox.targets = previousBox.targets.concat(box.targets);\n              // removing box\n              boxes.splice(i, 1);\n            }\n            overlapping = true;\n          }\n        }\n      }\n    }\n  }\n\n  // step 4: normalize y and adjust x\n  i = 0;\n  boxes.forEach((b) => {\n    let posInCompositeBox = b.pos;\n    b.targets.forEach(() => {\n      labels[i].y = posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n\n  const labelsMap = {};\n  for (const labelShape of labelShapes) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  // (x - cx)^2 + (y - cy)^2 = totalR^2\n  let totalR = (Math.max(...labels.map((l) => l.y)) - Math.min(...labels.map((l) => l.y))) / 2;\n  totalR = Math.max(totalR, radius);\n  labels.forEach((label) => {\n    const labelShape = labelsMap[label.id];\n\n    // because group could not effect text-shape, should set text-shape position manually\n    const textShape = labelShape.find((child) => child.get('type') === 'text') as IElement;\n\n    // textShape 发生过调整\n    if (textShape && textShape.attr('y') !== label.y) {\n      const rPow2 = totalR * totalR;\n      const dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n      if (rPow2 < dyPow2) {\n        label.x = center.x;\n      } else {\n        const dx = Math.sqrt(rPow2 - dyPow2);\n        if (!isRight) {\n          // left\n          label.x = center.x - dx;\n        } else {\n          // right\n          label.x = center.x + dx;\n        }\n      }\n    }\n\n    // adjust labelShape\n    labelShape.attr('x', label.x);\n    labelShape.attr('y', label.y);\n\n    // @ts-ignore\n    if (textShape) {\n      textShape.attr('y', label.y);\n      textShape.attr('x', label.x);\n    }\n  });\n}\n\nexport function pieOuterLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const offset = items[0] ? items[0].offset : 0;\n  const coordinate: Coordinate = labels[0].get('coordinate');\n  const radius = coordinate.getRadius();\n  const center = coordinate.getCenter();\n\n  if (offset > 0) {\n    // note labelHeight 可以控制 label 的行高\n    const lineHeight: number = get(items[0], 'labelHeight', 14);\n    const totalR = radius + offset;\n    const totalHeight = totalR * 2 + lineHeight * 2;\n    const plotRange = {\n      start: coordinate.start,\n      end: coordinate.end,\n    };\n\n    // step 1: separate labels\n    const halves: LabelItem[][] = [\n      [], // left\n      [], // right\n    ];\n    items.forEach((labelItem) => {\n      if (!labelItem) {\n        return;\n      }\n      if (labelItem.x < center.x) {\n        // left\n        halves[0].push(labelItem);\n      } else {\n        // right or center will be put on the right side\n        halves[1].push(labelItem);\n      }\n    });\n\n    halves.forEach((half, index) => {\n      // step 2: reduce labels\n      const maxLabelsCountForOneSide = totalHeight / lineHeight;\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort((a, b) => {\n          // sort by percentage DESC\n          // fixme-xinming 目前还获取不到，需要使用 scale 去获取 percent\n          return b['data.percent'] - a['data.percent'];\n        });\n\n        const hidden = half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide + 1);\n        hidden.forEach((l) => {\n          const idx = labels.findIndex((item) => item.get('id') === l.id);\n          if (labels[idx]) {\n            labels[idx].remove(true);\n            // 同时移除\n            labels.splice(idx, 1);\n          }\n        });\n      }\n      antiCollision(labels, half, lineHeight, plotRange, center, totalR, index === 1);\n    });\n  }\n\n  // 配置 labelLine\n  each(items, (item) => {\n    if (item && item.labelLine) {\n      const { angle } = item;\n      // 贴近圆周\n      const startPoint = polarToCartesian(center.x, center.y, radius, angle);\n      const itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n      const itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n\n      const endPoint = {\n        x: itemX - Math.cos(angle) * MARGIN,\n        y: itemY - Math.sin(angle) * MARGIN,\n      };\n\n      const smoothConnector = item.labelLine.smooth;\n      const path = [];\n      const dx = endPoint.x - center.x;\n      const dy = endPoint.y - center.y;\n      let endAngle = Math.atan(dy / dx);\n      // 第三象限 & 第四象限\n      if (dx < 0) {\n        endAngle += Math.PI;\n      }\n\n      // 默认 smooth, undefined 也为 smooth\n      if (smoothConnector === false) {\n        if (!isObject(item.labelLine)) {\n          // labelLine: true\n          item.labelLine = {};\n        }\n\n        // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n        let sweepFlag = 0;\n\n        // 第一象限\n        if ((angle < 0 && angle > -Math.PI / 2) || angle > Math.PI * 1.5) {\n          if (endPoint.y > startPoint.y) {\n            sweepFlag = 1;\n          }\n        }\n\n        // 第二象限\n        if (angle >= 0 && angle < Math.PI / 2) {\n          if (endPoint.y > startPoint.y) {\n            sweepFlag = 1;\n          }\n        }\n\n        // 第三象限\n        if (angle >= Math.PI / 2 && angle < Math.PI) {\n          if (startPoint.y > endPoint.y) {\n            sweepFlag = 1;\n          }\n        }\n\n        // 第四象限\n        if (angle < -Math.PI / 2 || (angle >= Math.PI && angle < Math.PI * 1.5)) {\n          if (startPoint.y > endPoint.y) {\n            sweepFlag = 1;\n          }\n        }\n\n        const distance = offset / 2 > 4 ? 4 : Math.max(offset / 2 - 1, 0);\n        const breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);\n        // 圆弧的结束点\n        const breakPoint3 = polarToCartesian(center.x, center.y, radius + offset / 2, endAngle);\n\n        /**\n         * @example\n         * M 100 100 L100 90 A 50 50 0 0 0 150 50\n         * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n         * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n         * 第 5 个参数: 是否顺时针绘制\n         */\n        // 默认小弧\n        const largeArcFlag = 0;\n        // step1: 移动至起点\n        path.push(`M ${startPoint.x} ${startPoint.y}`);\n        // step2: 连接拐点\n        path.push(`L ${breakPoint.x} ${breakPoint.y}`);\n        // step3: 绘制圆弧 至 结束点\n        path.push(`A ${center.x} ${center.y} 0 ${largeArcFlag} ${sweepFlag} ${breakPoint3.x} ${breakPoint3.y}`);\n        // step4: 连接结束点\n        path.push(`L ${endPoint.x} ${endPoint.y}`);\n      } else {\n        const breakPoint = polarToCartesian(\n          center.x,\n          center.y,\n          radius + (offset / 2 > 4 ? 4 : Math.max(offset / 2 - 1, 0)),\n          angle\n        );\n        // G2 旧的拉线\n        // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n        const xSign = startPoint.x < center.x ? 1 : -1;\n        // step1: 连接结束点\n        path.push(`M ${endPoint.x} ${endPoint.y}`);\n        const slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n        const slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n        if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n          // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n          path.push(\n            ...[\n              'C',\n              endPoint.x + xSign * 4,\n              endPoint.y,\n              2 * breakPoint.x - startPoint.x,\n              2 * breakPoint.y - startPoint.y,\n              startPoint.x,\n              startPoint.y,\n            ]\n          );\n        }\n        // step3: 连接至起点\n        path.push(`L ${startPoint.x} ${startPoint.y}`);\n      }\n\n      item.labelLine.path = path.join(' ');\n    }\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}