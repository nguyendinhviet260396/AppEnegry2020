{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { groupBy, each, keys } from '@antv/util';\nimport { registerLabelComponent } from './base';\nimport PointLabel from './point';\nimport { FIELD_ORIGIN, ORIGIN } from '../../dependents';\nimport { checkOriginEqual, moveInPanel, checkShapeOverlap } from '../../util/view';\nimport BBox from '../../util/bbox';\n\nvar PointAutoLabel =\n/** @class */\nfunction (_super) {\n  __extends(PointAutoLabel, _super);\n\n  function PointAutoLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PointAutoLabel.prototype.layoutLabels = function (geometry, labels) {\n    var _this = this;\n\n    var _a;\n\n    var dones = [];\n    var panel = BBox.fromBBoxObject(this.getCoordinateBBox());\n\n    var _b = geometry.getXYFields(),\n        xField = _b[0],\n        yField = _b[1];\n\n    var groupedMap = groupBy(labels, function (label) {\n      return label.get(ORIGIN)[FIELD_ORIGIN][xField];\n    });\n    var offset = (_a = labels[0]) === null || _a === void 0 ? void 0 : _a.get('offset');\n    each(keys(groupedMap).reverse(), function (xValue) {\n      var group = _this.sortLabels(geometry, groupedMap[xValue]);\n\n      while (group.length) {\n        var label = group.shift();\n\n        if (checkOriginEqual(label, dones, function (datumLeft, datumRight) {\n          return datumLeft._origin[xField] === datumRight._origin[xField] && datumLeft._origin[yField] === datumRight._origin[yField];\n        })) {\n          label.set('visible', false);\n          continue;\n        }\n\n        moveInPanel(label, panel);\n        var upFail = checkShapeOverlap(label, dones);\n        var downFail = void 0;\n\n        if (upFail) {\n          label.attr('y', label.attr('y') + 2 * offset);\n          moveInPanel(label, panel);\n          downFail = checkShapeOverlap(label, dones);\n        }\n\n        if (downFail) {\n          label.set('visible', false);\n          continue;\n        }\n\n        dones.push(label);\n      }\n    });\n  };\n  /** 对 Labels 排序，排序顺序决定自动布局优先级 */\n\n\n  PointAutoLabel.prototype.sortLabels = function (geometry, labels) {\n    var yField = geometry.getXYFields()[1];\n    var sorted = []; // 顺序：第一个、最后一个、再其他\n\n    labels.sort(function (a, b) {\n      return b.get(ORIGIN)[FIELD_ORIGIN][yField] - a.get(ORIGIN)[FIELD_ORIGIN][yField];\n    });\n\n    if (labels.length > 0) {\n      sorted.push(labels.shift());\n    }\n\n    if (labels.length > 0) {\n      sorted.push(labels.pop());\n    }\n\n    sorted.push.apply(sorted, labels);\n    return sorted;\n  };\n\n  return PointAutoLabel;\n}(PointLabel);\n\nexport default PointAutoLabel;\nregisterLabelComponent('point-auto', PointAutoLabel);","map":{"version":3,"sources":["../../../src/components/label/point-auto.ts"],"names":[],"mappings":"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","sourcesContent":["import { groupBy, each, keys } from '@antv/util';\nimport { registerLabelComponent } from './base';\nimport PointLabel from './point';\nimport { Geometry, IShape, MappingDatum, FIELD_ORIGIN, ORIGIN } from '../../dependents';\nimport { Label } from '../../interface/config';\nimport { checkOriginEqual, moveInPanel, checkShapeOverlap } from '../../util/view';\nimport BBox from '../../util/bbox';\n\nexport default class PointAutoLabel<L extends Label = Label> extends PointLabel<L> {\n  protected layoutLabels(geometry: Geometry, labels: IShape[]): void {\n    const dones: IShape[] = [];\n    const panel = BBox.fromBBoxObject(this.getCoordinateBBox());\n    const [xField, yField] = geometry.getXYFields();\n    const groupedMap: Record<string, IShape[]> = groupBy(labels, (label) => label.get(ORIGIN)[FIELD_ORIGIN][xField]);\n    const offset = labels[0]?.get('offset');\n\n    each(keys(groupedMap).reverse(), (xValue: string) => {\n      const group = this.sortLabels(geometry, groupedMap[xValue]);\n      while (group.length) {\n        const label = group.shift();\n        if (\n          checkOriginEqual(\n            label,\n            dones,\n            (datumLeft: MappingDatum, datumRight: MappingDatum) =>\n              datumLeft._origin[xField] === datumRight._origin[xField] &&\n              datumLeft._origin[yField] === datumRight._origin[yField]\n          )\n        ) {\n          label.set('visible', false);\n          continue;\n        }\n        moveInPanel(label, panel);\n        const upFail = checkShapeOverlap(label, dones);\n        let downFail: boolean;\n        if (upFail) {\n          label.attr('y', label.attr('y') + 2 * offset);\n          moveInPanel(label, panel);\n          downFail = checkShapeOverlap(label, dones);\n        }\n        if (downFail) {\n          label.set('visible', false);\n          continue;\n        }\n        dones.push(label);\n      }\n    });\n  }\n\n  /** 对 Labels 排序，排序顺序决定自动布局优先级 */\n  protected sortLabels(geometry: Geometry, labels: IShape[]): IShape[] {\n    const yField = geometry.getXYFields()[1];\n    const sorted: IShape[] = [];\n\n    // 顺序：第一个、最后一个、再其他\n    labels.sort((a, b) => {\n      return b.get(ORIGIN)[FIELD_ORIGIN][yField] - a.get(ORIGIN)[FIELD_ORIGIN][yField];\n    });\n    if (labels.length > 0) {\n      sorted.push(labels.shift());\n    }\n    if (labels.length > 0) {\n      sorted.push(labels.pop());\n    }\n    sorted.push(...labels);\n\n    return sorted;\n  }\n}\n\nregisterLabelComponent('point-auto', PointAutoLabel);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}