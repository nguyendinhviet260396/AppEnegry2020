{"ast":null,"code":"import { each, isArray } from '@antv/util';\nimport { parseStyle } from './parse';\nimport getArcParams from './arc-params';\nimport { mergeRegion, intersectRect } from './util';\nimport * as ArrowUtil from '../util/arrow';\nvar SHAPE_ATTRS_MAP = {\n  fill: 'fillStyle',\n  stroke: 'strokeStyle',\n  opacity: 'globalAlpha'\n};\nexport function applyAttrsToContext(context, element) {\n  var attrs = element.attr();\n\n  for (var k in attrs) {\n    var v = attrs[k]; // 转换一下不与 canvas 兼容的属性名\n\n    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\n\n    if (name_1 === 'matrix' && v) {\n      // 设置矩阵\n      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\n    } else if (name_1 === 'lineDash' && context.setLineDash) {\n      // 设置虚线，只支持数组形式，非数组形式不做任何操作\n      isArray(v) && context.setLineDash(v);\n    } else {\n      if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {\n        // 如果存在渐变、pattern 这个开销有些大\n        // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\n        v = parseStyle(context, element, v);\n      } else if (name_1 === 'globalAlpha') {\n        // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\n        v = v * context.globalAlpha;\n      }\n\n      context[name_1] = v;\n    }\n  }\n}\nexport function drawChildren(context, children, region) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child.get('visible')) {\n      child.draw(context, region);\n    } else {\n      child.skipDraw();\n    }\n  }\n} // 绘制 path\n\nexport function drawPath(shape, context, attrs, arcParamsCache) {\n  var path = attrs.path,\n      startArrow = attrs.startArrow,\n      endArrow = attrs.endArrow;\n  var currentPoint = [0, 0]; // 当前图形\n\n  var startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\n\n  var distance = {\n    dx: 0,\n    dy: 0\n  };\n  context.beginPath();\n\n  for (var i = 0; i < path.length; i++) {\n    var params = path[i];\n    var command = params[0];\n\n    if (i === 0 && startArrow && startArrow.d) {\n      var tangent = shape.getStartTangent();\n      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\n    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\n      // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\n      var lastPath = path[i + 1];\n\n      if (lastPath[0] === 'Z') {\n        var tangent = shape.getEndTangent();\n        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n      }\n    } else if (i === path.length - 1 && endArrow && endArrow.d) {\n      if (path[0] !== 'Z') {\n        var tangent = shape.getEndTangent();\n        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n      }\n    }\n\n    var dx = distance.dx,\n        dy = distance.dy; // V,H,S,T 都在前面被转换成标准形式\n\n    switch (command) {\n      case 'M':\n        context.moveTo(params[1] - dx, params[2] - dy);\n        startMovePoint = [params[1], params[2]];\n        break;\n\n      case 'L':\n        context.lineTo(params[1] - dx, params[2] - dy);\n        break;\n\n      case 'Q':\n        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\n        break;\n\n      case 'C':\n        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\n        break;\n\n      case 'A':\n        {\n          var arcParams = void 0; // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\n\n          if (arcParamsCache) {\n            arcParams = arcParamsCache[i];\n\n            if (!arcParams) {\n              arcParams = getArcParams(currentPoint, params);\n              arcParamsCache[i] = arcParams;\n            }\n          } else {\n            arcParams = getArcParams(currentPoint, params);\n          }\n\n          var cx = arcParams.cx,\n              cy = arcParams.cy,\n              rx = arcParams.rx,\n              ry = arcParams.ry,\n              startAngle = arcParams.startAngle,\n              endAngle = arcParams.endAngle,\n              xRotation = arcParams.xRotation,\n              sweepFlag = arcParams.sweepFlag; // 直接使用椭圆的 api\n\n          if (context.ellipse) {\n            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\n          } else {\n            var r = rx > ry ? rx : ry;\n            var scaleX = rx > ry ? 1 : rx / ry;\n            var scaleY = rx > ry ? ry / rx : 1;\n            context.translate(cx, cy);\n            context.rotate(xRotation);\n            context.scale(scaleX, scaleY);\n            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\n            context.scale(1 / scaleX, 1 / scaleY);\n            context.rotate(-xRotation);\n            context.translate(-cx, -cy);\n          }\n\n          break;\n        }\n\n      case 'Z':\n        context.closePath();\n        break;\n\n      default:\n        break;\n    } // 有了 Z 后，当前节点从开始 M 的点开始\n\n\n    if (command === 'Z') {\n      currentPoint = startMovePoint;\n    } else {\n      var len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n  }\n} // 刷新图形元素(Shape 或者 Group)\n\nexport function refreshElement(element, changeType) {\n  var canvas = element.get('canvas'); // 只有存在于 canvas 上时生效\n\n  if (canvas) {\n    if (changeType === 'remove') {\n      // 一旦 remove，则无法在 element 上拿到包围盒\n      // destroy 后所有属性都拿不到，所以需要暂存一下\n      // 这是一段 hack 的代码\n      element._cacheCanvasBBox = element.get('cacheCanvasBBox');\n    } // 防止反复刷新\n\n\n    if (!element.get('hasChanged')) {\n      // 本来只有局部渲染模式下，才需要记录更新的元素队列\n      // if (canvas.get('localRefresh')) {\n      //   canvas.refreshElement(element, changeType, canvas);\n      // }\n      // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\n      canvas.refreshElement(element, changeType, canvas);\n\n      if (canvas.get('autoDraw')) {\n        canvas.draw();\n      }\n\n      element.set('hasChanged', true);\n    }\n  }\n}\nexport function getRefreshRegion(element) {\n  var region;\n\n  if (!element.destroyed) {\n    var cacheBox = element.get('cacheCanvasBBox');\n    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\n    var bbox = element.getCanvasBBox();\n    var validBBox = bbox && !!(bbox.width && bbox.height); // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\n\n    if (validCache && validBBox) {\n      region = mergeRegion(cacheBox, bbox);\n    } else if (validCache) {\n      region = cacheBox;\n    } else if (validBBox) {\n      region = bbox;\n    }\n  } else {\n    // 因为元素已经销毁所以无法获取到缓存的包围盒\n    region = element['_cacheCanvasBBox'];\n  }\n\n  return region;\n}\nexport function getMergedRegion(elements) {\n  if (!elements.length) {\n    return null;\n  }\n\n  var minXArr = [];\n  var minYArr = [];\n  var maxXArr = [];\n  var maxYArr = [];\n  each(elements, function (el) {\n    var region = getRefreshRegion(el);\n\n    if (region) {\n      minXArr.push(region.minX);\n      minYArr.push(region.minY);\n      maxXArr.push(region.maxX);\n      maxYArr.push(region.maxY);\n    }\n  });\n  return {\n    minX: Math.min.apply(null, minXArr),\n    minY: Math.min.apply(null, minYArr),\n    maxX: Math.max.apply(null, maxXArr),\n    maxY: Math.max.apply(null, maxYArr)\n  };\n}\nexport function mergeView(region, viewRegion) {\n  if (!region || !viewRegion) {\n    return null;\n  } // 不相交，则直接返回 null\n\n\n  if (!intersectRect(region, viewRegion)) {\n    return null;\n  }\n\n  return {\n    minX: Math.max(region.minX, viewRegion.minX),\n    minY: Math.max(region.minY, viewRegion.minY),\n    maxX: Math.min(region.maxX, viewRegion.maxX),\n    maxY: Math.min(region.maxY, viewRegion.maxY)\n  };\n}","map":{"version":3,"sources":["../../src/util/draw.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { each, isArray } from '@antv/util';\nimport { parseStyle } from './parse';\nimport getArcParams from './arc-params';\nimport { mergeRegion, intersectRect } from './util';\nimport * as ArrowUtil from '../util/arrow';\nvar SHAPE_ATTRS_MAP = {\n    fill: 'fillStyle',\n    stroke: 'strokeStyle',\n    opacity: 'globalAlpha',\n};\nexport function applyAttrsToContext(context, element) {\n    var attrs = element.attr();\n    for (var k in attrs) {\n        var v = attrs[k];\n        // 转换一下不与 canvas 兼容的属性名\n        var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\n        if (name_1 === 'matrix' && v) {\n            // 设置矩阵\n            context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\n        }\n        else if (name_1 === 'lineDash' && context.setLineDash) {\n            // 设置虚线，只支持数组形式，非数组形式不做任何操作\n            isArray(v) && context.setLineDash(v);\n        }\n        else {\n            if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {\n                // 如果存在渐变、pattern 这个开销有些大\n                // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\n                v = parseStyle(context, element, v);\n            }\n            else if (name_1 === 'globalAlpha') {\n                // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\n                v = v * context.globalAlpha;\n            }\n            context[name_1] = v;\n        }\n    }\n}\nexport function drawChildren(context, children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.get('visible')) {\n            child.draw(context, region);\n        }\n        else {\n            child.skipDraw();\n        }\n    }\n}\n// 绘制 path\nexport function drawPath(shape, context, attrs, arcParamsCache) {\n    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n    var currentPoint = [0, 0]; // 当前图形\n    var startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\n    var distance = {\n        dx: 0,\n        dy: 0,\n    };\n    context.beginPath();\n    for (var i = 0; i < path.length; i++) {\n        var params = path[i];\n        var command = params[0];\n        if (i === 0 && startArrow && startArrow.d) {\n            var tangent = shape.getStartTangent();\n            distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\n        }\n        else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\n            // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\n            var lastPath = path[i + 1];\n            if (lastPath[0] === 'Z') {\n                var tangent = shape.getEndTangent();\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n            }\n        }\n        else if (i === path.length - 1 && endArrow && endArrow.d) {\n            if (path[0] !== 'Z') {\n                var tangent = shape.getEndTangent();\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n            }\n        }\n        var dx = distance.dx, dy = distance.dy;\n        // V,H,S,T 都在前面被转换成标准形式\n        switch (command) {\n            case 'M':\n                context.moveTo(params[1] - dx, params[2] - dy);\n                startMovePoint = [params[1], params[2]];\n                break;\n            case 'L':\n                context.lineTo(params[1] - dx, params[2] - dy);\n                break;\n            case 'Q':\n                context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\n                break;\n            case 'C':\n                context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\n                break;\n            case 'A': {\n                var arcParams = void 0;\n                // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\n                if (arcParamsCache) {\n                    arcParams = arcParamsCache[i];\n                    if (!arcParams) {\n                        arcParams = getArcParams(currentPoint, params);\n                        arcParamsCache[i] = arcParams;\n                    }\n                }\n                else {\n                    arcParams = getArcParams(currentPoint, params);\n                }\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;\n                // 直接使用椭圆的 api\n                if (context.ellipse) {\n                    context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\n                }\n                else {\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    context.translate(cx, cy);\n                    context.rotate(xRotation);\n                    context.scale(scaleX, scaleY);\n                    context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\n                    context.scale(1 / scaleX, 1 / scaleY);\n                    context.rotate(-xRotation);\n                    context.translate(-cx, -cy);\n                }\n                break;\n            }\n            case 'Z':\n                context.closePath();\n                break;\n            default:\n                break;\n        }\n        // 有了 Z 后，当前节点从开始 M 的点开始\n        if (command === 'Z') {\n            currentPoint = startMovePoint;\n        }\n        else {\n            var len = params.length;\n            currentPoint = [params[len - 2], params[len - 1]];\n        }\n    }\n}\n// 刷新图形元素(Shape 或者 Group)\nexport function refreshElement(element, changeType) {\n    var canvas = element.get('canvas');\n    // 只有存在于 canvas 上时生效\n    if (canvas) {\n        if (changeType === 'remove') {\n            // 一旦 remove，则无法在 element 上拿到包围盒\n            // destroy 后所有属性都拿不到，所以需要暂存一下\n            // 这是一段 hack 的代码\n            element._cacheCanvasBBox = element.get('cacheCanvasBBox');\n        }\n        // 防止反复刷新\n        if (!element.get('hasChanged')) {\n            // 本来只有局部渲染模式下，才需要记录更新的元素队列\n            // if (canvas.get('localRefresh')) {\n            //   canvas.refreshElement(element, changeType, canvas);\n            // }\n            // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\n            canvas.refreshElement(element, changeType, canvas);\n            if (canvas.get('autoDraw')) {\n                canvas.draw();\n            }\n            element.set('hasChanged', true);\n        }\n    }\n}\nexport function getRefreshRegion(element) {\n    var region;\n    if (!element.destroyed) {\n        var cacheBox = element.get('cacheCanvasBBox');\n        var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\n        var bbox = element.getCanvasBBox();\n        var validBBox = bbox && !!(bbox.width && bbox.height);\n        // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\n        if (validCache && validBBox) {\n            region = mergeRegion(cacheBox, bbox);\n        }\n        else if (validCache) {\n            region = cacheBox;\n        }\n        else if (validBBox) {\n            region = bbox;\n        }\n    }\n    else {\n        // 因为元素已经销毁所以无法获取到缓存的包围盒\n        region = element['_cacheCanvasBBox'];\n    }\n    return region;\n}\nexport function getMergedRegion(elements) {\n    if (!elements.length) {\n        return null;\n    }\n    var minXArr = [];\n    var minYArr = [];\n    var maxXArr = [];\n    var maxYArr = [];\n    each(elements, function (el) {\n        var region = getRefreshRegion(el);\n        if (region) {\n            minXArr.push(region.minX);\n            minYArr.push(region.minY);\n            maxXArr.push(region.maxX);\n            maxYArr.push(region.maxY);\n        }\n    });\n    return {\n        minX: Math.min.apply(null, minXArr),\n        minY: Math.min.apply(null, minYArr),\n        maxX: Math.max.apply(null, maxXArr),\n        maxY: Math.max.apply(null, maxYArr),\n    };\n}\nexport function mergeView(region, viewRegion) {\n    if (!region || !viewRegion) {\n        return null;\n    }\n    // 不相交，则直接返回 null\n    if (!intersectRect(region, viewRegion)) {\n        return null;\n    }\n    return {\n        minX: Math.max(region.minX, viewRegion.minX),\n        minY: Math.max(region.minY, viewRegion.minY),\n        maxX: Math.min(region.maxX, viewRegion.maxX),\n        maxY: Math.min(region.maxY, viewRegion.maxY),\n    };\n}\n//# sourceMappingURL=draw.js.map"]},"metadata":{},"sourceType":"module"}