{"ast":null,"code":"import { getMaxLabelWidth } from '../../util/label'; // 文本是否旋转\n\nfunction isRotate(label) {\n  var matrix = label.attr('matrix');\n  return matrix && matrix[0] !== 1; // 仅在这个场景下判定\n} // autohide 不再考虑超出限制\n// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {\n//   if (!limitLength) {\n//     // 如果没限制 limitLength 则直接返回 false\n//     return false;\n//   }\n//   const canvasBBox = label.getCanvasBBox();\n//   let isOut = false;\n//   if (isVertical) {\n//     isOut = canvasBBox.width > limitLength;\n//   } else {\n//     isOut = canvasBBox.height > limitLength;\n//   }\n//   return isOut;\n// }\n// 是否重叠\n\n\nfunction isOverlap(isVertical, rotated, preBox, curBox, reversed) {\n  if (reversed === void 0) {\n    reversed = false;\n  }\n\n  var overlap = false;\n\n  if (isVertical) {\n    // 垂直时检测边高\n    overlap = Math.abs(preBox.y - curBox.y) < preBox.height;\n  } else {\n    // 水平时检测\n    if (rotated) {\n      // 如果旋转了，则检测两者 x 之间的间距是否小于前一个的高度\n      var height = reversed ? curBox.height : preBox.height;\n      overlap = Math.abs(preBox.x - curBox.x) < height;\n    } else {\n      // 检测两者是否 x 方向重合\n      var width = reversed ? curBox.width : preBox.width;\n      overlap = Math.abs(preBox.x - curBox.x) < width;\n    }\n  }\n\n  return overlap;\n} // 保留第一个或者最后一个\n\n\nfunction reserveOne(isVertical, labelsGroup, reversed) {\n  var labels = labelsGroup.getChildren().slice(); // 复制数组\n\n  if (!labels.length) {\n    return false;\n  }\n\n  var hasHide = false;\n\n  if (reversed) {\n    // 翻转\n    labels.reverse();\n  }\n\n  var count = labels.length;\n  var first = labels[0];\n  var rotated = isRotate(first);\n  var preBox = first.getBBox();\n\n  for (var i = 1; i < count; i++) {\n    var label = labels[i];\n    var curBBox = label.getBBox(); // 不再考虑超出限制，而仅仅根据是否重叠进行隐藏 isOutLimit(isVertical, label, limitLength) ||\n\n    var isHide = isOverlap(isVertical, rotated, preBox, curBBox, reversed);\n\n    if (isHide) {\n      label.hide();\n      hasHide = true;\n    } else {\n      preBox = curBBox;\n    }\n  }\n\n  return hasHide;\n}\n\nexport function getDefault() {\n  return equidistance;\n}\n/**\n * 保证首个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\n\nexport function reserveFirst(isVertical, labelsGroup) {\n  return reserveOne(isVertical, labelsGroup, false);\n}\n/**\n * 保证最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\n\nexport function reserveLast(isVertical, labelsGroup) {\n  return reserveOne(isVertical, labelsGroup, true);\n}\n/**\n * 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\n\nexport function reserveBoth(isVertical, labelsGroup) {\n  var labels = labelsGroup.getChildren().slice(); // 复制数组\n\n  if (labels.length <= 2) {\n    // 如果数量小于或等于 2 则直接返回\n    return false;\n  }\n\n  var hasHide = false;\n  var count = labels.length;\n  var first = labels[0];\n  var last = labels[count - 1];\n  var rotated = isRotate(first);\n  var preBox = first.getBBox();\n  var preLabel = first; // 按照先保存第一个的逻辑循环一遍，最后一个不参与循环\n\n  for (var i = 1; i < count - 1; i++) {\n    var label = labels[i];\n    var curBBox = label.getBBox(); // 废弃 isOutLimit(isVertical, label, limitLength) ||\n\n    var isHide = isOverlap(isVertical, rotated, preBox, curBBox);\n\n    if (isHide) {\n      label.hide();\n      hasHide = true;\n    } else {\n      preBox = curBBox;\n      preLabel = label;\n    }\n  }\n\n  var lastBBox = last.getBBox();\n  var overlap = isOverlap(isVertical, rotated, preBox, lastBBox); // 不检测超出 limit\n\n  if (overlap) {\n    // 发生冲突，则隐藏前一个保留后一个\n    preLabel.hide();\n    hasHide = true;\n  }\n\n  return hasHide;\n}\n/**\n * 保证 label 均匀显示，主要解决文本层叠的问题，对于 limitLength 不处理\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\n\nexport function equidistance(isVertical, labelsGroup) {\n  var labels = labelsGroup.getChildren().slice(); // 复制数组\n\n  if (labels.length < 2) {\n    // 如果数量小于 2 则直接返回，等于 2 时可能也会重合\n    return false;\n  }\n\n  var hasHide = false;\n  var first = labels[0];\n  var firstBBox = first.getBBox();\n  var second = labels[1];\n  var rotated = isRotate(first);\n  var count = labels.length;\n  var interval = 0; // 不重叠的坐标文本间距个数\n\n  if (isVertical) {\n    // 垂直的坐标轴计算垂直方向的间距\n    var distance = Math.abs(second.attr('y') - first.attr('y'));\n    interval = firstBBox.height / distance;\n  } else {\n    // 水平坐标轴\n    if (rotated) {\n      var distance = Math.abs(second.attr('x') - first.attr('x'));\n      interval = firstBBox.width / distance;\n    } else {\n      var maxWidth = getMaxLabelWidth(labels);\n      var distance = Math.abs(second.attr('x') - first.attr('x'));\n      interval = maxWidth / distance;\n    }\n  } // interval > 1 时需要对 label 进行隐藏\n\n\n  if (interval > 1) {\n    interval = Math.ceil(interval);\n\n    for (var i = 0; i < count; i++) {\n      if (i % interval !== 0) {\n        // 仅保留被整除的 label\n        labels[i].hide();\n        hasHide = true;\n      }\n    }\n  }\n\n  return hasHide;\n}","map":{"version":3,"sources":["../../../src/axis/overlap/auto-hide.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMaxLabelWidth } from '../../util/label';\n// 文本是否旋转\nfunction isRotate(label) {\n    var matrix = label.attr('matrix');\n    return matrix && matrix[0] !== 1; // 仅在这个场景下判定\n}\n// autohide 不再考虑超出限制\n// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {\n//   if (!limitLength) {\n//     // 如果没限制 limitLength 则直接返回 false\n//     return false;\n//   }\n//   const canvasBBox = label.getCanvasBBox();\n//   let isOut = false;\n//   if (isVertical) {\n//     isOut = canvasBBox.width > limitLength;\n//   } else {\n//     isOut = canvasBBox.height > limitLength;\n//   }\n//   return isOut;\n// }\n// 是否重叠\nfunction isOverlap(isVertical, rotated, preBox, curBox, reversed) {\n    if (reversed === void 0) { reversed = false; }\n    var overlap = false;\n    if (isVertical) {\n        // 垂直时检测边高\n        overlap = Math.abs(preBox.y - curBox.y) < preBox.height;\n    }\n    else {\n        // 水平时检测\n        if (rotated) {\n            // 如果旋转了，则检测两者 x 之间的间距是否小于前一个的高度\n            var height = reversed ? curBox.height : preBox.height;\n            overlap = Math.abs(preBox.x - curBox.x) < height;\n        }\n        else {\n            // 检测两者是否 x 方向重合\n            var width = reversed ? curBox.width : preBox.width;\n            overlap = Math.abs(preBox.x - curBox.x) < width;\n        }\n    }\n    return overlap;\n}\n// 保留第一个或者最后一个\nfunction reserveOne(isVertical, labelsGroup, reversed) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (!labels.length) {\n        return false;\n    }\n    var hasHide = false;\n    if (reversed) {\n        // 翻转\n        labels.reverse();\n    }\n    var count = labels.length;\n    var first = labels[0];\n    var rotated = isRotate(first);\n    var preBox = first.getBBox();\n    for (var i = 1; i < count; i++) {\n        var label = labels[i];\n        var curBBox = label.getBBox();\n        // 不再考虑超出限制，而仅仅根据是否重叠进行隐藏 isOutLimit(isVertical, label, limitLength) ||\n        var isHide = isOverlap(isVertical, rotated, preBox, curBBox, reversed);\n        if (isHide) {\n            label.hide();\n            hasHide = true;\n        }\n        else {\n            preBox = curBBox;\n        }\n    }\n    return hasHide;\n}\nexport function getDefault() {\n    return equidistance;\n}\n/**\n * 保证首个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function reserveFirst(isVertical, labelsGroup) {\n    return reserveOne(isVertical, labelsGroup, false);\n}\n/**\n * 保证最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function reserveLast(isVertical, labelsGroup) {\n    return reserveOne(isVertical, labelsGroup, true);\n}\n/**\n * 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function reserveBoth(isVertical, labelsGroup) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (labels.length <= 2) {\n        // 如果数量小于或等于 2 则直接返回\n        return false;\n    }\n    var hasHide = false;\n    var count = labels.length;\n    var first = labels[0];\n    var last = labels[count - 1];\n    var rotated = isRotate(first);\n    var preBox = first.getBBox();\n    var preLabel = first;\n    // 按照先保存第一个的逻辑循环一遍，最后一个不参与循环\n    for (var i = 1; i < count - 1; i++) {\n        var label = labels[i];\n        var curBBox = label.getBBox();\n        // 废弃 isOutLimit(isVertical, label, limitLength) ||\n        var isHide = isOverlap(isVertical, rotated, preBox, curBBox);\n        if (isHide) {\n            label.hide();\n            hasHide = true;\n        }\n        else {\n            preBox = curBBox;\n            preLabel = label;\n        }\n    }\n    var lastBBox = last.getBBox();\n    var overlap = isOverlap(isVertical, rotated, preBox, lastBBox); // 不检测超出 limit\n    if (overlap) {\n        // 发生冲突，则隐藏前一个保留后一个\n        preLabel.hide();\n        hasHide = true;\n    }\n    return hasHide;\n}\n/**\n * 保证 label 均匀显示，主要解决文本层叠的问题，对于 limitLength 不处理\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function equidistance(isVertical, labelsGroup) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (labels.length < 2) {\n        // 如果数量小于 2 则直接返回，等于 2 时可能也会重合\n        return false;\n    }\n    var hasHide = false;\n    var first = labels[0];\n    var firstBBox = first.getBBox();\n    var second = labels[1];\n    var rotated = isRotate(first);\n    var count = labels.length;\n    var interval = 0; // 不重叠的坐标文本间距个数\n    if (isVertical) {\n        // 垂直的坐标轴计算垂直方向的间距\n        var distance = Math.abs(second.attr('y') - first.attr('y'));\n        interval = firstBBox.height / distance;\n    }\n    else {\n        // 水平坐标轴\n        if (rotated) {\n            var distance = Math.abs(second.attr('x') - first.attr('x'));\n            interval = firstBBox.width / distance;\n        }\n        else {\n            var maxWidth = getMaxLabelWidth(labels);\n            var distance = Math.abs(second.attr('x') - first.attr('x'));\n            interval = maxWidth / distance;\n        }\n    }\n    // interval > 1 时需要对 label 进行隐藏\n    if (interval > 1) {\n        interval = Math.ceil(interval);\n        for (var i = 0; i < count; i++) {\n            if (i % interval !== 0) {\n                // 仅保留被整除的 label\n                labels[i].hide();\n                hasHide = true;\n            }\n        }\n    }\n    return hasHide;\n}\n//# sourceMappingURL=auto-hide.js.map"]},"metadata":{},"sourceType":"module"}