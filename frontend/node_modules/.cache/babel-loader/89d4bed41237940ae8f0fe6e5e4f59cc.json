{"ast":null,"code":"import { registerAnimation } from '../../../dependents';\nimport { clone, isFunction, isNil, deepMix } from '@antv/util';\nvar plotInfo;\n\nfunction clipingWithData(shape, animateCfg) {\n  var defaultCfg = {\n    easing: 'easeLinear',\n    duration: 10000\n  };\n  var animationConfig = deepMix({}, animateCfg, defaultCfg);\n  var geometry = shape.get('element').geometry;\n  geometry.labelsContainer.set('visible', false);\n  /** 动画初始状态 */\n\n  var index = shape.get('index');\n  var coord = geometry.coordinate;\n  var scales = geometry.scales;\n  var yScale = scales[plotInfo.options.yField];\n  var shapeData = clone(shape.get('origin'));\n  setClip(shape, coord);\n  var clip = shape.get('clipShape');\n  var parent = shape.get('parent');\n  var offsetX = 12;\n  var title = null;\n  var seriesField = plotInfo.options.seriesField;\n\n  if (seriesField) {\n    title = parent.addShape('text', {\n      attrs: {\n        x: coord.start.x + offsetX,\n        y: 0,\n        text: shapeData.data[0][seriesField],\n        fill: shape.attr('stroke'),\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle'\n      }\n    });\n  }\n\n  var offsetY = title ? 16 : 0;\n  var marker = parent.addShape('text', {\n    attrs: {\n      x: coord.start.x + offsetX,\n      y: offsetY,\n      text: \"test\" + index,\n      fill: shape.attr('stroke'),\n      fontSize: 12,\n      textAlign: 'start',\n      textBaseline: 'middle'\n    }\n  });\n  /** 动画执行之后 */\n\n  animationConfig.callback = function () {\n    if (shape && !shape.get('destroyed')) {\n      shape.setClip(null);\n      clip.remove();\n      marker.animate({\n        opacity: 0\n      }, 300, function () {\n        marker.remove();\n\n        if (!isNil(title)) {\n          title.remove();\n        }\n\n        var labelsContainer = geometry.labelsContainer;\n\n        if (!labelsContainer.get('visible')) {\n          labelsContainer.set('visible', true);\n        }\n      });\n    }\n  };\n  /** 执行动画 */\n\n  /** 准备动画参数 */\n\n\n  var delay = animationConfig.delay;\n\n  if (isFunction(delay)) {\n    delay = animationConfig.delay(index);\n  }\n\n  var easing = animationConfig.easing;\n\n  if (isFunction(easing)) {\n    easing = animationConfig.easing(index);\n  }\n  /** 动起来 */\n\n\n  clip.animate({\n    width: coord.getWidth()\n  }, animationConfig.duration, easing, animationConfig.callback, delay);\n  animationConfig.onFrame = function (ratio) {\n    var position = getPositionByRatio(ratio, shapeData, coord);\n    if (!position) return;\n    marker.attr('x', position[0] + offsetX);\n    marker.attr('y', position[1] + offsetY);\n    var yText = getDataByPosition(yScale, position[1], coord); // use formatter\n\n    if (yScale.formatter) {\n      yText = yScale.formatter(yText);\n    }\n\n    marker.attr('text', yText);\n  }, marker.animate(animationConfig.onFrame, {\n    duration: animationConfig.duration,\n    easing: easing,\n    callback: animationConfig.callback,\n    delay: delay\n  });\n\n  if (title) {\n    title.animate({\n      onFrame: function onFrame(ratio) {\n        var position = getPositionByRatio(ratio, shapeData, coord);\n        if (!position) return;\n        title.attr('x', position[0] + offsetX);\n        title.attr('y', position[1]);\n      }\n    }, animationConfig.duration, easing, animationConfig.callback, delay);\n  }\n}\n\nfunction setClip(shape, coord) {\n  var start = coord.start,\n      end = coord.end,\n      height = coord.height;\n  shape.setClip({\n    type: 'rect',\n    attrs: {\n      x: start.x,\n      y: end.y,\n      width: 0,\n      height: height\n    }\n  });\n}\n\nfunction getPositionByRatio(ratio, dataPoints, coord) {\n  var points = dataPoints.points;\n  var currentX = coord.start.x + coord.getWidth() * ratio;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var current = points[i];\n    var next = points[i + 1];\n\n    if (currentX >= current.x && currentX <= next.x) {\n      var m = (next.y - current.y) / (next.x - current.x); // 斜率\n\n      var y = current.y + m * (currentX - current.x);\n      return [currentX, y];\n    }\n  }\n}\n\nfunction getDataByPosition(scale, y, coord) {\n  var yRatio = (y - coord.start.y) / (coord.end.y - coord.start.y);\n  return scale.invert(yRatio).toFixed(2);\n}\n\nexport function getPlotOption(option) {\n  plotInfo = option;\n}\nregisterAnimation('clipingWithData', clipingWithData);","map":{"version":3,"sources":["../../../../src/plots/line/animation/clipIn-with-data.ts"],"names":[],"mappings":"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","sourcesContent":["import { registerAnimation } from '../../../dependents';\nimport { clone, isFunction, isNil, deepMix } from '@antv/util';\n\nlet plotInfo;\n\nfunction clipingWithData(shape, animateCfg) {\n  const defaultCfg = {\n    easing: 'easeLinear',\n    duration: 10000,\n  };\n  const animationConfig = deepMix({}, animateCfg, defaultCfg);\n  const geometry = shape.get('element').geometry;\n  geometry.labelsContainer.set('visible', false);\n  /** 动画初始状态 */\n  const index = shape.get('index');\n  const coord = geometry.coordinate;\n  const scales = geometry.scales;\n  const yScale = scales[plotInfo.options.yField];\n  const shapeData = clone(shape.get('origin'));\n  setClip(shape, coord);\n  const clip = shape.get('clipShape');\n  const parent = shape.get('parent');\n  const offsetX = 12;\n  let title = null;\n  const { seriesField } = plotInfo.options;\n  if (seriesField) {\n    title = parent.addShape('text', {\n      attrs: {\n        x: coord.start.x + offsetX,\n        y: 0,\n        text: shapeData.data[0][seriesField],\n        fill: shape.attr('stroke'),\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle',\n      },\n    });\n  }\n  const offsetY = title ? 16 : 0;\n  const marker = parent.addShape('text', {\n    attrs: {\n      x: coord.start.x + offsetX,\n      y: offsetY,\n      text: `test${index}`,\n      fill: shape.attr('stroke'),\n      fontSize: 12,\n      textAlign: 'start',\n      textBaseline: 'middle',\n    },\n  });\n  /** 动画执行之后 */\n  animationConfig.callback = () => {\n    if (shape && !shape.get('destroyed')) {\n      shape.setClip(null);\n      clip.remove();\n      marker.animate(\n        {\n          opacity: 0,\n        },\n        300,\n        () => {\n          marker.remove();\n          if (!isNil(title)) {\n            title.remove();\n          }\n          const labelsContainer = geometry.labelsContainer;\n          if (!labelsContainer.get('visible')) {\n            labelsContainer.set('visible', true);\n          }\n        }\n      );\n    }\n  };\n  /** 执行动画 */\n  /** 准备动画参数 */\n  let delay = animationConfig.delay;\n  if (isFunction(delay)) {\n    delay = animationConfig.delay(index);\n  }\n  let easing = animationConfig.easing;\n  if (isFunction(easing)) {\n    easing = animationConfig.easing(index);\n  }\n  /** 动起来 */\n  clip.animate(\n    {\n      width: coord.getWidth(),\n    },\n    animationConfig.duration,\n    easing,\n    animationConfig.callback,\n    delay\n  );\n  (animationConfig.onFrame = (ratio) => {\n    const position = getPositionByRatio(ratio, shapeData, coord);\n    if (!position) return;\n\n    marker.attr('x', position[0] + offsetX);\n    marker.attr('y', position[1] + offsetY);\n    let yText = getDataByPosition(yScale, position[1], coord);\n\n    // use formatter\n    if (yScale.formatter) {\n      yText = yScale.formatter(yText);\n    }\n\n    marker.attr('text', yText);\n  }),\n    marker.animate(animationConfig.onFrame, {\n      duration: animationConfig.duration,\n      easing,\n      callback: animationConfig.callback,\n      delay,\n    });\n  if (title) {\n    title.animate(\n      {\n        onFrame: (ratio) => {\n          const position = getPositionByRatio(ratio, shapeData, coord);\n          if (!position) return;\n          title.attr('x', position[0] + offsetX);\n          title.attr('y', position[1]);\n        },\n      },\n      animationConfig.duration,\n      easing,\n      animationConfig.callback,\n      delay\n    );\n  }\n}\n\nfunction setClip(shape, coord) {\n  const { start, end, height } = coord;\n  shape.setClip({\n    type: 'rect',\n    attrs: {\n      x: start.x,\n      y: end.y,\n      width: 0,\n      height,\n    },\n  });\n}\n\nfunction getPositionByRatio(ratio, dataPoints, coord) {\n  const { points } = dataPoints;\n  const currentX = coord.start.x + coord.getWidth() * ratio;\n  for (let i = 0; i < points.length - 1; i++) {\n    const current = points[i];\n    const next = points[i + 1];\n    if (currentX >= current.x && currentX <= next.x) {\n      const m = (next.y - current.y) / (next.x - current.x); // 斜率\n      const y = current.y + m * (currentX - current.x);\n      return [currentX, y];\n    }\n  }\n}\n\nfunction getDataByPosition(scale, y, coord) {\n  const yRatio = (y - coord.start.y) / (coord.end.y - coord.start.y);\n  return scale.invert(yRatio).toFixed(2);\n}\n\nexport function getPlotOption(option) {\n  plotInfo = option;\n}\n\nregisterAnimation('clipingWithData', clipingWithData);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}