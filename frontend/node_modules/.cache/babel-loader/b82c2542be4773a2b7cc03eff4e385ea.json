{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Scrollbar } from '../dependents';\nimport BBox from '../util/bbox';\nimport { clamp, get, isEqual, throttle } from '@antv/util';\nimport BaseInteraction from './base';\nimport { getDataByScaleRange } from './helper/data-range';\nimport { VIEW_LIFE_CIRCLE } from '@antv/g2/lib/constant';\nimport { VIEW_LAYER_LIFE_CYCLE } from '../base/constants';\nvar DEFAULT_PADDING = 4;\nvar DEFAULT_SIZE = 8;\nvar DEFAULT_CATEGORY_SIZE = 32;\nvar MIN_THUMB_LENGTH = 20;\nvar SCROLL_BAR_Z_INDEX = 999;\n\nvar getValidScrollbarConfig = function (cfg) {\n  if (cfg === void 0) {\n    cfg = {};\n  }\n\n  var _cfg = __assign({\n    type: 'horizontal',\n    categorySize: DEFAULT_CATEGORY_SIZE,\n    width: DEFAULT_SIZE,\n    height: DEFAULT_SIZE,\n    padding: [0, 0, 0, 0]\n  }, cfg); // default padding\n\n\n  if (!cfg.padding) {\n    _cfg.padding = _cfg.type === 'horizontal' ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];\n  }\n\n  return _cfg;\n};\n\nvar ScrollbarInteraction =\n/** @class */\nfunction (_super) {\n  __extends(ScrollbarInteraction, _super);\n\n  function ScrollbarInteraction() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.onChangeFn = throttle(_this.onChange.bind(_this), 20, {\n      leading: true\n    });\n    return _this;\n  }\n\n  ScrollbarInteraction.getInteractionRange = function (layerRange, interaction) {\n    var config = getValidScrollbarConfig(interaction);\n    var _a = config.padding,\n        paddingTop = _a[0],\n        paddingRight = _a[1],\n        paddingBottom = _a[2],\n        paddingLeft = _a[3];\n\n    if (config.type === 'horizontal') {\n      return new BBox(layerRange.minX, layerRange.maxY - config.height - paddingTop - paddingBottom, layerRange.width, config.height + paddingTop + paddingBottom);\n    } else {\n      return new BBox(layerRange.maxX - config.width - paddingLeft - paddingRight, layerRange.minY, config.width + paddingLeft + paddingRight, layerRange.height);\n    }\n  };\n\n  ScrollbarInteraction.prototype.render = function () {\n    var _this = this;\n\n    var layer = this.getViewLayer();\n    var view = this.view;\n    this.ratio = 0;\n    this.thumbOffset = 0;\n\n    var callback = function () {\n      var padding = _this.view.padding; // if we're not in `auto padding` process\n\n      if (padding === 'auto' || isEqual(padding, [0, 0, 0, 1])) {\n        return;\n      }\n\n      if (!_this.trackLen) {\n        _this.measureScrollBar();\n\n        _this.changeViewData(_this.getScrollRange(), true);\n      } else {\n        _this.renderScrollbar();\n      }\n    };\n\n    var changeDataCallback = function () {\n      // reset\n      _this.trackLen = 0;\n    };\n\n    view.on(VIEW_LIFE_CIRCLE.AFTER_PAINT, callback);\n    this.addDisposable(function () {\n      return view.off(VIEW_LIFE_CIRCLE.AFTER_PAINT, callback);\n    });\n    view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, callback);\n    this.addDisposable(function () {\n      return view.off(VIEW_LIFE_CIRCLE.AFTER_RENDER, callback);\n    });\n    layer.on(VIEW_LAYER_LIFE_CYCLE.BEFORE_CHANGE_DATA, changeDataCallback);\n    this.addDisposable(function () {\n      return layer.off(VIEW_LAYER_LIFE_CYCLE.BEFORE_CHANGE_DATA, changeDataCallback);\n    });\n  };\n\n  ScrollbarInteraction.prototype.start = function () {\n    return;\n  };\n\n  ScrollbarInteraction.prototype.clear = function () {\n    if (this.scrollbar) {\n      this.scrollbar.destroy();\n      this.scrollbar = null;\n    }\n\n    if (this.container) {\n      this.container.remove(true);\n      this.container = null;\n    }\n\n    this.trackLen = null;\n    this.thumbLen = null;\n  };\n\n  ScrollbarInteraction.prototype.renderScrollbar = function () {\n    var config = getValidScrollbarConfig(this.getInteractionConfig());\n    var range = this.getRange();\n    var isHorizontal = config.type !== 'vertical';\n    var panelRange = this.view.coordinateBBox;\n    var _a = config.padding,\n        paddingTop = _a[0],\n        paddingLeft = _a[3];\n    var position = isHorizontal ? {\n      x: panelRange.minX + paddingLeft,\n      y: range.minY + paddingTop\n    } : {\n      x: range.minX + paddingLeft,\n      y: panelRange.minY + paddingTop\n    };\n\n    if (!this.scrollbar) {\n      this.container = this.canvas.addGroup();\n      this.scrollbar = new Scrollbar({\n        container: this.container,\n        x: position.x,\n        y: position.y,\n        isHorizontal: isHorizontal,\n        trackLen: this.trackLen,\n        thumbLen: this.thumbLen,\n        thumbOffset: this.ratio * this.trackLen\n      });\n      this.scrollbar.init();\n      this.scrollbar.render();\n      this.scrollbar.get('group').set('zIndex', SCROLL_BAR_Z_INDEX);\n      this.scrollbar.on('scrollchange', this.onChangeFn);\n    } else {\n      this.scrollbar.update({\n        trackLen: this.trackLen,\n        thumbLen: this.thumbLen,\n        thumbOffset: this.thumbOffset,\n        x: position.x,\n        y: position.y\n      });\n      this.scrollbar.render();\n    }\n  };\n\n  ScrollbarInteraction.prototype.measureScrollBar = function () {\n    var config = getValidScrollbarConfig(this.getInteractionConfig());\n    var _a = config.padding,\n        paddingTop = _a[0],\n        paddingRight = _a[1],\n        paddingBottom = _a[2],\n        paddingLeft = _a[3];\n    var isHorizontal = config.type !== 'vertical';\n    var panelRange = this.view.coordinateBBox;\n    var xScale = this.view.getXScale();\n    var yScales = this.view.getYScales().filter(function (scale) {\n      return scale;\n    });\n    this.cnt = xScale.values.length;\n    this.xScaleCfg = {\n      field: xScale.field,\n      values: xScale.values || []\n    };\n    this.yScalesCfg = yScales;\n    this.step = Math.floor((isHorizontal ? panelRange.width : panelRange.height) / config.categorySize);\n    this.trackLen = isHorizontal ? panelRange.width - paddingLeft - paddingRight : panelRange.height - paddingTop - paddingBottom;\n    this.thumbLen = Math.max(this.trackLen * clamp(this.step / xScale.values.length, 0, 1), MIN_THUMB_LENGTH);\n  };\n\n  ScrollbarInteraction.prototype.getScrollRange = function () {\n    var startIdx = Math.floor((this.cnt - this.step) * clamp(this.ratio, 0, 1));\n    var endIdx = Math.min(startIdx + this.step, this.cnt);\n    return [startIdx, endIdx];\n  };\n\n  ScrollbarInteraction.prototype.changeViewData = function (_a, render) {\n    var _this = this;\n\n    var startIdx = _a[0],\n        endIdx = _a[1];\n    var config = getValidScrollbarConfig(this.getInteractionConfig());\n    var viewLayer = this.getViewLayer();\n    var meta = viewLayer.options.meta;\n    var origData = viewLayer.getData();\n    var newData = getDataByScaleRange(this.xScaleCfg.field, this.xScaleCfg.values, origData, [startIdx, endIdx], config.type === 'vertical'); // ScrollBar在滚动过程中保持\b\bY轴上scale配置: min/max/ticks\n\n    this.yScalesCfg.forEach(function (cfg) {\n      var metaCfg = get(meta, cfg.field) || {};\n\n      _this.view.scale(cfg.field, __assign(__assign({\n        formatter: cfg.formatter\n      }, metaCfg), {\n        type: cfg.type,\n        min: cfg.min,\n        max: cfg.max\n      }));\n    });\n\n    if (render) {\n      this.view.data(newData);\n      this.view.render();\n    } else {\n      this.view.changeData(newData);\n    }\n  };\n\n  ScrollbarInteraction.prototype.onChange = function (_a) {\n    var ratio = _a.ratio,\n        thumbOffset = _a.thumbOffset;\n    this.ratio = ratio;\n    this.thumbOffset = thumbOffset;\n    var origAnimate = this.view.getOptions().animate;\n    this.view.animate(false);\n    this.changeViewData(this.getScrollRange(), true);\n    this.view.animate(origAnimate); // update scrollbar\n\n    this.renderScrollbar();\n  };\n\n  return ScrollbarInteraction;\n}(BaseInteraction);\n\nexport default ScrollbarInteraction;","map":{"version":3,"sources":["../../src/interaction/scrollbar.ts"],"names":[],"mappings":"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","sourcesContent":["import { IGroup, Scrollbar } from '../dependents';\nimport BBox from '../util/bbox';\nimport { Scale } from '@antv/scale';\nimport { clamp, get, isEqual, throttle } from '@antv/util';\nimport ViewLayer from '../base/view-layer';\nimport { IScrollbarInteractionConfig } from '../interface/config';\nimport BaseInteraction from './base';\nimport { getDataByScaleRange } from './helper/data-range';\nimport { VIEW_LIFE_CIRCLE } from '@antv/g2/lib/constant';\nimport { VIEW_LAYER_LIFE_CYCLE } from '../base/constants';\n\nconst DEFAULT_PADDING: number = 4;\nconst DEFAULT_SIZE: number = 8;\nconst DEFAULT_CATEGORY_SIZE: number = 32;\nconst MIN_THUMB_LENGTH: number = 20;\nconst SCROLL_BAR_Z_INDEX: number = 999;\n\nconst getValidScrollbarConfig = (cfg: IScrollbarInteractionConfig = {}): Required<IScrollbarInteractionConfig> => {\n  const _cfg: Required<IScrollbarInteractionConfig> = {\n    type: 'horizontal',\n    categorySize: DEFAULT_CATEGORY_SIZE,\n    width: DEFAULT_SIZE,\n    height: DEFAULT_SIZE,\n    padding: [0, 0, 0, 0],\n    ...cfg,\n  };\n\n  // default padding\n  if (!cfg.padding) {\n    _cfg.padding =\n      _cfg.type === 'horizontal' ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];\n  }\n\n  return _cfg;\n};\n\nexport default class ScrollbarInteraction extends BaseInteraction {\n  public static getInteractionRange(layerRange: BBox, interaction: IScrollbarInteractionConfig) {\n    const config: Required<IScrollbarInteractionConfig> = getValidScrollbarConfig(interaction);\n    const [paddingTop, paddingRight, paddingBottom, paddingLeft] = config.padding;\n\n    if (config.type === 'horizontal') {\n      return new BBox(\n        layerRange.minX,\n        layerRange.maxY - config.height - paddingTop - paddingBottom,\n        layerRange.width,\n        config.height + paddingTop + paddingBottom\n      );\n    } else {\n      return new BBox(\n        layerRange.maxX - config.width - paddingLeft - paddingRight,\n        layerRange.minY,\n        config.width + paddingLeft + paddingRight,\n        layerRange.height\n      );\n    }\n  }\n\n  private container: IGroup;\n  private scrollbar: Scrollbar;\n  private cnt: number;\n  private step: number;\n  private xScaleCfg: {\n    field: string;\n    values: string[];\n  };\n  private yScalesCfg: Scale[];\n  private ratio: number;\n  private thumbOffset: number;\n  private trackLen: number;\n  private thumbLen: number;\n  private onChangeFn = throttle(this.onChange.bind(this), 20, {\n    leading: true,\n  }) as (evt: object) => void;\n\n  public render(): void {\n    const layer = this.getViewLayer();\n    const view = this.view;\n    this.ratio = 0;\n    this.thumbOffset = 0;\n    const callback = () => {\n      const padding = this.view.padding;\n      // if we're not in `auto padding` process\n      if (padding === 'auto' || isEqual(padding, [0, 0, 0, 1])) {\n        return;\n      }\n      if (!this.trackLen) {\n        this.measureScrollBar();\n        this.changeViewData(this.getScrollRange(), true);\n      } else {\n        this.renderScrollbar();\n      }\n    };\n    const changeDataCallback = () => {\n      // reset\n      this.trackLen = 0;\n    };\n    view.on(VIEW_LIFE_CIRCLE.AFTER_PAINT, callback);\n    this.addDisposable(() => view.off(VIEW_LIFE_CIRCLE.AFTER_PAINT, callback));\n    view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, callback);\n    this.addDisposable(() => view.off(VIEW_LIFE_CIRCLE.AFTER_RENDER, callback));\n    layer.on(VIEW_LAYER_LIFE_CYCLE.BEFORE_CHANGE_DATA, changeDataCallback);\n    this.addDisposable(() => layer.off(VIEW_LAYER_LIFE_CYCLE.BEFORE_CHANGE_DATA, changeDataCallback));\n  }\n\n  protected start() {\n    return;\n  }\n\n  protected clear(): void {\n    if (this.scrollbar) {\n      this.scrollbar.destroy();\n      this.scrollbar = null;\n    }\n    if (this.container) {\n      this.container.remove(true);\n      this.container = null;\n    }\n    this.trackLen = null;\n    this.thumbLen = null;\n  }\n\n  private renderScrollbar(): void {\n    const config: Required<IScrollbarInteractionConfig> = getValidScrollbarConfig(this.getInteractionConfig());\n    const range = this.getRange();\n    const isHorizontal = config.type !== 'vertical';\n    const panelRange = this.view.coordinateBBox;\n    const [paddingTop, , , paddingLeft] = config.padding;\n    const position = isHorizontal\n      ? { x: panelRange.minX + paddingLeft, y: range.minY + paddingTop }\n      : { x: range.minX + paddingLeft, y: panelRange.minY + paddingTop };\n\n    if (!this.scrollbar) {\n      this.container = this.canvas.addGroup();\n      this.scrollbar = new Scrollbar({\n        container: this.container,\n        x: position.x,\n        y: position.y,\n        isHorizontal,\n        trackLen: this.trackLen,\n        thumbLen: this.thumbLen,\n        thumbOffset: this.ratio * this.trackLen,\n      });\n      this.scrollbar.init();\n      this.scrollbar.render();\n      this.scrollbar.get('group').set('zIndex', SCROLL_BAR_Z_INDEX);\n      this.scrollbar.on('scrollchange', this.onChangeFn);\n    } else {\n      this.scrollbar.update({\n        trackLen: this.trackLen,\n        thumbLen: this.thumbLen,\n        thumbOffset: this.thumbOffset,\n        x: position.x,\n        y: position.y,\n      });\n      this.scrollbar.render();\n    }\n  }\n\n  private measureScrollBar(): void {\n    const config: Required<IScrollbarInteractionConfig> = getValidScrollbarConfig(this.getInteractionConfig());\n    const [paddingTop, paddingRight, paddingBottom, paddingLeft] = config.padding;\n    const isHorizontal: boolean = config.type !== 'vertical';\n    const panelRange = this.view.coordinateBBox;\n    const xScale: Scale = this.view.getXScale();\n    const yScales: Scale[] = this.view.getYScales().filter((scale) => scale);\n\n    this.cnt = xScale.values.length;\n    this.xScaleCfg = { field: xScale.field, values: xScale.values || [] };\n    this.yScalesCfg = yScales;\n    this.step = Math.floor((isHorizontal ? panelRange.width : panelRange.height) / config.categorySize);\n    this.trackLen = isHorizontal\n      ? panelRange.width - paddingLeft - paddingRight\n      : panelRange.height - paddingTop - paddingBottom;\n    this.thumbLen = Math.max(this.trackLen * clamp(this.step / xScale.values.length, 0, 1), MIN_THUMB_LENGTH);\n  }\n\n  private getScrollRange(): [number, number] {\n    const startIdx: number = Math.floor((this.cnt - this.step) * clamp(this.ratio, 0, 1));\n    const endIdx: number = Math.min(startIdx + this.step, this.cnt);\n    return [startIdx, endIdx];\n  }\n\n  private changeViewData([startIdx, endIdx]: [number, number], render?: boolean): void {\n    const config: Required<IScrollbarInteractionConfig> = getValidScrollbarConfig(this.getInteractionConfig());\n    const viewLayer: ViewLayer = this.getViewLayer();\n    const { meta } = viewLayer.options;\n    const origData: object[] = viewLayer.getData();\n    const newData: object[] = getDataByScaleRange(\n      this.xScaleCfg.field,\n      this.xScaleCfg.values,\n      origData,\n      [startIdx, endIdx],\n      config.type === 'vertical'\n    );\n\n    // ScrollBar在滚动过程中保持\b\bY轴上scale配置: min/max/ticks\n    this.yScalesCfg.forEach((cfg) => {\n      const metaCfg = get(meta, cfg.field) || {};\n      this.view.scale(cfg.field, {\n        formatter: cfg.formatter,\n        ...metaCfg,\n        type: cfg.type as 'linear' | 'cat' | 'log' | 'pow' | 'identity' | 'time',\n        min: cfg.min,\n        max: cfg.max,\n      });\n    });\n    if (render) {\n      this.view.data(newData);\n      this.view.render();\n    } else {\n      this.view.changeData(newData);\n    }\n  }\n\n  private onChange({ ratio, thumbOffset }: { ratio: number; thumbOffset: number }): void {\n    this.ratio = ratio;\n    this.thumbOffset = thumbOffset;\n\n    const origAnimate = this.view.getOptions().animate;\n    this.view.animate(false);\n    this.changeViewData(this.getScrollRange(), true);\n    this.view.animate(origAnimate);\n    // update scrollbar\n    this.renderScrollbar();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}