{"ast":null,"code":"export function getEndPoint(center, angle, r) {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle)\n  };\n}\n/** 获取矩形中点 */\n\nexport function getCenter(box) {\n  return {\n    x: box.x + box.width / 2,\n    y: box.y + box.height / 2\n  };\n}\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/**\n * 计算两个矩形之间的堆叠情况\n * @return xOverlap x方向重叠大小\n * @return yOverlap y方向重叠大小\n */\n\nexport function getOverlapInfo(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)); // 添加 sign\n\n  if (xOverlap && a.x < b.x) {\n    xOverlap = -xOverlap;\n  }\n\n  if (yOverlap && a.y < b.y) {\n    yOverlap = -yOverlap;\n  } // 重叠\n\n\n  if (a.x === b.x && a.width === b.width) {\n    xOverlap = b.width;\n  }\n\n  if (a.y === b.y && a.height === b.height) {\n    yOverlap = b.height;\n  }\n\n  return {\n    xOverlap: xOverlap,\n    yOverlap: yOverlap\n  };\n}\n/**\n * 粗略地判断是否在panel内部\n * @param panel\n * @param shape\n */\n\nexport function inPanel(panel, shape) {\n  return panel.x < shape.x && panel.x + panel.width > shape.x + shape.width && panel.y < shape.y && panel.y + panel.height > shape.y + shape.height;\n}\n/**\n * 判断两个数值 是否接近\n * - 解决精度问题（由于无法确定精度上限，根据具体场景可传入 精度 参数）\n */\n\nexport var near = function near(x, y, e) {\n  if (e === void 0) {\n    e = Math.pow(Number.EPSILON, 0.5);\n  }\n\n  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;\n};\n/**\n * 获取点到圆心的连线与水平方向的夹角\n */\n\nexport function getAngleByPoint(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n/**\n * 获取 label 的旋转角度\n * @param angle\n */\n\nexport function getLabelRotate(angle) {\n  var HALF_PI = Math.PI / 2;\n  var rotate = angle;\n\n  if (rotate > HALF_PI || rotate < -HALF_PI) {\n    rotate = rotate + Math.PI;\n  }\n\n  return rotate;\n}","map":{"version":3,"sources":["../../../../../../src/plots/pie/component/label/utils/index.ts"],"names":[],"mappings":"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","sourcesContent":["export interface Point {\n  x: number;\n  y: number;\n}\n\nexport function getEndPoint(center, angle, r): Point {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle),\n  };\n}\n\nexport interface Box {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\n/** 获取矩形中点 */\nexport function getCenter(box: Box): Point {\n  return {\n    x: box.x + box.width / 2,\n    y: box.y + box.height / 2,\n  };\n}\n\nexport function getOverlapArea(a: Box, b: Box, margin = 0): number {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n  return xOverlap * yOverlap;\n}\n\n/**\n * 计算两个矩形之间的堆叠情况\n * @return xOverlap x方向重叠大小\n * @return yOverlap y方向重叠大小\n */\nexport function getOverlapInfo(a: Box, b: Box, margin = 0): { xOverlap: number; yOverlap: number } {\n  let xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  let yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  // 添加 sign\n  if (xOverlap && a.x < b.x) {\n    xOverlap = -xOverlap;\n  }\n  if (yOverlap && a.y < b.y) {\n    yOverlap = -yOverlap;\n  }\n\n  // 重叠\n  if (a.x === b.x && a.width === b.width) {\n    xOverlap = b.width;\n  }\n  if (a.y === b.y && a.height === b.height) {\n    yOverlap = b.height;\n  }\n\n  return { xOverlap, yOverlap };\n}\n\n/**\n * 粗略地判断是否在panel内部\n * @param panel\n * @param shape\n */\nexport function inPanel(panel: Box, shape: Box) {\n  return (\n    panel.x < shape.x &&\n    panel.x + panel.width > shape.x + shape.width &&\n    panel.y < shape.y &&\n    panel.y + panel.height > shape.y + shape.height\n  );\n}\n\n/**\n * 判断两个数值 是否接近\n * - 解决精度问题（由于无法确定精度上限，根据具体场景可传入 精度 参数）\n */\nexport const near = (x: number, y: number, e: number = Number.EPSILON ** 0.5): boolean =>\n  [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;\n\n/**\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate, point): number {\n  const center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\n/**\n * 获取 label 的旋转角度\n * @param angle\n */\nexport function getLabelRotate(angle: number) {\n  const HALF_PI = Math.PI / 2;\n  let rotate = angle;\n  if (rotate > HALF_PI || rotate < -HALF_PI) {\n    rotate = rotate + Math.PI;\n  }\n  return rotate;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}