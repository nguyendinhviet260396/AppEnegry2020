{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { get, isFunction, has, isString, isArray } from '@antv/util';\nimport ElementParser from '../base';\n\nvar LineParser =\n/** @class */\nfunction (_super) {\n  __extends(LineParser, _super);\n\n  function LineParser() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LineParser.prototype.init = function () {\n    var props = this.plot.options;\n    this.config = {\n      type: 'line',\n      position: {\n        fields: [props.xField, props.yField]\n      },\n      connectNulls: props.connectNulls\n    };\n\n    if (props.lineSize) {\n      this.parseSize();\n    }\n\n    if (props.smooth) {\n      this.config.shape = {\n        values: ['smooth']\n      };\n    }\n\n    if (props.step) {\n      this.config.shape = {\n        values: [props.step]\n      };\n    }\n\n    if (props.seriesField || props.color) {\n      this.parseColor();\n    }\n\n    if (props.lineStyle || get(props, ['line', 'style'])) {\n      this.parseStyle();\n    }\n  };\n\n  LineParser.prototype.parseSize = function () {\n    var sizeProps = this.plot.options.lineSize;\n    var config = {};\n\n    if (isFunction(sizeProps)) {\n      config.callback = sizeProps;\n    } else {\n      config.values = [sizeProps];\n    }\n\n    this.config.size = config;\n  };\n\n  LineParser.prototype.parseColor = function () {\n    var props = this.plot.options;\n    var config = {};\n\n    if (props.seriesField) {\n      config.fields = [props.seriesField];\n    }\n\n    if (has(props, 'color')) {\n      var color = props.color;\n\n      if (isString(color)) {\n        config.values = [color];\n      } else if (isFunction(color)) {\n        config.callback = color;\n      } else if (isArray(color)) {\n        if (props.seriesField) {\n          config.values = color;\n        } else {\n          if (color.length > 0) {\n            config.values = [color[0]];\n          }\n        }\n      }\n    }\n\n    this.config.color = config;\n  };\n\n  LineParser.prototype.parseStyle = function () {\n    var props = this.plot.options;\n    var styleProps = props.lineStyle || get(props, ['line', 'style']);\n    var config = {\n      fields: null,\n      callback: null,\n      cfg: null\n    };\n\n    if (isFunction(styleProps) && props.seriesField) {\n      config.fields = [props.seriesField];\n      config.callback = styleProps;\n    } else {\n      config.cfg = styleProps;\n    }\n\n    this.config.style = config;\n  };\n\n  return LineParser;\n}(ElementParser);\n\nexport default LineParser;","map":{"version":3,"sources":["../../../src/geoms/line/main.ts"],"names":[],"mappings":"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","sourcesContent":["import { LooseObject } from '../../dependents';\nimport { get, isFunction, has, isString, isArray } from '@antv/util';\nimport ElementParser from '../base';\n\nexport default class LineParser extends ElementParser {\n  public init() {\n    const props = this.plot.options;\n    this.config = {\n      type: 'line',\n      position: {\n        fields: [props.xField, props.yField],\n      },\n      connectNulls: props.connectNulls,\n    };\n    if (props.lineSize) {\n      this.parseSize();\n    }\n    if (props.smooth) {\n      this.config.shape = { values: ['smooth'] };\n    }\n    if (props.step) {\n      this.config.shape = { values: [props.step] };\n    }\n    if (props.seriesField || props.color) {\n      this.parseColor();\n    }\n    if (props.lineStyle || get(props, ['line', 'style'])) {\n      this.parseStyle();\n    }\n  }\n\n  public parseSize() {\n    const sizeProps = this.plot.options.lineSize;\n    const config: LooseObject = {};\n    if (isFunction(sizeProps)) {\n      config.callback = sizeProps;\n    } else {\n      config.values = [sizeProps];\n    }\n    this.config.size = config;\n  }\n\n  public parseColor() {\n    const props = this.plot.options;\n    const config: LooseObject = {};\n    if (props.seriesField) {\n      config.fields = [props.seriesField];\n    }\n    if (has(props, 'color')) {\n      const color = props.color;\n      if (isString(color)) {\n        config.values = [color];\n      } else if (isFunction(color)) {\n        config.callback = color;\n      } else if (isArray(color)) {\n        if (props.seriesField) {\n          config.values = color;\n        } else {\n          if (color.length > 0) {\n            config.values = [color[0]];\n          }\n        }\n      }\n    }\n\n    this.config.color = config;\n  }\n\n  public parseStyle() {\n    const props = this.plot.options;\n    const styleProps = props.lineStyle || get(props, ['line', 'style']);\n    const config = {\n      fields: null,\n      callback: null,\n      cfg: null,\n    };\n    if (isFunction(styleProps) && props.seriesField) {\n      config.fields = [props.seriesField];\n      config.callback = styleProps;\n    } else {\n      config.cfg = styleProps;\n    }\n    this.config.style = config;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}