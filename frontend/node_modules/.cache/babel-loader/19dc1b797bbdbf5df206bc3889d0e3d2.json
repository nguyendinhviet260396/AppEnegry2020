{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport EE from '@antv/event-emitter';\nimport * as d3Ease from 'd3-ease';\nimport { GM } from '../gm';\nimport { clock } from '../utils/clock'; // 看那个曲线跟合适了\n\nvar ease = d3Ease.easeCubicIn;\nvar TOTAL_MS = 800; // 惯性滚动时间；调参工程师，或者根据速度来计算这个时间\n\nvar SWIPE = 'swipe';\nvar PAN = 'pan';\nvar WHEEL = 'wheel';\n/**\n * 给 view 添加移动端的滚动能力：\n *  - 监听 touch 事件，emit wheel 事件\n *  - 滚动惯性包装\n *  - 和 pc 的 wheel 事件保持基本一致\n */\n\nvar Wheel =\n/** @class */\nfunction (_super) {\n  __extends(Wheel, _super);\n\n  function Wheel(element) {\n    var _this = _super.call(this) || this;\n\n    _this.rafMs = 0;\n    /**\n     * pan 事件\n     * @param ev\n     */\n\n    _this.onPan = function (ev) {\n      var deltaX = ev.deltaX,\n          deltaY = ev.deltaY;\n\n      var e = _this.getWrapperEvent(ev, deltaX, deltaY);\n\n      _this.emit(WHEEL, e);\n    };\n    /**\n     * 当出现 swipe 事件的时候\n     * @param ev\n     */\n\n\n    _this.onSwipe = function (ev) {\n      var speedX = ev.speedX,\n          speedY = ev.speedY; // raf 循环执行的时间戳\n\n      _this.rafMs = clock.now();\n      _this.ms = _this.rafMs; // 对于没有滑动的情况下，不做处理\n\n      if (speedX !== 0 || speedY !== 0) {\n        _this.rafInertia(ev);\n      }\n    };\n\n    _this.element = element;\n    _this.gm = new GM(element, {\n      gestures: ['Pan', 'Swipe']\n    });\n\n    _this.gm.on(SWIPE, _this.onSwipe);\n\n    _this.gm.on(PAN, _this.onPan);\n\n    return _this;\n  }\n\n  Wheel.prototype.destroy = function () {\n    window.cancelAnimationFrame(this.raf);\n    this.gm.destroy();\n    this.off();\n  }; // 使用 raf 进行惯性滑动\n\n\n  Wheel.prototype.rafInertia = function (ev) {\n    var _this = this;\n\n    var speedX = ev.speedX,\n        speedY = ev.speedY;\n    this.raf = window.requestAnimationFrame(function () {\n      var now = clock.now();\n      var ratio = (now - _this.ms) / TOTAL_MS;\n\n      if (ratio < 1) {\n        ratio = ease(1 - ratio); // 折损之后的速度 * 时间，等于距离\n\n        var t = now - _this.rafMs;\n        var movedX = speedX * ratio * t;\n        var movedY = speedY * ratio * t;\n\n        var e = _this.getWrapperEvent(ev, movedX, movedY); // 发出 wheel 事件\n\n\n        _this.emit(WHEEL, e);\n\n        _this.rafMs = now; // 记录时间\n        // 进行下一次\n\n        _this.rafInertia(ev);\n      }\n    });\n  };\n\n  Wheel.prototype.getWrapperEvent = function (ev, deltaX, deltaY) {\n    // 移动端的滑动应该是跟随手指\n    return __assign(__assign({}, ev), {\n      deltaX: -deltaX,\n      deltaY: -deltaY\n    });\n  };\n\n  return Wheel;\n}(EE);\n\nexport { Wheel };","map":{"version":3,"sources":["../../src/event/wheel.ts"],"names":[],"mappings":";AAAA,OAAO,EAAP,MAAe,qBAAf;AAEA,OAAO,KAAK,MAAZ,MAAwB,SAAxB;AAEA,SAAS,EAAT,QAAmB,OAAnB;AACA,SAAS,KAAT,QAAsB,gBAAtB,C,CAGA;;AACA,IAAM,IAAI,GAAG,MAAM,CAAC,WAApB;AAEA,IAAM,QAAQ,GAAG,GAAjB,C,CAAsB;;AAEtB,IAAM,KAAK,GAAG,OAAd;AACA,IAAM,GAAG,GAAG,KAAZ;AACA,IAAM,KAAK,GAAG,OAAd;AAEA;;;;;;;AAMA,IAAA,KAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA2B,EAAA,SAAA,CAAA,KAAA,EAAA,MAAA,CAAA;;AAYzB,WAAA,KAAA,CAAY,OAAZ,EAA6B;AAA7B,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADT;;AALQ,IAAA,KAAA,CAAA,KAAA,GAAgB,CAAhB;AAuBR;;;;;AAIQ,IAAA,KAAA,CAAA,KAAA,GAAQ,UAAC,EAAD,EAAiB;AACvB,UAAA,MAAA,GAAA,EAAA,CAAA,MAAA;AAAA,UAAQ,MAAA,GAAA,EAAA,CAAA,MAAR;;AAER,UAAM,CAAC,GAAG,KAAI,CAAC,eAAL,CAAqB,EAArB,EAAyB,MAAzB,EAAiC,MAAjC,CAAV;;AAEA,MAAA,KAAI,CAAC,IAAL,CAAU,KAAV,EAAiB,CAAjB;AACD,KANO;AAQR;;;;;;AAIQ,IAAA,KAAA,CAAA,OAAA,GAAU,UAAC,EAAD,EAAiB;AACzB,UAAA,MAAA,GAAA,EAAA,CAAA,MAAA;AAAA,UAAQ,MAAA,GAAA,EAAA,CAAA,MAAR,CADyB,CAEjC;;AACA,MAAA,KAAI,CAAC,KAAL,GAAa,KAAK,CAAC,GAAN,EAAb;AACA,MAAA,KAAI,CAAC,EAAL,GAAU,KAAI,CAAC,KAAf,CAJiC,CAMjC;;AACA,UAAI,MAAM,KAAK,CAAX,IAAgB,MAAM,KAAK,CAA/B,EAAkC;AAChC,QAAA,KAAI,CAAC,UAAL,CAAgB,EAAhB;AACD;AACF,KAVO;;AAhCN,IAAA,KAAI,CAAC,OAAL,GAAe,OAAf;AAEA,IAAA,KAAI,CAAC,EAAL,GAAU,IAAI,EAAJ,CAAO,OAAP,EAAgB;AAAE,MAAA,QAAQ,EAAE,CAAC,KAAD,EAAQ,OAAR;AAAZ,KAAhB,CAAV;;AAEA,IAAA,KAAI,CAAC,EAAL,CAAQ,EAAR,CAAW,KAAX,EAAkB,KAAI,CAAC,OAAvB;;AACA,IAAA,KAAI,CAAC,EAAL,CAAQ,EAAR,CAAW,GAAX,EAAgB,KAAI,CAAC,KAArB;;;AACD;;AAEM,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACE,IAAA,MAAM,CAAC,oBAAP,CAA4B,KAAK,GAAjC;AAEA,SAAK,EAAL,CAAQ,OAAR;AAEA,SAAK,GAAL;AACD,GANM,CAtBT,CA0DE;;;AACQ,EAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAR,UAAmB,EAAnB,EAAqB;AAArB,QAAA,KAAA,GAAA,IAAA;;AACU,QAAA,MAAA,GAAA,EAAA,CAAA,MAAA;AAAA,QAAQ,MAAA,GAAA,EAAA,CAAA,MAAR;AAER,SAAK,GAAL,GAAW,MAAM,CAAC,qBAAP,CAA6B,YAAA;AACtC,UAAM,GAAG,GAAG,KAAK,CAAC,GAAN,EAAZ;AAEA,UAAI,KAAK,GAAG,CAAC,GAAG,GAAG,KAAI,CAAC,EAAZ,IAAkB,QAA9B;;AACA,UAAI,KAAK,GAAG,CAAZ,EAAe;AACb,QAAA,KAAK,GAAG,IAAI,CAAC,IAAI,KAAL,CAAZ,CADa,CAEb;;AACA,YAAM,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,KAArB;AACA,YAAM,MAAM,GAAG,MAAM,GAAG,KAAT,GAAiB,CAAhC;AACA,YAAM,MAAM,GAAG,MAAM,GAAG,KAAT,GAAiB,CAAhC;;AAEA,YAAM,CAAC,GAAG,KAAI,CAAC,eAAL,CAAqB,EAArB,EAAyB,MAAzB,EAAiC,MAAjC,CAAV,CAPa,CASb;;;AACA,QAAA,KAAI,CAAC,IAAL,CAAU,KAAV,EAAiB,CAAjB;;AAEA,QAAA,KAAI,CAAC,KAAL,GAAa,GAAb,CAZa,CAYK;AAElB;;AACA,QAAA,KAAI,CAAC,UAAL,CAAgB,EAAhB;AACD;AACF,KArBU,CAAX;AAsBD,GAzBO;;AA2BA,EAAA,KAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,EAAxB,EAA4B,MAA5B,EAA4C,MAA5C,EAA0D;AACxD;AACA,WAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAY,EAAZ,CAAA,EAAc;AAAE,MAAA,MAAM,EAAE,CAAC,MAAX;AAAmB,MAAA,MAAM,EAAE,CAAC;AAA5B,KAAd,CAAA;AACD,GAHO;;AAIV,SAAA,KAAA;AAAC,CA1FD,CAA2B,EAA3B,CAAA","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport EE from '@antv/event-emitter';\nimport * as d3Ease from 'd3-ease';\nimport { GM } from '../gm';\nimport { clock } from '../utils/clock';\n// 看那个曲线跟合适了\nvar ease = d3Ease.easeCubicIn;\nvar TOTAL_MS = 800; // 惯性滚动时间；调参工程师，或者根据速度来计算这个时间\nvar SWIPE = 'swipe';\nvar PAN = 'pan';\nvar WHEEL = 'wheel';\n/**\n * 给 view 添加移动端的滚动能力：\n *  - 监听 touch 事件，emit wheel 事件\n *  - 滚动惯性包装\n *  - 和 pc 的 wheel 事件保持基本一致\n */\nvar Wheel = /** @class */ (function (_super) {\n    __extends(Wheel, _super);\n    function Wheel(element) {\n        var _this = _super.call(this) || this;\n        _this.rafMs = 0;\n        /**\n         * pan 事件\n         * @param ev\n         */\n        _this.onPan = function (ev) {\n            var deltaX = ev.deltaX, deltaY = ev.deltaY;\n            var e = _this.getWrapperEvent(ev, deltaX, deltaY);\n            _this.emit(WHEEL, e);\n        };\n        /**\n         * 当出现 swipe 事件的时候\n         * @param ev\n         */\n        _this.onSwipe = function (ev) {\n            var speedX = ev.speedX, speedY = ev.speedY;\n            // raf 循环执行的时间戳\n            _this.rafMs = clock.now();\n            _this.ms = _this.rafMs;\n            // 对于没有滑动的情况下，不做处理\n            if (speedX !== 0 || speedY !== 0) {\n                _this.rafInertia(ev);\n            }\n        };\n        _this.element = element;\n        _this.gm = new GM(element, { gestures: ['Pan', 'Swipe'] });\n        _this.gm.on(SWIPE, _this.onSwipe);\n        _this.gm.on(PAN, _this.onPan);\n        return _this;\n    }\n    Wheel.prototype.destroy = function () {\n        window.cancelAnimationFrame(this.raf);\n        this.gm.destroy();\n        this.off();\n    };\n    // 使用 raf 进行惯性滑动\n    Wheel.prototype.rafInertia = function (ev) {\n        var _this = this;\n        var speedX = ev.speedX, speedY = ev.speedY;\n        this.raf = window.requestAnimationFrame(function () {\n            var now = clock.now();\n            var ratio = (now - _this.ms) / TOTAL_MS;\n            if (ratio < 1) {\n                ratio = ease(1 - ratio);\n                // 折损之后的速度 * 时间，等于距离\n                var t = now - _this.rafMs;\n                var movedX = speedX * ratio * t;\n                var movedY = speedY * ratio * t;\n                var e = _this.getWrapperEvent(ev, movedX, movedY);\n                // 发出 wheel 事件\n                _this.emit(WHEEL, e);\n                _this.rafMs = now; // 记录时间\n                // 进行下一次\n                _this.rafInertia(ev);\n            }\n        });\n    };\n    Wheel.prototype.getWrapperEvent = function (ev, deltaX, deltaY) {\n        // 移动端的滑动应该是跟随手指\n        return __assign(__assign({}, ev), { deltaX: -deltaX, deltaY: -deltaY });\n    };\n    return Wheel;\n}(EE));\nexport { Wheel };\n//# sourceMappingURL=wheel.js.map"]},"metadata":{},"sourceType":"module"}