{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport PolarLabel from './polar';\n/**\n * 饼图 label\n */\n\nvar PieLabel =\n/** @class */\nfunction (_super) {\n  __extends(PieLabel, _super);\n\n  function PieLabel(geometry) {\n    var _this = _super.call(this, geometry) || this;\n\n    _this.defaultLayout = 'distribute';\n    return _this;\n  }\n\n  PieLabel.prototype.getDefaultLabelCfg = function () {\n    return get(this.geometry.theme, 'pieLabels', {});\n  };\n\n  PieLabel.prototype.getDefaultOffset = function (offset) {\n    return offset || 0;\n  };\n\n  PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {\n    var rotate;\n\n    if (offset < 0) {\n      rotate = angle;\n\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n\n    return rotate;\n  };\n\n  PieLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var align;\n\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n\n    var offset = this.getDefaultOffset(point.offset);\n\n    if (offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n\n    return align;\n  };\n\n  PieLabel.prototype.getArcPoint = function (point) {\n    return point;\n  };\n\n  PieLabel.prototype.getPointAngle = function (point) {\n    var coordinate = this.getCoordinate();\n    var startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0]\n    };\n    var endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1]\n    };\n    var angle;\n    var startAngle = getAngleByPoint(coordinate, startPoint);\n\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      var endAngle = getAngleByPoint(coordinate, endPoint);\n\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n\n    return angle;\n  };\n\n  PieLabel.prototype.getCirclePoint = function (angle, offset, p) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = coordinate.getRadius() + offset;\n    return __assign(__assign({}, polarToCartesian(center.x, center.y, r, angle)), {\n      angle: angle,\n      r: r\n    });\n  };\n\n  return PieLabel;\n}(PolarLabel);\n\nexport default PieLabel;","map":{"version":3,"sources":["../../../src/geometry/label/pie.ts"],"names":[],"mappings":";AAAA,SAAS,GAAT,EAAc,OAAd,QAA6B,YAA7B;AACA,SAAS,eAAT,QAAgC,uBAAhC;AACA,SAAS,gBAAT,QAAiC,qBAAjC;AAGA,OAAO,UAAP,MAAuB,SAAvB;AAEA;;;;AAGA,IAAA,QAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAsC,EAAA,SAAA,CAAA,QAAA,EAAA,MAAA,CAAA;;AAGpC,WAAA,QAAA,CAAY,QAAZ,EAA8B;AAA9B,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,QAAN,KAAe,IADjB;;AAFO,IAAA,KAAA,CAAA,aAAA,GAAgB,YAAhB;;AAIN;;AAES,EAAA,QAAA,CAAA,SAAA,CAAA,kBAAA,GAAV,YAAA;AACE,WAAO,GAAG,CAAC,KAAK,QAAL,CAAc,KAAf,EAAsB,WAAtB,EAAmC,EAAnC,CAAV;AACD,GAFS;;AAIA,EAAA,QAAA,CAAA,SAAA,CAAA,gBAAA,GAAV,UAA2B,MAA3B,EAAiC;AAC/B,WAAO,MAAM,IAAI,CAAjB;AACD,GAFS;;AAIA,EAAA,QAAA,CAAA,SAAA,CAAA,cAAA,GAAV,UAAyB,KAAzB,EAAwC,MAAxC,EAAwD,YAAxD,EAA6E;AAC3E,QAAI,MAAJ;;AACA,QAAI,MAAM,GAAG,CAAb,EAAgB;AACd,MAAA,MAAM,GAAG,KAAT;;AACA,UAAI,MAAM,GAAG,IAAI,CAAC,EAAL,GAAU,CAAvB,EAA0B;AACxB,QAAA,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,EAAvB;AACD;;AACD,UAAI,MAAM,GAAG,CAAC,IAAI,CAAC,EAAN,GAAW,CAAxB,EAA2B;AACzB,QAAA,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,EAAvB;AACD;AACF;;AACD,WAAO,MAAP;AACD,GAZS;;AAcA,EAAA,QAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,KAAxB,EAAwC;AACtC,QAAM,UAAU,GAAG,KAAK,aAAL,EAAnB;AACA,QAAM,MAAM,GAAG,UAAU,CAAC,SAAX,EAAf;AAEA,QAAI,KAAJ;;AACA,QAAI,KAAK,CAAC,KAAN,IAAe,IAAI,CAAC,EAAL,GAAU,CAAzB,IAA8B,KAAK,CAAC,CAAN,IAAW,MAAM,CAAC,CAApD,EAAuD;AACrD,MAAA,KAAK,GAAG,MAAR;AACD,KAFD,MAEO;AACL,MAAA,KAAK,GAAG,OAAR;AACD;;AACD,QAAM,MAAM,GAAG,KAAK,gBAAL,CAAsB,KAAK,CAAC,MAA5B,CAAf;;AACA,QAAI,MAAM,IAAI,CAAd,EAAiB;AACf,UAAI,KAAK,KAAK,OAAd,EAAuB;AACrB,QAAA,KAAK,GAAG,MAAR;AACD,OAFD,MAEO;AACL,QAAA,KAAK,GAAG,OAAR;AACD;AACF;;AACD,WAAO,KAAP;AACD,GAnBS;;AAqBA,EAAA,QAAA,CAAA,SAAA,CAAA,WAAA,GAAV,UAAsB,KAAtB,EAA2B;AACzB,WAAO,KAAP;AACD,GAFS;;AAIA,EAAA,QAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,KAAxB,EAA6B;AAC3B,QAAM,UAAU,GAAG,KAAK,aAAL,EAAnB;AACA,QAAM,UAAU,GAAG;AACjB,MAAA,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAP,CAAP,GAAmB,KAAK,CAAC,CAAN,CAAQ,CAAR,CAAnB,GAAgC,KAAK,CAAC,CADxB;AAEjB,MAAA,CAAC,EAAE,KAAK,CAAC,CAAN,CAAQ,CAAR;AAFc,KAAnB;AAIA,QAAM,QAAQ,GAAG;AACf,MAAA,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAP,CAAP,GAAmB,KAAK,CAAC,CAAN,CAAQ,CAAR,CAAnB,GAAgC,KAAK,CAAC,CAD1B;AAEf,MAAA,CAAC,EAAE,KAAK,CAAC,CAAN,CAAQ,CAAR;AAFY,KAAjB;AAIA,QAAI,KAAJ;AACA,QAAM,UAAU,GAAG,eAAe,CAAC,UAAD,EAAa,UAAb,CAAlC;;AACA,QAAI,KAAK,CAAC,MAAN,IAAgB,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,CAAhB,KAAsB,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,CAA1D,EAA6D;AAC3D,MAAA,KAAK,GAAG,UAAR;AACD,KAFD,MAEO;AACL,UAAI,QAAQ,GAAG,eAAe,CAAC,UAAD,EAAa,QAAb,CAA9B;;AACA,UAAI,UAAU,IAAI,QAAlB,EAA4B;AAC1B;AACA,QAAA,QAAQ,GAAG,QAAQ,GAAG,IAAI,CAAC,EAAL,GAAU,CAAhC;AACD;;AACD,MAAA,KAAK,GAAG,UAAU,GAAG,CAAC,QAAQ,GAAG,UAAZ,IAA0B,CAA/C;AACD;;AACD,WAAO,KAAP;AACD,GAvBS;;AAyBA,EAAA,QAAA,CAAA,SAAA,CAAA,cAAA,GAAV,UAAyB,KAAzB,EAAgC,MAAhC,EAAwC,CAAxC,EAA0C;AACxC,QAAM,UAAU,GAAG,KAAK,aAAL,EAAnB;AACA,QAAM,MAAM,GAAG,UAAU,CAAC,SAAX,EAAf;AACA,QAAM,CAAC,GAAG,UAAU,CAAC,SAAX,KAAyB,MAAnC;AACA,WAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACK,gBAAgB,CAAC,MAAM,CAAC,CAAR,EAAW,MAAM,CAAC,CAAlB,EAAqB,CAArB,EAAwB,KAAxB,CADrB,CAAA,EACmD;AACjD,MAAA,KAAK,EAAA,KAD4C;AAEjD,MAAA,CAAC,EAAA;AAFgD,KADnD,CAAA;AAKD,GATS;;AAUZ,SAAA,QAAA;AAAC,CAzFD,CAAsC,UAAtC,CAAA","sourcesContent":["import { get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport Geometry from '../base';\nimport { LabelItem } from './interface';\nimport PolarLabel from './polar';\n\n/**\n * 饼图 label\n */\nexport default class PieLabel extends PolarLabel {\n  public defaultLayout = 'distribute';\n\n  constructor(geometry: Geometry) {\n    super(geometry);\n  }\n\n  protected getDefaultLabelCfg() {\n    return get(this.geometry.theme, 'pieLabels', {});\n  }\n\n  protected getDefaultOffset(offset) {\n    return offset || 0;\n  }\n\n  protected getLabelRotate(angle: number, offset: number, isLabelLimit: boolean) {\n    let rotate;\n    if (offset < 0) {\n      rotate = angle;\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n\n    let align;\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n    const offset = this.getDefaultOffset(point.offset);\n    if (offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n    return align;\n  }\n\n  protected getArcPoint(point) {\n    return point;\n  }\n\n  protected getPointAngle(point) {\n    const coordinate = this.getCoordinate();\n    const startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0],\n    };\n    const endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1],\n    };\n    let angle;\n    const startAngle = getAngleByPoint(coordinate, startPoint);\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      let endAngle = getAngleByPoint(coordinate, endPoint);\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n    return angle;\n  }\n\n  protected getCirclePoint(angle, offset, p?) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    const r = coordinate.getRadius() + offset;\n    return {\n      ...polarToCartesian(center.x, center.y, r, angle),\n      angle,\n      r,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}