{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { filter, head, last, map } from '@antv/util';\nimport PieBaseLabel from './base-label';\nimport { getEndPoint } from './utils'; // 默认label和element的偏移 16px\n\nexport var DEFAULT_OFFSET = 16;\n\nvar PieOuterLabel =\n/** @class */\nfunction (_super) {\n  __extends(PieOuterLabel, _super);\n\n  function PieOuterLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /** @override 不能大于0 */\n\n\n  PieOuterLabel.prototype.adjustOption = function (options) {\n    _super.prototype.adjustOption.call(this, options);\n\n    if (options.offset < 0) {\n      options.offset = 0;\n    }\n  };\n\n  PieOuterLabel.prototype.getDefaultOptions = function () {\n    var theme = this.plot.theme;\n    var labelStyle = theme.label.style;\n    return {\n      offsetX: 0,\n      offsetY: 0,\n      offset: 12,\n      style: __assign(__assign({}, labelStyle), {\n        textBaseline: 'middle'\n      })\n    };\n  };\n  /** label 碰撞调整 */\n\n\n  PieOuterLabel.prototype.layout = function (labels, items, panel) {\n    var _this = this;\n\n    var center = this.getCoordinate().center;\n    var leftHalf = filter(labels, function (l) {\n      return l.attr('x') <= center.x;\n    });\n    var rightHalf = filter(labels, function (l) {\n      return l.attr('x') > center.x;\n    });\n    [rightHalf, leftHalf].forEach(function (half, isLeft) {\n      _this._antiCollision(half, !isLeft, panel);\n    });\n  };\n  /** labels 碰撞处理（重点算法） */\n\n\n  PieOuterLabel.prototype._antiCollision = function (labels, isRight, panelBox) {\n    var _this = this;\n\n    var labelHeight = this.getLabelHeight(labels);\n\n    var _a = this.getCoordinate(),\n        center = _a.center,\n        radius = _a.radius;\n\n    var offset = this.options.offset;\n    var totalR = radius + offset;\n    var totalHeight = Math.min(panelBox.height, Math.max(totalR * 2 + labelHeight * 2, labels.length * labelHeight));\n    var maxLabelsCount = Math.floor(totalHeight / labelHeight); // fix-bug, maxLabelsCount 之后的labels 在非 allowOverlap 不显示（避免出现尾部label展示，而前置label不展示）\n\n    if (!this.options.allowOverlap) {\n      labels.slice(maxLabelsCount).forEach(function (label) {\n        label.get('parent').set('visible', false);\n      });\n    }\n\n    labels.splice(maxLabelsCount, labels.length - maxLabelsCount); // sort by y DESC\n\n    labels.sort(function (a, b) {\n      return a.getBBox().y - b.getBBox().y;\n    }); // adjust y position of labels to avoid overlapping\n\n    var overlapping = true;\n    var i;\n    var maxY = center.y + totalHeight / 2;\n    var minY = center.y - totalHeight / 2;\n    var boxes = labels.map(function (label) {\n      var labelBox = label.getBBox();\n\n      if (labelBox.maxY > maxY) {\n        maxY = Math.min(panelBox.maxY, labelBox.maxY);\n      }\n\n      if (labelBox.minY < minY) {\n        minY = Math.max(panelBox.minY, labelBox.minY);\n      }\n\n      return {\n        text: label.attr('text'),\n        size: labelHeight,\n        pos: labelBox.y,\n        targets: []\n      };\n    });\n    var j = 0;\n\n    while (j < boxes.length) {\n      if (j === boxes.length - 1) {\n        boxes[j].targets[0] = maxY;\n      } else {\n        boxes[j].targets[0] = boxes[j + 1].pos - boxes[j + 1].size / 2;\n      }\n\n      j++;\n    }\n\n    while (overlapping) {\n      boxes.forEach(function (box) {\n        var target = last(box.targets);\n        box.pos = Math.max(minY, Math.min(box.pos, target - box.size));\n      }); // detect overlapping and join boxes\n\n      overlapping = false;\n      i = boxes.length;\n\n      while (i--) {\n        if (i > 0) {\n          var previousBox = boxes[i - 1];\n          var box = boxes[i];\n\n          if (previousBox.pos + previousBox.size > box.pos) {\n            // overlapping\n            previousBox.size += box.size;\n            previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up\n\n            var target = last(previousBox.targets);\n\n            if (previousBox.pos + previousBox.size > target) {\n              previousBox.pos = target - previousBox.size;\n            }\n\n            boxes.splice(i, 1); // removing box\n\n            overlapping = true;\n          } else {\n            // 换掉最后一个\n            previousBox.targets.splice(-1, 1, box.pos);\n          }\n        }\n      }\n    }\n\n    i = 0; // step 4: normalize y and adjust x\n\n    boxes.forEach(function (b) {\n      var posInCompositeBox = labelHeight / 2; // middle of the label\n\n      b.targets.forEach(function () {\n        labels[i].attr('y', b.pos + posInCompositeBox);\n        posInCompositeBox += labelHeight;\n        i++;\n      });\n    }); // 调整 x 位置在椭圆轨道上\n\n    var topLabels = [];\n    var bottomLabels = [];\n    labels.forEach(function (label, idx) {\n      var anchor = _this.arcPoints[idx];\n\n      if (anchor.angle >= 0 && anchor.angle <= Math.PI) {\n        bottomLabels.push(label);\n      } else {\n        topLabels.push(label);\n      }\n    });\n    [topLabels, bottomLabels].forEach(function (adjustLabels, isBottom) {\n      if (!adjustLabels.length) {\n        return;\n      }\n\n      var ry = isBottom ? last(adjustLabels).getBBox().maxY - center.y : center.y - head(adjustLabels).getBBox().minY;\n      ry = Math.max(totalR, ry);\n      var distance = offset > 4 ? 4 : 0;\n      var maxLabelWidth = Math.max.apply(0, map(labels, function (label) {\n        return label.getBBox().width;\n      })) + offset + distance;\n      var rx = Math.max(totalR, Math.min((ry + totalR) / 2, center.x - (panelBox.minX + maxLabelWidth)));\n      var rxPow2 = rx * rx;\n      var ryPow2 = ry * ry;\n      adjustLabels.forEach(function (label, idx) {\n        var anchor = _this.arcPoints[idx];\n        var box = label.getBBox();\n        var boxCenter = {\n          x: box.minX + box.width / 2,\n          y: box.minY + box.height / 2\n        };\n        var dyPow2 = Math.pow(boxCenter.y - center.y, 2);\n        var endPoint = getEndPoint(center, anchor.angle, radius);\n        var distance_offset = (isRight ? 1 : -1) * distance * 2;\n\n        if (dyPow2 > ryPow2) {\n          console.warn('异常(一般不会出现)', label.attr('text'));\n          label.attr('x', endPoint.x + distance_offset);\n        } else {\n          // (x - cx)^2 / rx ^ 2 + (y - cy)^2 / ry ^ 2 = 1\n          // 避免 label的 拉线 在 element 上\n          var xPos = center.x + (isRight ? 1 : -1) * Math.sqrt((1 - dyPow2 / ryPow2) * rxPow2);\n\n          if (center.x === endPoint.x && boxCenter.y === endPoint.y || center.y === endPoint.y && xPos === endPoint.x) {\n            xPos = endPoint.x;\n          } else {// const k1 = (center.y - endPoint.y) / (center.x - endPoint.x);\n            // const k2 = (boxCenter.y - endPoint.y) / (xPos - endPoint.x);\n            // const theta = Math.atan((k1 - k2) / (1 + k1 * k2));\n            // 切角 < 90度（目前的坐标系 无法精准计算切角）\n            // if (Math.cos(theta) > 0 && (!isRight ? xPos > endPoint.x : xPos < endPoint.x)) {\n            //   xPos = endPoint.x;\n            // }\n          }\n\n          label.attr('x', xPos + distance_offset);\n        }\n      });\n    });\n  };\n  /** 获取label height */\n\n\n  PieOuterLabel.prototype.getLabelHeight = function (labels) {\n    if (!this.options.labelHeight) {\n      return head(labels) ? head(labels).getBBox().height : 14;\n    }\n\n    return this.options.labelHeight;\n  };\n\n  return PieOuterLabel;\n}(PieBaseLabel);\n\nexport default PieOuterLabel;","map":{"version":3,"sources":["../../../../../src/plots/pie/component/label/outer-label.ts"],"names":[],"mappings":"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","sourcesContent":["import { IShape, BBox } from '../../../../dependents';\nimport { filter, head, last, map } from '@antv/util';\nimport PieBaseLabel, { LabelItem, PieLabelConfig } from './base-label';\nimport { getEndPoint } from './utils';\n\n// 默认label和element的偏移 16px\nexport const DEFAULT_OFFSET = 16;\n\nexport default class PieOuterLabel extends PieBaseLabel {\n  /** @override 不能大于0 */\n  protected adjustOption(options: PieLabelConfig) {\n    super.adjustOption(options);\n    if (options.offset < 0) {\n      options.offset = 0;\n    }\n  }\n\n  protected getDefaultOptions() {\n    const { theme } = this.plot;\n    const labelStyle = theme.label.style;\n    return {\n      offsetX: 0,\n      offsetY: 0,\n      offset: 12,\n      style: {\n        ...labelStyle,\n        textBaseline: 'middle',\n      },\n    };\n  }\n\n  /** label 碰撞调整 */\n  protected layout(labels: IShape[], items: LabelItem[], panel: BBox) {\n    const { center } = this.getCoordinate();\n    const leftHalf = filter(labels, (l) => l.attr('x') <= center.x);\n    const rightHalf = filter(labels, (l) => l.attr('x') > center.x);\n    [rightHalf, leftHalf].forEach((half, isLeft) => {\n      this._antiCollision(half, !isLeft, panel);\n    });\n  }\n\n  /** labels 碰撞处理（重点算法） */\n  private _antiCollision(labels: IShape[], isRight: boolean, panelBox: BBox) {\n    const labelHeight = this.getLabelHeight(labels);\n    const { center, radius } = this.getCoordinate();\n    const offset = this.options.offset;\n    const totalR = radius + offset;\n    const totalHeight = Math.min(panelBox.height, Math.max(totalR * 2 + labelHeight * 2, labels.length * labelHeight));\n    const maxLabelsCount = Math.floor(totalHeight / labelHeight);\n    // fix-bug, maxLabelsCount 之后的labels 在非 allowOverlap 不显示（避免出现尾部label展示，而前置label不展示）\n    if (!this.options.allowOverlap) {\n      labels.slice(maxLabelsCount).forEach((label) => {\n        label.get('parent').set('visible', false);\n      });\n    }\n    labels.splice(maxLabelsCount, labels.length - maxLabelsCount);\n\n    // sort by y DESC\n    labels.sort((a, b) => a.getBBox().y - b.getBBox().y);\n    // adjust y position of labels to avoid overlapping\n    let overlapping = true;\n    let i;\n    let maxY = center.y + totalHeight / 2;\n    let minY = center.y - totalHeight / 2;\n    const boxes = labels.map((label) => {\n      const labelBox = label.getBBox();\n      if (labelBox.maxY > maxY) {\n        maxY = Math.min(panelBox.maxY, labelBox.maxY);\n      }\n      if (labelBox.minY < minY) {\n        minY = Math.max(panelBox.minY, labelBox.minY);\n      }\n      return {\n        text: label.attr('text'),\n        size: labelHeight,\n        pos: labelBox.y,\n        targets: [],\n      };\n    });\n    let j = 0;\n    while (j < boxes.length) {\n      if (j === boxes.length - 1) {\n        boxes[j].targets[0] = maxY;\n      } else {\n        boxes[j].targets[0] = boxes[j + 1].pos - boxes[j + 1].size / 2;\n      }\n      j++;\n    }\n    while (overlapping) {\n      boxes.forEach((box) => {\n        const target = last(box.targets);\n        box.pos = Math.max(minY, Math.min(box.pos, target - box.size));\n      });\n      // detect overlapping and join boxes\n      overlapping = false;\n      i = boxes.length;\n      while (i--) {\n        if (i > 0) {\n          const previousBox = boxes[i - 1];\n          const box = boxes[i];\n          if (previousBox.pos + previousBox.size > box.pos) {\n            // overlapping\n            previousBox.size += box.size;\n            previousBox.targets = previousBox.targets.concat(box.targets);\n            // overflow, shift up\n            const target = last(previousBox.targets);\n            if (previousBox.pos + previousBox.size > target) {\n              previousBox.pos = target - previousBox.size;\n            }\n            boxes.splice(i, 1); // removing box\n            overlapping = true;\n          } else {\n            // 换掉最后一个\n            previousBox.targets.splice(-1, 1, box.pos);\n          }\n        }\n      }\n    }\n\n    i = 0;\n    // step 4: normalize y and adjust x\n    boxes.forEach((b) => {\n      let posInCompositeBox = labelHeight / 2; // middle of the label\n      b.targets.forEach(() => {\n        labels[i].attr('y', b.pos + posInCompositeBox);\n        posInCompositeBox += labelHeight;\n        i++;\n      });\n    });\n\n    // 调整 x 位置在椭圆轨道上\n    const topLabels = [];\n    const bottomLabels = [];\n    labels.forEach((label, idx) => {\n      const anchor = this.arcPoints[idx];\n      if (anchor.angle >= 0 && anchor.angle <= Math.PI) {\n        bottomLabels.push(label);\n      } else {\n        topLabels.push(label);\n      }\n    });\n    [topLabels, bottomLabels].forEach((adjustLabels, isBottom) => {\n      if (!adjustLabels.length) {\n        return;\n      }\n      let ry = isBottom ? last(adjustLabels).getBBox().maxY - center.y : center.y - head(adjustLabels).getBBox().minY;\n      ry = Math.max(totalR, ry);\n      const distance = offset > 4 ? 4 : 0;\n      const maxLabelWidth =\n        Math.max.apply(\n          0,\n          map(labels, (label) => label.getBBox().width)\n        ) +\n        offset +\n        distance;\n      const rx = Math.max(totalR, Math.min((ry + totalR) / 2, center.x - (panelBox.minX + maxLabelWidth)));\n      const rxPow2 = rx * rx;\n      const ryPow2 = ry * ry;\n      adjustLabels.forEach((label, idx) => {\n        const anchor = this.arcPoints[idx];\n        const box = label.getBBox();\n        const boxCenter = { x: box.minX + box.width / 2, y: box.minY + box.height / 2 };\n        const dyPow2 = Math.pow(boxCenter.y - center.y, 2);\n        const endPoint = getEndPoint(center, anchor.angle, radius);\n        const distance_offset = (isRight ? 1 : -1) * distance * 2;\n        if (dyPow2 > ryPow2) {\n          console.warn('异常(一般不会出现)', label.attr('text'));\n          label.attr('x', endPoint.x + distance_offset);\n        } else {\n          // (x - cx)^2 / rx ^ 2 + (y - cy)^2 / ry ^ 2 = 1\n          // 避免 label的 拉线 在 element 上\n          let xPos = center.x + (isRight ? 1 : -1) * Math.sqrt((1 - dyPow2 / ryPow2) * rxPow2);\n          if (\n            (center.x === endPoint.x && boxCenter.y === endPoint.y) ||\n            (center.y === endPoint.y && xPos === endPoint.x)\n          ) {\n            xPos = endPoint.x;\n          } else {\n            // const k1 = (center.y - endPoint.y) / (center.x - endPoint.x);\n            // const k2 = (boxCenter.y - endPoint.y) / (xPos - endPoint.x);\n            // const theta = Math.atan((k1 - k2) / (1 + k1 * k2));\n            // 切角 < 90度（目前的坐标系 无法精准计算切角）\n            // if (Math.cos(theta) > 0 && (!isRight ? xPos > endPoint.x : xPos < endPoint.x)) {\n            //   xPos = endPoint.x;\n            // }\n          }\n          label.attr('x', xPos + distance_offset);\n        }\n      });\n    });\n  }\n\n  /** 获取label height */\n  private getLabelHeight(labels: IShape[]): number {\n    if (!this.options.labelHeight) {\n      return head(labels) ? head(labels).getBBox().height : 14;\n    }\n    return this.options.labelHeight;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}