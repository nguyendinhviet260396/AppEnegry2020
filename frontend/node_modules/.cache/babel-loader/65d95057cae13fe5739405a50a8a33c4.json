{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { deepMix, clone, each, isString, mix } from '@antv/util';\nimport { percentageField } from '../../layer';\nvar ANCHOR_OFFSET = 0; // 锚点偏移量\n\nvar INFLECTION_OFFSET = 15; // 拐点偏移量\n\nvar DEFAULT_COLOR = '#CCC';\nvar LABEL1_OFFSETY = 2;\nvar LABEL2_OFFSETY = -2;\nvar ADJUSTOFFSET = 15;\n\nfunction getEndPoint(center, angle, r) {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle)\n  };\n}\n\nvar SpiderLabel =\n/** @class */\nfunction () {\n  function SpiderLabel(cfg) {\n    this.destroyed = false;\n    this.view = cfg.view;\n    this.options = deepMix({}, this.getDefaultOptions(), cfg);\n\n    this._adjustOptions(this.options);\n\n    this.init();\n  }\n\n  SpiderLabel.prototype.init = function () {\n    var _this = this;\n\n    this.container = this.view.geometries[0].labelsContainer;\n    this.view.on('beforerender', function () {\n      _this.clear();\n    });\n  };\n\n  SpiderLabel.prototype.render = function () {\n    var _this = this;\n\n    if (!this.view || this.view.destroyed) {\n      return;\n    }\n    /** 如果有formatter则事先处理数据 */\n\n\n    var data = clone(this.view.getData());\n    this.halves = [[], []];\n    var shapes = [];\n    var elements = this.view.geometries[0].elements;\n    each(elements, function (ele) {\n      shapes.push(ele.shape);\n    });\n    this.coord = this.view.geometries[0].coordinate;\n    var _a = this.options,\n        allZero = _a.allZero,\n        trueAngleField = _a.angleField;\n    var angleField = this.options.fields[0];\n    var scale = this.view.getScalesByDim('y')[angleField];\n    var center = this.coord.getCenter();\n    var startAngle = this.coord.startAngle;\n    var radius = this.coord.polarRadius;\n    var _b = this.view.coordinateBBox,\n        width = _b.width,\n        height = _b.height;\n    this.width = width;\n    this.height = height;\n    var angle = startAngle;\n\n    var _loop_1 = function _loop_1(idx) {\n      var d = data[idx]; // 计算每个切片的middle angle\n\n      var angleValue = scale.scale(d[angleField]);\n      var targetAngle = angle + Math.PI * 2 * angleValue;\n      var middleAngle = angle + (targetAngle - angle) / 2;\n      angle = targetAngle; // 根据middle angle计算锚点和拐点距离\n\n      var anchorPoint = getEndPoint(center, middleAngle, radius + ANCHOR_OFFSET);\n      var inflectionPoint = getEndPoint(center, middleAngle, radius + INFLECTION_OFFSET); // 获取对应shape的color\n\n      var color = DEFAULT_COLOR;\n\n      if (this_1.options.fields.length === 2) {\n        var colorField = this_1.options.fields[1];\n        var colorScale = this_1.view.geometries[0].scales[colorField];\n        var colorIndex = colorScale.scale(d[colorField]);\n\n        if (colorIndex) {\n          var shapeIndex = Math.floor(colorIndex * (shapes.length - 1));\n          color = shapes[shapeIndex].attr('fill');\n        }\n      } // 组装label数据\n\n\n      var label = {\n        _anchor: anchorPoint,\n        _inflection: inflectionPoint,\n        _data: d,\n        x: inflectionPoint.x,\n        y: inflectionPoint.y,\n        r: radius + INFLECTION_OFFSET,\n        fill: color,\n        textGroup: null,\n        _side: null\n      }; // 创建label文本\n\n      var texts = [];\n      each(this_1.options.fields, function (f) {\n        if (allZero && f === percentageField) {\n          texts.push(d[trueAngleField]);\n        } else {\n          texts.push(d[f]);\n        }\n      });\n\n      if (this_1.options.formatter) {\n        var formatted = this_1.options.formatter(d[trueAngleField], {\n          _origin: d,\n          color: color\n        }, idx);\n\n        if (isString(formatted)) {\n          formatted = [formatted];\n        }\n\n        texts = formatted;\n      }\n\n      var textGroup = this_1.container.addGroup({\n        capture: false,\n        visible: false\n      });\n      var textAttrs = {\n        x: 0,\n        y: 0,\n        fontSize: this_1.options.text.fontSize,\n        lineHeight: this_1.options.text.fontSize,\n        fontWeight: this_1.options.text.fontWeight,\n        fill: this_1.options.text.fill\n      }; // label1:下部label\n\n      var lowerText = d[trueAngleField];\n\n      if (this_1.options.formatter) {\n        lowerText = texts[0];\n      }\n\n      var lowerTextAttrs = clone(textAttrs);\n\n      if (texts.length === 2) {\n        lowerTextAttrs.fontWeight = 700;\n      }\n\n      var lowerTextShape = textGroup.addShape('text', {\n        attrs: mix({\n          textBaseline: texts.length === 2 ? 'top' : 'middle',\n          text: lowerText\n        }, lowerTextAttrs),\n        data: d,\n        offsetY: texts.length === 2 ? LABEL1_OFFSETY : 0,\n        name: 'label'\n      });\n      lowerTextShape.name = 'label'; // 用于事件标记 shapeName\n\n      /** label2:上部label */\n\n      if (texts.length === 2) {\n        var topTextShape = textGroup.addShape('text', {\n          attrs: mix({\n            textBaseline: 'bottom',\n            text: texts[1]\n          }, textAttrs),\n          data: d,\n          offsetY: LABEL2_OFFSETY,\n          name: 'label'\n        });\n        topTextShape.name = 'label'; // 用于事件标记 shapeName\n      }\n\n      label.textGroup = textGroup;\n      /** 将label分组 */\n\n      if (anchorPoint.x < center.x) {\n        label._side = 'left';\n        this_1.halves[0].push(label);\n      } else {\n        label._side = 'right';\n        this_1.halves[1].push(label);\n      }\n    };\n\n    var this_1 = this; // tslint:disable-next-line: prefer-for-of\n\n    for (var idx = 0; idx < data.length; idx++) {\n      _loop_1(idx);\n    }\n    /** 绘制label */\n\n\n    var maxCountForOneSide = Math.floor(height / this.options.lineHeight);\n    each(this.halves, function (half) {\n      if (half.length > maxCountForOneSide) {\n        half.splice(maxCountForOneSide, half.length - maxCountForOneSide);\n      }\n\n      half.sort(function (a, b) {\n        return a.y - b.y;\n      });\n\n      _this._antiCollision(half);\n    });\n    this.view.canvas.draw();\n  };\n\n  SpiderLabel.prototype.clear = function () {\n    if (this.container) {\n      this.container.clear();\n    }\n  };\n\n  SpiderLabel.prototype.hide = function () {\n    this.container.set('visible', false);\n    this.view.canvas.draw();\n  };\n\n  SpiderLabel.prototype.show = function () {\n    this.container.set('visible', true);\n    this.view.canvas.draw();\n  };\n\n  SpiderLabel.prototype.destroy = function () {\n    if (this.container) {\n      this.container.remove();\n    }\n\n    this.destroyed = true;\n  };\n\n  SpiderLabel.prototype.getDefaultOptions = function () {\n    return {\n      text: {\n        fill: 'rgba(0, 0, 0, 0.65)',\n        fontSize: 12\n      },\n      line: {\n        lineWidth: 0.5,\n        stroke: 'rgba(0, 0, 0, 0.45)'\n      },\n      lineHeight: 32,\n\n      /** distance between label and edge */\n      sidePadding: 20\n    };\n  };\n\n  SpiderLabel.prototype._antiCollision = function (half) {\n    var _this = this;\n\n    var coord = this.coord;\n    var canvasHeight = coord.getHeight();\n    var center = coord.center;\n    var radius = coord.getRadius();\n    var startY = center.y - radius - INFLECTION_OFFSET - this.options.lineHeight;\n    var overlapping = true;\n    var totalH = canvasHeight;\n    var i;\n    var maxY = 0;\n    var minY = Number.MIN_VALUE;\n    var maxLabelWidth = 0;\n    var boxes = half.map(function (label) {\n      var labelY = label.y;\n\n      if (labelY > maxY) {\n        maxY = labelY;\n      }\n\n      if (labelY < minY) {\n        minY = labelY;\n      }\n\n      var textGroup = label.textGroup;\n      var labelWidth = textGroup.getBBox().width;\n\n      if (labelWidth >= maxLabelWidth) {\n        maxLabelWidth = labelWidth;\n      }\n\n      return {\n        size: _this.options.lineHeight,\n        targets: [labelY - startY]\n      };\n    });\n\n    if (maxY - startY > totalH) {\n      totalH = maxY - startY;\n    }\n\n    var iteratorBoxed = function iteratorBoxed(items) {\n      items.forEach(function (box) {\n        var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n        box.pos = Math.min(Math.max(minY, target - box.size / 2), totalH - box.size);\n      });\n    };\n\n    while (overlapping) {\n      iteratorBoxed(boxes); // detect overlapping and join boxes\n\n      overlapping = false;\n      i = boxes.length;\n\n      while (i--) {\n        if (i > 0) {\n          var previousBox = boxes[i - 1];\n          var box = boxes[i];\n\n          if (previousBox.pos + previousBox.size > box.pos) {\n            // overlapping\n            previousBox.size += box.size;\n            previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up\n\n            if (previousBox.pos + previousBox.size > totalH) {\n              previousBox.pos = totalH - previousBox.size;\n            }\n\n            boxes.splice(i, 1); // removing box\n\n            overlapping = true;\n          }\n        }\n      }\n    }\n\n    i = 0;\n    boxes.forEach(function (b) {\n      var posInCompositeBox = startY; // middle of the label\n\n      b.targets.forEach(function () {\n        half[i].y = b.pos + posInCompositeBox + _this.options.lineHeight / 2;\n        posInCompositeBox += _this.options.lineHeight;\n        i++;\n      });\n    });\n    var drawnLabels = [];\n    half.forEach(function (label) {\n      var textGroup = _this._drawLabel(label);\n\n      _this._drawLabelLine(label, maxLabelWidth, textGroup);\n\n      drawnLabels.push(textGroup);\n    });\n  };\n\n  SpiderLabel.prototype._drawLabel = function (label) {\n    var coord = this.coord;\n    var center = coord.getCenter();\n    var radius = coord.getRadius();\n    var y = label.y,\n        textGroup = label.textGroup;\n    var children = textGroup.get('children');\n    var x_dir = label._side === 'left' ? 1 : -1;\n\n    var textAttrs = __assign({\n      textAlign: label._side === 'left' ? 'right' : 'left',\n      x: label._side === 'left' ? center.x - radius - this.options.sidePadding : center.x + radius + this.options.sidePadding\n    }, this.options.style);\n\n    if (this.options.offsetX) {\n      textAttrs.x += this.options.offsetX * x_dir;\n    }\n\n    children.forEach(function (child) {\n      var offsetY = child.get('offsetY');\n      var yPosition = y + offsetY;\n      child.attr(textAttrs);\n      child.attr('y', yPosition);\n    });\n    textGroup.show();\n    return textGroup;\n  };\n\n  SpiderLabel.prototype._drawLabelLine = function (label, maxLabelWidth, container) {\n    var _anchor = [label._anchor.x, label._anchor.y];\n    var _inflection = [label._inflection.x, label._inflection.y];\n    var y = label.y,\n        textGroup = label.textGroup;\n    if (!textGroup) return;\n    var lastPoint = [label._side === 'left' ? textGroup.getBBox().maxX + 4 : textGroup.getBBox().minX - 4, y];\n    var points = [_anchor, _inflection, lastPoint];\n\n    if (_inflection[1] !== y) {\n      // 展示全部文本文本位置做过调整\n      if (_inflection[1] < this.height / 2 && _inflection[1] < y || _inflection[1] >= this.height / 2 && _inflection[1] > y) {\n        // 文本被调整下去了，则添加拐点连接线\n        var point1 = _inflection;\n        var leftPoint = lastPoint[0] + ADJUSTOFFSET;\n        var rightPoint = lastPoint[0] - ADJUSTOFFSET;\n        var point2 = [label._side === 'left' ? leftPoint : rightPoint, _inflection[1]];\n        points = [_anchor, point1, point2, lastPoint];\n\n        if (label._side === 'right' && point2[0] < point1[0] || label._side === 'left' && point2[0] > point1[0]) {\n          points = [_anchor, point1, lastPoint];\n        }\n      } else {\n        points = [_anchor, [_inflection[0], y], lastPoint];\n      }\n    }\n\n    var path = [];\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var starter = 'L';\n\n      if (i === 0) {\n        starter = 'M';\n      }\n\n      path.push([starter, p[0], p[1]]);\n    }\n\n    container.addShape('path', {\n      attrs: {\n        path: path,\n        lineWidth: this.options.line.lineWidth,\n        stroke: this.options.line.stroke\n      }\n    }); // 绘制锚点\n    // container.addShape('circle', {\n    //   attrs: {\n    //     x: _anchor[0],\n    //     y: _anchor[1],\n    //     r: this.config.anchorSize,\n    //     fill,\n    //   },\n    // });\n  };\n\n  SpiderLabel.prototype._adjustOptions = function (config) {\n    if (config.text.fontSize) {\n      config.lineHeight = config.text.fontSize * 3;\n    }\n  };\n\n  return SpiderLabel;\n}();\n\nexport default SpiderLabel;","map":{"version":3,"sources":["../../../../../src/plots/pie/component/label/spider-label.ts"],"names":[],"mappings":"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","sourcesContent":["import { View, IGroup, IShape } from '../../../../dependents';\nimport { deepMix, clone, each, isString, mix } from '@antv/util';\nimport { LooseMap } from '../../../../interface/types';\nimport { percentageField } from '../../layer';\n\nconst ANCHOR_OFFSET = 0; // 锚点偏移量\nconst INFLECTION_OFFSET = 15; // 拐点偏移量\nconst DEFAULT_COLOR = '#CCC';\nconst LABEL1_OFFSETY = 2;\nconst LABEL2_OFFSETY = -2;\nconst ADJUSTOFFSET = 15;\n\ntype IAttrs = LooseMap;\n\ntype Point = { x: number; y: number };\ninterface LabelData {\n  _anchor: Point;\n  _inflection: Point;\n  _data: object;\n  x: number;\n  y: number;\n  r: number;\n  fill: string;\n  textGroup: IGroup;\n  _side?: 'left' | 'right';\n}\n\ninterface SpiderLabelConfig {\n  line?: any;\n  text?: any;\n  formatter?: (text: string, item: OriginLabelItem, index: number) => string | string[];\n  offsetX?: number;\n  offsetY?: number;\n  [field: string]: any;\n}\n\ninterface ISpiderLabel extends SpiderLabelConfig {\n  view: View;\n  fields: string[];\n  allZero: boolean;\n  angleField: string;\n}\n\nfunction getEndPoint(center, angle, r) {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle),\n  };\n}\n\ninterface OriginLabelItem {\n  /** 原始数据值 */\n  _origin: object;\n  color?: string;\n}\n\nexport default class SpiderLabel {\n  public destroyed: boolean = false;\n  private view: View;\n  private options: ISpiderLabel;\n  private halves: any[][];\n  private container: IGroup;\n  private width: number;\n  private height: number;\n  private coord: any;\n\n  constructor(cfg: ISpiderLabel) {\n    this.view = cfg.view;\n    this.options = deepMix({}, this.getDefaultOptions(), cfg);\n    this._adjustOptions(this.options);\n    this.init();\n  }\n\n  private init() {\n    this.container = this.view.geometries[0].labelsContainer;\n    this.view.on('beforerender', () => {\n      this.clear();\n    });\n  }\n\n  public render() {\n    if (!this.view || this.view.destroyed) {\n      return;\n    }\n    /** 如果有formatter则事先处理数据 */\n    const data = clone(this.view.getData());\n    this.halves = [[], []];\n    const shapes = [];\n    const elements = this.view.geometries[0].elements;\n    each(elements, (ele) => {\n      shapes.push(ele.shape);\n    });\n    this.coord = this.view.geometries[0].coordinate;\n    const { allZero, angleField: trueAngleField } = this.options;\n    const angleField = this.options.fields[0];\n    const scale = this.view.getScalesByDim('y')[angleField];\n    const center = this.coord.getCenter();\n    const { startAngle } = this.coord;\n    const radius = this.coord.polarRadius;\n    const { width, height } = this.view.coordinateBBox;\n    this.width = width;\n    this.height = height;\n    let angle = startAngle;\n    // tslint:disable-next-line: prefer-for-of\n    for (let idx = 0; idx < data.length; idx++) {\n      const d = data[idx];\n      // 计算每个切片的middle angle\n      const angleValue = scale.scale(d[angleField]);\n      const targetAngle = angle + Math.PI * 2 * angleValue;\n      const middleAngle = angle + (targetAngle - angle) / 2;\n      angle = targetAngle;\n      // 根据middle angle计算锚点和拐点距离\n      const anchorPoint = getEndPoint(center, middleAngle, radius + ANCHOR_OFFSET);\n      const inflectionPoint = getEndPoint(center, middleAngle, radius + INFLECTION_OFFSET);\n      // 获取对应shape的color\n      let color = DEFAULT_COLOR;\n      if (this.options.fields.length === 2) {\n        const colorField = this.options.fields[1];\n        const colorScale = this.view.geometries[0].scales[colorField];\n        const colorIndex = colorScale.scale(d[colorField]);\n        if (colorIndex) {\n          const shapeIndex = Math.floor(colorIndex * (shapes.length - 1));\n          color = shapes[shapeIndex].attr('fill');\n        }\n      }\n      // 组装label数据\n      const label: LabelData = {\n        _anchor: anchorPoint,\n        _inflection: inflectionPoint,\n        _data: d,\n        x: inflectionPoint.x,\n        y: inflectionPoint.y,\n        r: radius + INFLECTION_OFFSET,\n        fill: color,\n        textGroup: null,\n        _side: null,\n      };\n      // 创建label文本\n      let texts = [];\n      each(this.options.fields, (f) => {\n        if (allZero && f === percentageField) {\n          texts.push(d[trueAngleField]);\n        } else {\n          texts.push(d[f]);\n        }\n      });\n      if (this.options.formatter) {\n        let formatted: any = this.options.formatter(d[trueAngleField], { _origin: d, color }, idx);\n        if (isString(formatted)) {\n          formatted = [formatted];\n        }\n        texts = formatted;\n      }\n      const textGroup = this.container.addGroup({\n        capture: false, // 不捕获事件，否则鼠标 hover 到图形会失焦\n        visible: false, // 因为后续会将部分 label 删除，所以这里需要先隐藏，避免调整完后不该绘制的 label 显示在画布上\n      });\n      const textAttrs: IAttrs = {\n        x: 0,\n        y: 0,\n        fontSize: this.options.text.fontSize,\n        lineHeight: this.options.text.fontSize,\n        fontWeight: this.options.text.fontWeight,\n        fill: this.options.text.fill,\n      };\n      // label1:下部label\n      let lowerText = d[trueAngleField];\n      if (this.options.formatter) {\n        lowerText = texts[0];\n      }\n      const lowerTextAttrs = clone(textAttrs);\n      if (texts.length === 2) {\n        lowerTextAttrs.fontWeight = 700;\n      }\n      const lowerTextShape: any = textGroup.addShape('text', {\n        attrs: mix(\n          {\n            textBaseline: texts.length === 2 ? 'top' : 'middle',\n            text: lowerText,\n          },\n          lowerTextAttrs\n        ),\n        data: d,\n        offsetY: texts.length === 2 ? LABEL1_OFFSETY : 0,\n        name: 'label',\n      });\n      lowerTextShape.name = 'label'; // 用于事件标记 shapeName\n      /** label2:上部label */\n      if (texts.length === 2) {\n        const topTextShape: any = textGroup.addShape('text', {\n          attrs: mix(\n            {\n              textBaseline: 'bottom',\n              text: texts[1],\n            },\n            textAttrs\n          ),\n          data: d,\n          offsetY: LABEL2_OFFSETY,\n          name: 'label',\n        });\n        topTextShape.name = 'label'; // 用于事件标记 shapeName\n      }\n\n      label.textGroup = textGroup;\n\n      /** 将label分组 */\n      if (anchorPoint.x < center.x) {\n        label._side = 'left';\n        this.halves[0].push(label);\n      } else {\n        label._side = 'right';\n        this.halves[1].push(label);\n      }\n    }\n\n    /** 绘制label */\n    const maxCountForOneSide = Math.floor(height / this.options.lineHeight);\n\n    each(this.halves, (half) => {\n      if (half.length > maxCountForOneSide) {\n        half.splice(maxCountForOneSide, half.length - maxCountForOneSide);\n      }\n\n      half.sort((a, b) => {\n        return a.y - b.y;\n      });\n\n      this._antiCollision(half);\n    });\n    this.view.canvas.draw();\n  }\n\n  public clear() {\n    if (this.container) {\n      this.container.clear();\n    }\n  }\n\n  public hide() {\n    this.container.set('visible', false);\n    this.view.canvas.draw();\n  }\n\n  public show() {\n    this.container.set('visible', true);\n    this.view.canvas.draw();\n  }\n\n  public destroy() {\n    if (this.container) {\n      this.container.remove();\n    }\n    this.destroyed = true;\n  }\n\n  protected getDefaultOptions() {\n    return {\n      text: {\n        fill: 'rgba(0, 0, 0, 0.65)',\n        fontSize: 12,\n      },\n      line: {\n        lineWidth: 0.5,\n        stroke: 'rgba(0, 0, 0, 0.45)',\n      },\n      lineHeight: 32,\n      /** distance between label and edge */\n      sidePadding: 20,\n      // anchorSize: 2,\n    };\n  }\n\n  private _antiCollision(half: LabelData[]) {\n    const { coord } = this;\n    const canvasHeight = coord.getHeight();\n    const { center } = coord;\n    const radius = coord.getRadius();\n    const startY = center.y - radius - INFLECTION_OFFSET - this.options.lineHeight;\n    let overlapping = true;\n    let totalH = canvasHeight;\n    let i;\n\n    let maxY = 0;\n    let minY = Number.MIN_VALUE;\n    let maxLabelWidth = 0;\n    const boxes: any[] = half.map((label) => {\n      const labelY = label.y;\n      if (labelY > maxY) {\n        maxY = labelY;\n      }\n      if (labelY < minY) {\n        minY = labelY;\n      }\n\n      const textGroup = label.textGroup;\n      const labelWidth = textGroup.getBBox().width;\n      if (labelWidth >= maxLabelWidth) {\n        maxLabelWidth = labelWidth;\n      }\n\n      return {\n        size: this.options.lineHeight,\n        targets: [labelY - startY],\n      };\n    });\n    if (maxY - startY > totalH) {\n      totalH = maxY - startY;\n    }\n\n    const iteratorBoxed = function (items) {\n      items.forEach((box) => {\n        const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n        box.pos = Math.min(Math.max(minY, target - box.size / 2), totalH - box.size);\n      });\n    };\n\n    while (overlapping) {\n      iteratorBoxed(boxes);\n      // detect overlapping and join boxes\n      overlapping = false;\n      i = boxes.length;\n      while (i--) {\n        if (i > 0) {\n          const previousBox = boxes[i - 1];\n          const box = boxes[i];\n          if (previousBox.pos + previousBox.size > box.pos) {\n            // overlapping\n            previousBox.size += box.size;\n            previousBox.targets = previousBox.targets.concat(box.targets);\n\n            // overflow, shift up\n            if (previousBox.pos + previousBox.size > totalH) {\n              previousBox.pos = totalH - previousBox.size;\n            }\n            boxes.splice(i, 1); // removing box\n            overlapping = true;\n          }\n        }\n      }\n    }\n\n    i = 0;\n    boxes.forEach((b) => {\n      let posInCompositeBox = startY; // middle of the label\n      b.targets.forEach(() => {\n        half[i].y = b.pos + posInCompositeBox + this.options.lineHeight / 2;\n        posInCompositeBox += this.options.lineHeight;\n        i++;\n      });\n    });\n\n    const drawnLabels = [];\n    half.forEach((label) => {\n      const textGroup = this._drawLabel(label);\n      this._drawLabelLine(label, maxLabelWidth, textGroup);\n      drawnLabels.push(textGroup);\n    });\n  }\n\n  private _drawLabel(label: LabelData) {\n    const { coord } = this;\n    const center = coord.getCenter();\n    const radius = coord.getRadius();\n\n    const { y, textGroup } = label;\n    const children = textGroup.get('children');\n    const x_dir = label._side === 'left' ? 1 : -1;\n\n    const textAttrs = {\n      textAlign: label._side === 'left' ? 'right' : 'left',\n      x:\n        label._side === 'left'\n          ? center.x - radius - this.options.sidePadding\n          : center.x + radius + this.options.sidePadding,\n      ...this.options.style,\n    };\n\n    if (this.options.offsetX) {\n      textAttrs.x += this.options.offsetX * x_dir;\n    }\n\n    children.forEach((child) => {\n      const offsetY = child.get('offsetY');\n      const yPosition = y + offsetY;\n      child.attr(textAttrs);\n      child.attr('y', yPosition);\n    });\n\n    textGroup.show();\n    return textGroup;\n  }\n\n  private _drawLabelLine(label: LabelData, maxLabelWidth, container: IGroup): IShape {\n    const _anchor = [label._anchor.x, label._anchor.y];\n    const _inflection = [label._inflection.x, label._inflection.y];\n    const { y, textGroup } = label;\n    if (!textGroup) return;\n    const lastPoint = [label._side === 'left' ? textGroup.getBBox().maxX + 4 : textGroup.getBBox().minX - 4, y];\n\n    let points = [_anchor, _inflection, lastPoint];\n    if (_inflection[1] !== y) {\n      // 展示全部文本文本位置做过调整\n      if (\n        (_inflection[1] < this.height / 2 && _inflection[1] < y) ||\n        (_inflection[1] >= this.height / 2 && _inflection[1] > y)\n      ) {\n        // 文本被调整下去了，则添加拐点连接线\n        const point1 = _inflection;\n        const leftPoint = lastPoint[0] + ADJUSTOFFSET;\n        const rightPoint = lastPoint[0] - ADJUSTOFFSET;\n        const point2 = [label._side === 'left' ? leftPoint : rightPoint, _inflection[1]];\n\n        points = [_anchor, point1, point2, lastPoint];\n        if ((label._side === 'right' && point2[0] < point1[0]) || (label._side === 'left' && point2[0] > point1[0])) {\n          points = [_anchor, point1, lastPoint];\n        }\n      } else {\n        points = [_anchor, [_inflection[0], y], lastPoint];\n      }\n    }\n\n    const path = [];\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i];\n      let starter = 'L';\n      if (i === 0) {\n        starter = 'M';\n      }\n      path.push([starter, p[0], p[1]]);\n    }\n    container.addShape('path', {\n      attrs: {\n        path,\n        lineWidth: this.options.line.lineWidth,\n        stroke: this.options.line.stroke,\n      },\n    });\n\n    // 绘制锚点\n    // container.addShape('circle', {\n    //   attrs: {\n    //     x: _anchor[0],\n    //     y: _anchor[1],\n    //     r: this.config.anchorSize,\n    //     fill,\n    //   },\n    // });\n  }\n\n  private _adjustOptions(config) {\n    if (config.text.fontSize) {\n      config.lineHeight = config.text.fontSize * 3;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}