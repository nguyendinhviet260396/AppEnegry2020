{"ast":null,"code":"/**\n * @description path 计算、转换的辅助工具\n */\nimport { vec2 as vector2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\n\nfunction _points2path(points, isInCircle) {\n  var path = [];\n\n  if (points.length) {\n    for (var i = 0, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      var command = i === 0 ? 'M' : 'L';\n      path.push([command, item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _getPointRadius(coord, point) {\n  var center = coord.getCenter();\n  var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n  return r;\n}\n\nfunction _convertArr(arr, coord) {\n  var tmp = [arr[0]];\n\n  for (var i = 1, len = arr.length; i < len; i = i + 2) {\n    var point = coord.convertPoint({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n\n  return tmp;\n}\n\nfunction _convertPolarPath(pre, cur, coord) {\n  var isTransposed = coord.isTransposed,\n      startAngle = coord.startAngle,\n      endAngle = coord.endAngle;\n  var prePoint = {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = [];\n  var xDim = isTransposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n\n  var convertPoint = coord.convertPoint(curPoint);\n\n  var r = _getPointRadius(coord, convertPoint);\n\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convertPoint(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n\n  return rst;\n} // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\n\n\nfunction _filterFullCirleLine(path) {\n  each(path, function (subPath, index) {\n    var cur = subPath;\n\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n  var cps = [];\n  var prevPoint;\n  var nextPoint;\n  var hasConstraint = !!constraint;\n  var min;\n  var max;\n\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vector2.min([0, 0], min, point);\n      max = vector2.max([0, 0], max, point);\n    }\n\n    min = vector2.min([0, 0], min, constraint[0]);\n    max = vector2.max([0, 0], max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    var v = [0, 0];\n    v = vector2.sub(v, nextPoint, prevPoint);\n    v = vector2.scale(v, v, smooth);\n    var d0 = vector2.distance(point, prevPoint);\n    var d1 = vector2.distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    var v1 = vector2.scale([0, 0], v, -d0);\n    var v2 = vector2.scale([0, 0], v, d1);\n    var cp0 = vector2.add([0, 0], point, v1);\n    var cp1 = vector2.add([0, 0], point, v2);\n\n    if (hasConstraint) {\n      cp0 = vector2.max([0, 0], cp0, min);\n      cp0 = vector2.min([0, 0], cp0, max);\n      cp1 = vector2.max([0, 0], cp1, min);\n      cp1 = vector2.min([0, 0], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}; // 贝塞尔曲线\n\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  return d1;\n} // 将点连接成路径 path\n\nexport function getLinePath(points, isInCircle) {\n  return _points2path(points, isInCircle);\n} // get spline： 限定了范围的平滑线\n\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n\n  each(points, function (point) {\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  });\n  var constraint = constaint || [// 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n} // 获取点到圆心的距离\n\nexport function getPointRadius(coord, point) {\n  return _getPointRadius(coord, point);\n} // 获取点到圆心的夹角\n\nexport function getPointAngle(coord, point) {\n  var center = coord.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\nexport function convertNormalPath(coord, path) {\n  var tmp = [];\n  each(path, function (subPath) {\n    var action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\nexport function convertPolarPath(coord, path) {\n  var tmp = [];\n  var pre;\n  var cur;\n  var transposed;\n  var equals;\n  each(path, function (subPath, index) {\n    var action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed; // 是否半径相同，转换成圆弧\n\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n\n        break;\n\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n\n\n  return tmp;\n}","map":{"version":3,"sources":["../../src/util/path.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @description path 计算、转换的辅助工具\n */\n\nimport { vec2 as vector2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\n\ninterface PointObject {\n  x: number;\n  y: number;\n}\n\ntype PointArray = [number, number];\n\nfunction _points2path(points: PointObject[], isInCircle: boolean): any[] {\n  const path = [];\n  if (points.length) {\n    for (let i = 0, length = points.length; i < length; i += 1) {\n      const item = points[i];\n      const command = i === 0 ? 'M' : 'L';\n      path.push([command, item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _getPointRadius(coord, point: PointObject): number {\n  const center = coord.getCenter();\n  const r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n  return r;\n}\n\nfunction _convertArr(arr: number[], coord): any[] {\n  const tmp = [arr[0]];\n  for (let i = 1, len = arr.length; i < len; i = i + 2) {\n    const point = coord.convertPoint({\n      x: arr[i],\n      y: arr[i + 1],\n    });\n    tmp.push(point.x, point.y);\n  }\n  return tmp;\n}\n\nfunction _convertPolarPath(pre: any[], cur: any[], coord): any[] {\n  const { isTransposed, startAngle, endAngle } = coord;\n\n  const prePoint = {\n    x: pre[1],\n    y: pre[2],\n  };\n  const curPoint = {\n    x: cur[1],\n    y: cur[2],\n  };\n  const rst = [];\n  const xDim = isTransposed ? 'y' : 'x';\n  const angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  const direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n  const flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n  const convertPoint = coord.convertPoint(curPoint);\n  const r = _getPointRadius(coord, convertPoint);\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      const middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2,\n      };\n      const middleConvertPoint = coord.convertPoint(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n  return rst;\n}\n\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path: any[]): void {\n  each(path, (subPath, index) => {\n    const cur = subPath;\n    if (cur[0].toLowerCase() === 'a') {\n      const pre = path[index - 1];\n      const next = path[index + 1];\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\nexport const smoothBezier = (\n  points: PointArray[],\n  smooth: number,\n  isLoop: boolean,\n  constraint: PointArray[]\n): PointArray[] => {\n  const cps = [];\n\n  let prevPoint: PointArray;\n  let nextPoint: PointArray;\n  const hasConstraint = !!constraint;\n  let min: PointArray;\n  let max: PointArray;\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      min = vector2.min([0, 0], min, point) as [number, number];\n      max = vector2.max([0, 0], max, point) as [number, number];\n    }\n    min = vector2.min([0, 0], min, constraint[0]) as [number, number];\n    max = vector2.max([0, 0], max, constraint[1]) as [number, number];\n  }\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n    let v: [number, number] = [0, 0];\n    v = vector2.sub(v, nextPoint, prevPoint) as [number, number];\n    v = vector2.scale(v, v, smooth) as [number, number];\n\n    let d0 = vector2.distance(point, prevPoint);\n    let d1 = vector2.distance(point, nextPoint);\n\n    const sum = d0 + d1;\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    const v1 = vector2.scale([0, 0], v, -d0) as [number, number];\n    const v2 = vector2.scale([0, 0], v, d1) as [number, number];\n\n    let cp0 = vector2.add([0, 0], point, v1) as [number, number];\n    let cp1 = vector2.add([0, 0], point, v2) as [number, number];\n\n    if (hasConstraint) {\n      cp0 = vector2.max([0, 0], cp0, min) as [number, number];\n      cp0 = vector2.min([0, 0], cp0, max) as [number, number];\n      cp1 = vector2.max([0, 0], cp1, min) as [number, number];\n      cp1 = vector2.min([0, 0], cp1, max) as [number, number];\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n\n// 贝塞尔曲线\nexport function catmullRom2bezier(crp: number[], z: boolean, constraint: PointArray[]): any[] {\n  const isLoop = !!z;\n  const pointList = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1 = [];\n\n  let cp1: PointArray;\n  let cp2: PointArray;\n  let p: PointArray;\n\n  for (let i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\n// 将点连接成路径 path\nexport function getLinePath(points: PointObject[], isInCircle: boolean): any[] {\n  return _points2path(points, isInCircle);\n}\n\n// get spline： 限定了范围的平滑线\nexport function getSplinePath(points: PointObject[], isInCircle: boolean, constaint: any): any[] {\n  const data = [];\n  const first = points[0];\n  let prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n  each(points, (point) => {\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  });\n  const constraint = constaint || [\n    // 范围\n    [0, 0],\n    [1, 1],\n  ];\n  const splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n\n// 获取点到圆心的距离\nexport function getPointRadius(coord, point: PointObject): number {\n  return _getPointRadius(coord, point);\n}\n\n// 获取点到圆心的夹角\nexport function getPointAngle(coord, point: PointObject): number {\n  const center = coord.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\nexport function convertNormalPath(coord, path: any[]): any[] {\n  const tmp = [];\n  each(path, (subPath) => {\n    const action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n\nexport function convertPolarPath(coord, path: any[]): any[] {\n  let tmp = [];\n  let pre: any[];\n  let cur: any[];\n  let transposed: boolean;\n  let equals: boolean;\n  each(path, (subPath, index) => {\n    const action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed;\n        // 是否半径相同，转换成圆弧\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n  return tmp;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}