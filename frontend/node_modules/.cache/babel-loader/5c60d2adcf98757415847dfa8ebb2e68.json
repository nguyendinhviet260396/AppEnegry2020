{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { clone, sortBy, valuesOfKey, getRange, each, hasKey } from '@antv/util';\nimport { registerPlotType } from '../../base/global';\nimport { sturges } from '../../util/math';\nimport Column from '../column/layer';\n\nvar HistogramLayer =\n/** @class */\nfunction (_super) {\n  __extends(HistogramLayer, _super);\n\n  function HistogramLayer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'histogram';\n    return _this;\n  }\n\n  HistogramLayer.prototype.init = function () {\n    this.options.xField = 'range';\n    this.options.yField = 'count';\n\n    _super.prototype.init.call(this);\n  };\n\n  HistogramLayer.prototype.processData = function (originData) {\n    var _this = this;\n\n    var _a = this.options,\n        binField = _a.binField,\n        binWidth = _a.binWidth,\n        binNumber = _a.binNumber;\n    var originData_copy = clone(originData); // 根据binField value对源数据进行排序\n\n    sortBy(originData_copy, binField); // 获取源数据binField values的range\n\n    var values = valuesOfKey(originData_copy, binField);\n    var range = getRange(values);\n    var rangeWidth = range.max - range.min; // 计算分箱，直方图分箱的计算基于binWidth，如配置了binNumber则将其转为binWidth进行计算\n\n    var _binWidth = binWidth;\n\n    if (!binWidth && binNumber) {\n      _binWidth = rangeWidth / binNumber;\n    } // 当binWidth和binNumber都没有指定的情况，采用Sturges formula自动生成binWidth\n\n\n    if (!binWidth && !binNumber) {\n      var _defaultBinNumber = sturges(values);\n\n      _binWidth = rangeWidth / _defaultBinNumber;\n    }\n\n    var bins = {};\n    each(originData_copy, function (data) {\n      var value = data[binField];\n\n      var bin = _this.getBin(value, _binWidth);\n\n      var binName = bin[0] + \"-\" + bin[1];\n\n      if (!hasKey(bins, binName)) {\n        bins[binName] = {\n          name: binName,\n          range: bin,\n          count: 0,\n          data: []\n        };\n      }\n\n      bins[binName].data.push(data);\n      bins[binName].count += 1;\n    }); // 将分箱数据转换为plotData\n\n    var plotData = [];\n    each(bins, function (bin) {\n      plotData.push(bin);\n    });\n    return plotData;\n  };\n\n  HistogramLayer.prototype.scale = function () {\n    _super.prototype.scale.call(this); // fixme: 类型定义\n\n\n    var range = this.config.scales.range;\n    range.nice = false;\n    range.type = 'linear';\n  };\n\n  HistogramLayer.prototype.getBin = function (value, binWidth) {\n    var index = Math.floor(value / binWidth);\n    return [binWidth * index, binWidth * (index + 1)];\n  };\n\n  return HistogramLayer;\n}(Column);\n\nexport default HistogramLayer;\nregisterPlotType('histogram', HistogramLayer);","map":{"version":3,"sources":["../../../src/plots/histogram/layer.ts"],"names":[],"mappings":"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","sourcesContent":["import { clone, sortBy, valuesOfKey, getRange, each, hasKey } from '@antv/util';\nimport { registerPlotType } from '../../base/global';\nimport { LayerConfig } from '../../base/layer';\nimport { sturges } from '../../util/math';\nimport Column from '../column/layer';\nimport { ColumnViewConfig } from '../column/interface';\nimport { DataItem } from '../../interface/config';\n\nexport interface HistogramViewConfig extends ColumnViewConfig {\n  binField: string;\n  binWidth?: number;\n  binNumber?: number;\n}\n\nexport interface HistogramLayerConfig extends HistogramViewConfig, LayerConfig {}\n\nexport default class HistogramLayer extends Column<HistogramLayerConfig> {\n  public type: string = 'histogram';\n\n  public init() {\n    this.options.xField = 'range';\n    this.options.yField = 'count';\n    super.init();\n  }\n\n  protected processData(originData?: DataItem[]) {\n    const { binField, binWidth, binNumber } = this.options;\n    const originData_copy = clone(originData);\n    // 根据binField value对源数据进行排序\n    sortBy(originData_copy, binField);\n    // 获取源数据binField values的range\n    const values = valuesOfKey(originData_copy, binField);\n    const range = getRange(values);\n    const rangeWidth = range.max - range.min;\n    // 计算分箱，直方图分箱的计算基于binWidth，如配置了binNumber则将其转为binWidth进行计算\n    let _binWidth = binWidth;\n    if (!binWidth && binNumber) {\n      _binWidth = rangeWidth / binNumber;\n    }\n    // 当binWidth和binNumber都没有指定的情况，采用Sturges formula自动生成binWidth\n    if (!binWidth && !binNumber) {\n      const _defaultBinNumber = sturges(values);\n      _binWidth = rangeWidth / _defaultBinNumber;\n    }\n    const bins = {};\n    each(originData_copy, (data) => {\n      const value = data[binField];\n      const bin = this.getBin(value, _binWidth);\n      const binName = `${bin[0]}-${bin[1]}`;\n      if (!hasKey(bins, binName)) {\n        bins[binName] = { name: binName, range: bin, count: 0, data: [] };\n      }\n      bins[binName].data.push(data);\n      bins[binName].count += 1;\n    });\n    // 将分箱数据转换为plotData\n    const plotData = [];\n    each(bins, (bin) => {\n      plotData.push(bin);\n    });\n    return plotData;\n  }\n\n  protected scale() {\n    super.scale();\n    // fixme: 类型定义\n    const range = this.config.scales.range as any;\n    range.nice = false;\n    range.type = 'linear';\n  }\n\n  private getBin(value, binWidth) {\n    const index = Math.floor(value / binWidth);\n    return [binWidth * index, binWidth * (index + 1)];\n  }\n}\n\nregisterPlotType('histogram', HistogramLayer);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}