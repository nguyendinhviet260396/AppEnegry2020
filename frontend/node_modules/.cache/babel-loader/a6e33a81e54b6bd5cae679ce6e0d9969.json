{"ast":null,"code":"import { __extends } from \"tslib\";\n/** 简化折线点 */\n\nimport { registerShape } from '../../dependents';\nimport { deepMix, each } from '@antv/util';\nimport { lineSimplification } from '../../util/math';\nimport { getSplinePath } from '../../util/path';\nimport AreaParser from './main';\nimport { getGlobalTheme } from '../../theme';\nregisterShape('area', 'miniArea', {\n  draw: function draw(cfg, container) {\n    var opacity = cfg.style ? cfg.style.opacity : null;\n    var path = getPath(cfg, this, false);\n    var style = deepMix({}, {\n      lineJoin: 'round',\n      lineCap: 'round'\n    }, cfg.style);\n    var shape = container.addShape('path', {\n      attrs: {\n        path: path,\n        fill: parseGradient(cfg.color || getGlobalTheme().defaultColor),\n        opacity: opacity || 0.4\n      },\n      style: style\n    });\n    return shape;\n  }\n});\nregisterShape('area', 'miniAreaSmooth', {\n  draw: function draw(cfg, container) {\n    var opacity = cfg.style ? cfg.style.opacity : null;\n    var path = getPath(cfg, this, true);\n    var shape = container.addShape('path', {\n      attrs: {\n        path: path,\n        fill: parseGradient(cfg.color || getGlobalTheme().defaultColor),\n        opacity: opacity || 0.5\n      }\n    });\n    return shape;\n  }\n});\n\nfunction getPath(cfg, shape, isSmooth) {\n  var constraint = [[0, 0], [1, 1]];\n  var topLinePoints = [];\n  var bottomLinePoints = [];\n  each(cfg.points, function (point) {\n    topLinePoints.push(point[1]);\n    bottomLinePoints.push(point[0]);\n  });\n  bottomLinePoints = shape.parsePoints(bottomLinePoints.reverse());\n  topLinePoints = lineSimplification(shape.parsePoints(topLinePoints));\n  var topPath = isSmooth ? getSplinePath(topLinePoints, false, constraint) : getStraightPath(topLinePoints);\n  var bottomPath = getStraightPath(bottomLinePoints);\n  bottomPath[0][0] = 'L';\n  var path = topPath.concat(bottomPath);\n  return path;\n}\n\nfunction getStraightPath(points) {\n  var path = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    var flag = i === 0 ? 'M' : 'L';\n    path.push([flag, p.x, p.y]);\n  }\n\n  return path;\n}\n\nfunction parseGradient(color) {\n  return \"l(90) 0:\" + color + \" 1:#ffffff\";\n}\n\nvar MiniAreaParser =\n/** @class */\nfunction (_super) {\n  __extends(MiniAreaParser, _super);\n\n  function MiniAreaParser() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MiniAreaParser.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.parseShape();\n  };\n\n  MiniAreaParser.prototype.parseShape = function () {\n    var props = this.plot.options;\n\n    if (props.smooth) {\n      this.config.shape = {\n        values: ['miniAreaSmooth']\n      };\n    } else {\n      this.config.shape = {\n        values: ['miniArea']\n      };\n    }\n  };\n\n  return MiniAreaParser;\n}(AreaParser);\n\nexport default MiniAreaParser;","map":{"version":3,"sources":["../../../src/geoms/area/mini.ts"],"names":[],"mappings":"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","sourcesContent":["/** 简化折线点 */\nimport { registerShape } from '../../dependents';\nimport { deepMix, each } from '@antv/util';\nimport { lineSimplification } from '../../util/math';\nimport { getSplinePath } from '../../util/path';\nimport AreaParser from './main';\nimport { getGlobalTheme } from '../../theme';\n\nregisterShape('area', 'miniArea', {\n  draw(cfg, container) {\n    const opacity = cfg.style ? cfg.style.opacity : null;\n    const path = getPath(cfg, this, false);\n    const style = deepMix(\n      {},\n      {\n        lineJoin: 'round',\n        lineCap: 'round',\n      },\n      cfg.style\n    );\n    const shape = container.addShape('path', {\n      attrs: {\n        path,\n        fill: parseGradient(cfg.color || getGlobalTheme().defaultColor),\n        opacity: opacity || 0.4,\n      },\n      style,\n    });\n    return shape;\n  },\n});\n\nregisterShape('area', 'miniAreaSmooth', {\n  draw(cfg, container) {\n    const opacity = cfg.style ? cfg.style.opacity : null;\n    const path = getPath(cfg, this, true);\n    const shape = container.addShape('path', {\n      attrs: {\n        path,\n        fill: parseGradient(cfg.color || getGlobalTheme().defaultColor),\n        opacity: opacity || 0.5,\n      },\n    });\n    return shape;\n  },\n});\n\nfunction getPath(cfg, shape, isSmooth) {\n  const constraint = [\n    [0, 0],\n    [1, 1],\n  ];\n  let topLinePoints = [];\n  let bottomLinePoints = [];\n  each(cfg.points, (point) => {\n    topLinePoints.push(point[1]);\n    bottomLinePoints.push(point[0]);\n  });\n  bottomLinePoints = shape.parsePoints(bottomLinePoints.reverse());\n  topLinePoints = lineSimplification(shape.parsePoints(topLinePoints));\n  const topPath = isSmooth ? getSplinePath(topLinePoints, false, constraint) : getStraightPath(topLinePoints);\n  const bottomPath = getStraightPath(bottomLinePoints);\n  bottomPath[0][0] = 'L';\n  const path = topPath.concat(bottomPath);\n\n  return path;\n}\n\nfunction getStraightPath(points) {\n  const path = [];\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    const flag = i === 0 ? 'M' : 'L';\n    path.push([flag, p.x, p.y]);\n  }\n  return path;\n}\n\nfunction parseGradient(color) {\n  return `l(90) 0:${color} 1:#ffffff`;\n}\n\nexport default class MiniAreaParser extends AreaParser {\n  public init() {\n    super.init();\n    this.parseShape();\n  }\n\n  private parseShape() {\n    const props = this.plot.options;\n    if (props.smooth) {\n      this.config.shape = { values: ['miniAreaSmooth'] };\n    } else {\n      this.config.shape = { values: ['miniArea'] };\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}