{"ast":null,"code":"/**\n * Create By Bruce Too\n * On 2020-02-14\n */\n\n/* eslint-disable unicorn/no-abusive-eslint-disable */\n\n/* eslint-disable */\n// @ts-nocheck\n// TODO rewrite with typescript @brucetoo\n\n/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n'use strict';\n\nimport { __assign } from \"tslib\";\nimport { get, isNil } from '@antv/util'; // setImmediate\n\nif (!window.setImmediate) {\n  window.setImmediate = function setupSetImmediate() {\n    return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message'; // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' || evt.data.substr(0, message.length) !== message\n        /* ||\n        evt.source !== window */\n        ) {\n            return;\n          }\n\n        evt.stopImmediatePropagation();\n        var id = parseInt(evt.data.substr(message.length), 36);\n\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n      /* specify clearImmediate() here since we need the scope */\n\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    }() || // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  }();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = function setupClearImmediate() {\n    return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate || // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  }();\n} // Check if WordCloud can run on this browser\n\n\nvar isSupported = function isSupported() {\n  var canvas = document.createElement('canvas');\n\n  if (!canvas || !canvas.getContext) {\n    return false;\n  }\n\n  var ctx = canvas.getContext('2d');\n\n  if (!ctx.getImageData) {\n    return false;\n  }\n\n  if (!ctx.fillText) {\n    return false;\n  }\n\n  if (!Array.prototype.some) {\n    return false;\n  }\n\n  if (!Array.prototype.push) {\n    return false;\n  }\n\n  return true;\n}(); // Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\n\n\nvar minFontSize = function getMinFontSize() {\n  if (!isSupported) {\n    return;\n  }\n\n  var ctx = document.createElement('canvas').getContext('2d'); // start from 20\n\n  var size = 20; // two sizes to measure\n\n  var hanWidth, mWidth;\n\n  while (size) {\n    ctx.font = size.toString(10) + 'px sans-serif';\n\n    if (ctx.measureText(\"\\uFF37\").width === hanWidth && ctx.measureText('m').width === mWidth) {\n      return size + 1;\n    }\n\n    hanWidth = ctx.measureText(\"\\uFF37\").width;\n    mWidth = ctx.measureText('m').width;\n    size--;\n  }\n\n  return 0;\n}(); // Based on http://jsfromhell.com/array/shuffle\n\n\nvar shuffleArray = function shuffleArray(arr) {\n  for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) {}\n\n  return arr;\n};\n\nvar WordCloud = function WordCloud(elements, options) {\n  if (!isSupported) {\n    return;\n  }\n\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  elements.forEach(function (el, i) {\n    if (typeof el === 'string') {\n      elements[i] = document.getElementById(el);\n\n      if (!elements[i]) {\n        throw 'The element id specified is not found.';\n      }\n    } else if (!el.tagName && !el.appendChild) {\n      throw 'You must pass valid HTML elements, or ID of the element.';\n    }\n  });\n  /* Default values to be overwritten by options object */\n\n  var settings = {\n    data: [],\n    fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n    fontWeight: 'normal',\n    color: 'random-dark',\n    minFontSize: minFontSize,\n    maxFontSize: 60,\n    clearCanvas: true,\n    backgroundColor: '#fff',\n    gridSize: 8,\n    drawOutOfBound: false,\n    origin: null,\n    drawMask: false,\n    maskColor: 'rgba(255,0,0,0.3)',\n    maskGapWidth: 0.3,\n    wait: 0,\n    abortThreshold: 0,\n    abort: function noop() {},\n    minRotation: -Math.PI / 2,\n    maxRotation: Math.PI / 2,\n    rotateRatio: 0.5,\n    rotationSteps: 1,\n    shuffle: true,\n    shape: 'circle',\n    ellipticity: 1,\n    active: true,\n    animatable: true,\n    selected: -1,\n    shadowColor: '#333',\n    shadowBlur: 10,\n    fontScale: 1.2,\n    classes: null,\n    onWordCloudHover: null,\n    onWordCloudClick: null\n  };\n  var interactionItems = [];\n\n  if (options) {\n    for (var key in options) {\n      if (key === 'wordStyle') {\n        for (var fontKey in options[key]) {\n          if (fontKey in settings) {\n            settings[fontKey] = options[key][fontKey];\n          }\n        }\n      } else {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n  }\n\n  if (settings.minFontSize < minFontSize) {\n    // can't less than browse's min font size\n    settings.minFontSize = minFontSize;\n  }\n\n  if (settings.minFontSize > settings.maxFontSize) {\n    console.error('minSize cant bigger than maxSize');\n    return;\n  }\n\n  var maxWeight = 0;\n\n  for (var i = 0; i < settings.data.length; i++) {\n    if (maxWeight < settings.data[i].weight) {\n      maxWeight = settings.data[i].weight;\n    }\n  }\n\n  var getRealFontSize = function getRealFontSize(weight) {\n    var fontSize = Math.min(Math.max(settings.minFontSize, settings.maxFontSize * weight / maxWeight), settings.maxFontSize);\n\n    if (twiceRender) {\n      return fontSize * settings.fontScale;\n    }\n\n    return fontSize;\n  };\n\n  var isCardioid = false;\n  /* Convert shape into a function */\n\n  if (typeof settings.shape !== 'function') {\n    switch (settings.shape) {\n      case 'circle':\n      /* falls through */\n\n      default:\n        // 'circle' is the default and a shortcut in the code loop.\n        settings.shape = 'circle';\n        break;\n\n      case 'cardioid':\n        // https://baike.baidu.com/item/%E5%BF%83%E8%84%8F%E7%BA%BF/10323843?fromtitle=%E5%BF%83%E5%BD%A2%E7%BA%BF&fromid=10018818\n        settings.shape = function shapeCardioid(theta) {\n          return 1 - Math.sin(theta);\n        };\n\n        isCardioid = true;\n        break;\n\n      /*\n      To work out an X-gon, one has to calculate \"m\",\n      where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n      http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n      2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n      Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n      where t' equals to mod(t, 2PI/X);\n      */\n\n      case 'diamond':\n        settings.shape = function shapeSquare(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'square':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n        // +0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          var thetaPrime = (theta + Math.PI / 4) % (2 * Math.PI / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'triangle-forward':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n        // %29%29%2C+t+%3D+0+..+2*PI\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'triangle-backward':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + Math.PI) % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'triangle':\n      case 'triangle-up':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'triangle-down':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + Math.PI * 5 / 2) % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'pentagon':\n        settings.shape = function shapePentagon(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n          return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'star':\n        settings.shape = function shapeStar(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n\n          if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {\n            return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));\n          } else {\n            return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n          }\n        };\n\n        break;\n    }\n  }\n  /* Make sure gridSize is a whole number and is not smaller than 4px */\n\n\n  settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n  /* shorthand */\n\n  var g = settings.gridSize;\n  var maskRectWidth = g - settings.maskGapWidth;\n  /* normalize rotation settings */\n\n  var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n  var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n  var rotationSteps = settings.rotationSteps;\n  /* information/object available to all functions, set when start() */\n\n  var grid, // 2d array containing filling information\n  ngx, ngy, // width and height of the grid\n  center, // position of the center of the cloud\n  maxRadius;\n  /* timestamp for measuring each putWord() action */\n\n  var escapeTime;\n  /* function for getting the color of the text */\n\n  var getTextColor;\n\n  function random_hsl_color(min, max) {\n    return 'hsl(' + (Math.random() * 360).toFixed() + ',' + (Math.random() * 30 + 70).toFixed() + '%,' + (Math.random() * (max - min) + min).toFixed() + '%)';\n  }\n\n  switch (settings.color) {\n    case 'random-dark':\n      getTextColor = function getRandomDarkColor() {\n        return random_hsl_color(10, 50);\n      };\n\n      break;\n\n    case 'random-light':\n      getTextColor = function getRandomLightColor() {\n        return random_hsl_color(50, 90);\n      };\n\n      break;\n\n    default:\n      if (typeof settings.color === 'function') {\n        getTextColor = settings.color;\n      }\n\n      break;\n  }\n  /* function for getting the classes of the text */\n\n\n  var getTextClasses = null;\n\n  if (typeof settings.classes === 'function') {\n    getTextClasses = settings.classes;\n  }\n  /* Interactive */\n\n\n  var interactive = false;\n  var infoGrid = [];\n  var hovered;\n\n  var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n    var canvas = evt.currentTarget;\n    var rect = canvas.getBoundingClientRect();\n    var clientX;\n    var clientY;\n    /** Detect if touches are available */\n\n    if (evt.touches) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n\n    var eventX = clientX - rect.left;\n    var eventY = clientY - rect.top;\n    var x = Math.floor(eventX * (canvas.width / rect.width || 1) / g);\n    var y = Math.floor(eventY * (canvas.height / rect.height || 1) / g);\n    return infoGrid && infoGrid[x] && infoGrid[x][y];\n  };\n\n  var defaultHoverAction = function defaultHoverAction(item, dimension, evt, start) {\n    if (item) {\n      start(item.id);\n    } else {\n      start(-1);\n    }\n  };\n\n  var wordcloudhover = function wordcloudhover(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n\n    if (hovered === info) {\n      return;\n    }\n\n    if (twiceRender && info && info.item && !get(info, ['item', 'twiceRender'])) {\n      return;\n    }\n\n    if (!info) {\n      settings.onWordCloudHover(undefined, undefined, evt, start);\n\n      if (settings.active) {\n        defaultHoverAction(undefined, undefined, evt, start);\n      }\n\n      return;\n    }\n\n    settings.onWordCloudHover(info.item, info.dimension, evt, start);\n\n    if (settings.active) {\n      defaultHoverAction(info.item, info.dimension, evt, start);\n    }\n\n    hovered = info;\n  };\n\n  var wordcloudclick = function wordcloudclick(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n\n    if (!info) {\n      return;\n    }\n\n    settings.onWordCloudClick(info.item, info.dimension, evt);\n    evt.preventDefault();\n  };\n  /* Get points on the grid for a given radius away from the center */\n\n\n  var pointsAtRadius = [];\n\n  var getPointsAtRadius = function getPointsAtRadius(radius) {\n    if (pointsAtRadius[radius]) {\n      return pointsAtRadius[radius];\n    } // Look for these number of points on each radius\n\n\n    var T = radius * 8; // Getting all the points at this radius\n\n    var t = T;\n    var points = [];\n\n    if (radius === 0) {\n      points.push([center[0], center[1], 0]);\n    }\n\n    while (t--) {\n      // distort the radius to put the cloud in shape\n      var rx = 1;\n\n      if (settings.shape !== 'circle') {\n        rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n      } // Push [x, y, t]; t is used solely for getTextColor()\n\n\n      points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * settings.ellipticity, t / T * 2 * Math.PI]);\n    }\n\n    pointsAtRadius[radius] = points;\n    return points;\n  };\n  /* Return true if we had spent too much time */\n\n\n  var exceedTime = function exceedTime() {\n    return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n  };\n  /* Get the deg of rotation according to settings, and luck. */\n\n\n  var getRotateDeg = function getRotateDeg() {\n    if (settings.rotateRatio === 0) {\n      return 0;\n    }\n\n    if (Math.random() > settings.rotateRatio) {\n      return 0;\n    }\n\n    if (rotationRange === 0) {\n      return minRotation;\n    } // return minRotation + Math.round(Math.random() * rotationRange / rotationSteps) * rotationSteps;\n\n\n    if (rotationSteps > 0) {\n      // Min rotation + zero or more steps * span of one step\n      return minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / rotationSteps;\n    } else {\n      return minRotation + Math.random() * rotationRange;\n    }\n  };\n\n  var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n    // calculate the acutal font size\n    // fontSize === 0 means wants the text skipped,\n    // and size < minSize means we cannot draw the text\n    var debug = false;\n    var fontSize = getRealFontSize(weight);\n\n    if (fontSize <= 0) {\n      return false;\n    } // Scale factor here is to make sure fillText is not limited by\n    // the minium font size set by browser.\n    // It will always be 1 or 2n.\n\n\n    var mu = 1;\n\n    if (fontSize < minFontSize) {\n      mu = function calculateScaleFactor() {\n        var mu = 2;\n\n        while (mu * fontSize < minFontSize) {\n          mu += 2;\n        }\n\n        return mu;\n      }();\n    }\n\n    var fcanvas = document.createElement('canvas');\n    var fctx = fcanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Estimate the dimension of the text with measureText().\n\n    var fw = fctx.measureText(word).width / mu;\n    var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText(\"\\uFF37\").width) / mu; // Create a boundary box that is larger than our estimates,\n    // so text don't get cut of (it sill might)\n\n    var boxWidth = fw + fh * 2;\n    var boxHeight = fh * 3;\n    var fgw = Math.ceil(boxWidth / g);\n    var fgh = Math.ceil(boxHeight / g);\n    boxWidth = fgw * g;\n    boxHeight = fgh * g; // Calculate the proper offsets to make the text centered at\n    // the preferred position.\n    // This is simply half of the width.\n\n    var fillTextOffsetX = -fw / 2; // Instead of moving the box to the exact middle of the preferred\n    // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n    // vertical centered.\n\n    var fillTextOffsetY = -fh * 0.4; // Calculate the actual dimension of the canvas, considering the rotation.\n\n    var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n    var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n    var width = cgw * g;\n    var height = cgh * g;\n    fcanvas.setAttribute('width', width);\n    fcanvas.setAttribute('height', height);\n\n    if (debug) {\n      // Attach fcanvas to the DOM\n      document.body.appendChild(fcanvas); // Save it's state so that we could restore and draw the grid correctly.\n\n      fctx.save();\n    } // Scale the canvas with |mu|.\n\n\n    fctx.scale(1 / mu, 1 / mu);\n    fctx.translate(width * mu / 2, height * mu / 2);\n    fctx.rotate(-rotateDeg); // Once the width/height is set, ctx info will be reset.\n    // Set it again here.\n\n    fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Fill the text into the fcanvas.\n    // XXX: We cannot because textBaseline = 'top' here because\n    // Firefox and Chrome uses different default line-height for canvas.\n    // Please read https://bugzil.la/737852#c6.\n    // Here, we use textBaseline = 'middle' and draw the text at exactly\n    // 0.5 * fontSize lower.\n\n    fctx.fillStyle = '#000';\n    fctx.textBaseline = 'middle';\n    fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu); // Get the pixels of the text\n\n    var imageData;\n\n    try {\n      imageData = fctx.getImageData(0, 0, width, height).data;\n    } catch (e) {\n      // data not long type\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    if (debug) {\n      // Draw the box of the original estimation\n      fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n      fctx.restore();\n    } // Read the pixels and save the information to the occupied array\n\n\n    var occupied = [];\n    var gx = cgw,\n        gy,\n        x,\n        y;\n    var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n\n    while (gx--) {\n      gy = cgh;\n\n      while (gy--) {\n        y = g;\n\n        singleGridLoop: {\n          while (y--) {\n            x = g;\n\n            while (x--) {\n              if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                occupied.push([gx, gy]);\n\n                if (gx < bounds[3]) {\n                  bounds[3] = gx;\n                }\n\n                if (gx > bounds[1]) {\n                  bounds[1] = gx;\n                }\n\n                if (gy < bounds[0]) {\n                  bounds[0] = gy;\n                }\n\n                if (gy > bounds[2]) {\n                  bounds[2] = gy;\n                }\n\n                if (debug) {\n                  fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                  fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                }\n\n                break singleGridLoop;\n              }\n            }\n          }\n\n          if (debug) {\n            fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n          }\n        }\n      }\n    }\n\n    if (debug) {\n      // real bounds\n      fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n      fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n    } // Return information needed to create the text on the real canvas\n\n\n    return {\n      mu: mu,\n      occupied: occupied,\n      bounds: bounds,\n      gw: cgw,\n      gh: cgh,\n      fillTextOffsetX: fillTextOffsetX,\n      fillTextOffsetY: fillTextOffsetY,\n      fillTextWidth: fw,\n      fillTextHeight: fh,\n      fontSize: fontSize\n    };\n  };\n  /* Determine if there is room available in the given dimension */\n\n\n  var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n    // Go through the occupied points,\n    // return false if the space is not available.\n    var i = occupied.length;\n\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        if (!settings.drawOutOfBound) {\n          return false;\n        }\n\n        continue;\n      }\n\n      if (!grid[px][py]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /* Actually draw the text on the grid */\n\n\n  var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, id, refresh) {\n    var fontSize = info.fontSize;\n    var color = settings.color;\n    var classes = settings.classes;\n\n    if (!refresh) {\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      }\n\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\n      } else {\n        classes = settings.classes;\n      }\n    } else {\n      var find = getInteractionItemById(id);\n      color = find ? find.color : settings.color;\n    }\n\n    var dimension;\n    var bounds = info.bounds;\n    dimension = {\n      x: (gx + bounds[3]) * g,\n      y: (gy + bounds[0]) * g,\n      w: (bounds[1] - bounds[3] + 1) * g,\n      h: (bounds[2] - bounds[0] + 1) * g\n    };\n    elements.forEach(function (el) {\n      if (el.getContext) {\n        var ctx = el.getContext('2d');\n        var mu = info.mu; // Save the current state before messing it\n\n        ctx.save();\n        var font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        ctx.scale(1 / mu, 1 / mu);\n        ctx.font = font;\n        ctx.fillStyle = color; // Translate the canvas position to the origin coordinate of where\n        // the text should be put.\n\n        var transX = (gx + info.gw / 2) * g * mu;\n        var transY = (gy + info.gh / 2) * g * mu;\n        ctx.translate(transX, transY);\n\n        if (rotateDeg !== 0) {\n          ctx.rotate(-rotateDeg);\n        } // Finally, fill the text.\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n\n\n        ctx.textBaseline = 'middle';\n\n        if (settings.selected === id) {\n          ctx.shadowColor = settings.shadowColor;\n          ctx.shadowBlur = settings.shadowBlur;\n        }\n\n        ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu); // The below box is always matches how <span>s are positioned\n        // ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n        //   info.fillTextWidth, info.fillTextHeight);\n\n        if (!refresh) {\n          interactionItems.push({\n            gx: gx,\n            gy: gy,\n            info: info,\n            word: word,\n            weight: weight,\n            distance: distance,\n            theta: theta,\n            rotateDeg: rotateDeg,\n            attributes: attributes,\n            id: id,\n            color: color\n          });\n        } // Restore the state.\n\n\n        ctx.restore();\n      } else {\n        // drawText on DIV element\n        var span = document.createElement('span');\n        var transformRule = '';\n        transformRule = 'rotate(' + -rotateDeg / Math.PI * 180 + 'deg) ';\n\n        if (info.mu !== 1) {\n          transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n        }\n\n        var styleRules = {\n          position: 'absolute',\n          display: 'block',\n          font: settings.fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n          left: (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n          top: (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n          width: info.fillTextWidth + 'px',\n          height: info.fillTextHeight + 'px',\n          lineHeight: fontSize + 'px',\n          whiteSpace: 'nowrap',\n          transform: transformRule,\n          webkitTransform: transformRule,\n          msTransform: transformRule,\n          transformOrigin: '50% 40%',\n          webkitTransformOrigin: '50% 40%',\n          msTransformOrigin: '50% 40%'\n        };\n\n        if (color) {\n          styleRules.color = color;\n        }\n\n        span.textContent = word;\n\n        for (var cssProp in styleRules) {\n          span.style[cssProp] = styleRules[cssProp];\n        }\n\n        if (attributes) {\n          for (var attribute in attributes) {\n            span.setAttribute(attribute, attributes[attribute]);\n          }\n        }\n\n        if (classes) {\n          span.className += classes;\n        }\n\n        el.appendChild(span);\n      }\n    });\n  };\n  /* Help function to updateGrid */\n\n\n  var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n    if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n      return;\n    }\n\n    grid[x][y] = false;\n\n    if (drawMask) {\n      var ctx = elements[0].getContext('2d');\n      ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n    }\n\n    if (interactive) {\n      infoGrid[x][y] = {\n        item: item,\n        dimension: dimension\n      };\n    }\n  };\n  /* Update the filling information of the given space with occupied points.\n     Draw the mask on the canvas if necessary. */\n\n\n  var updateGrid = function updateGrid(gx, gy, gw, gh, info) {\n    var occupied = info.occupied;\n    var drawMask = settings.drawMask;\n    var ctx;\n\n    if (drawMask) {\n      ctx = elements[0].getContext('2d');\n      ctx.save();\n      ctx.fillStyle = settings.maskColor;\n    }\n\n    var dimension;\n\n    if (interactive) {\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n    }\n\n    var i = occupied.length;\n\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        continue;\n      } // save item's color from info\n\n\n      var find = getInteractionItemById(info.item.id);\n\n      if (find) {\n        info.item.color = find.color;\n      }\n\n      fillGridAt(px, py, drawMask, dimension, info.item);\n    }\n\n    if (drawMask) {\n      ctx.restore();\n    }\n  };\n\n  var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy, info, word, weight, distance, rotateDeg, attributes, id) {\n    var gx = Math.floor(gxy[0] - info.gw / 2);\n    var gy = Math.floor(gxy[1] - info.gh / 2);\n    var gw = info.gw;\n    var gh = info.gh; // If we cannot fit the text at this position, return false\n    // and go to the next position.\n\n    if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n      return false;\n    } // Actually put the text on the canvas\n\n\n    drawText(gx, gy, info, word, weight, distance, gxy[2], rotateDeg, attributes, id, false); // Mark the spaces on the grid as filled\n\n    updateGrid(gx, gy, gw, gh, info);\n    return {\n      gx: gx,\n      gy: gy,\n      rot: rotateDeg,\n      info: info\n    };\n  };\n  /* putWord() processes each item on the list,\n     calculate it's size and determine it's position, and actually\n     put it on the canvas. */\n\n\n  var putWord = function putWord(item) {\n    var word, weight, attributes, id;\n\n    if (Array.isArray(item)) {\n      word = item[0];\n      weight = item[1];\n    } else {\n      word = item.word;\n      weight = item.weight;\n      attributes = item.attributes;\n      id = item.id;\n    }\n\n    var rotateDeg = isNil(item.rotateDeg) ? getRotateDeg() : item.rotateDeg; // get info needed to put the text onto the canvas\n\n    var info = getTextInfo(word, weight, rotateDeg);\n\n    if (info) {\n      info['item'] = item;\n    } // not getting the info means we shouldn't be drawing this one.\n\n\n    if (!info) {\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    } // If drawOutOfBound is set to false,\n    // skip the loop if we have already know the bounding box of\n    // word is larger than the canvas.\n\n\n    if (!settings.drawOutOfBound) {\n      var bounds = info.bounds;\n\n      if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n        return false;\n      }\n    } // Determine the position to put the text by\n    // start looking for the nearest points\n\n\n    var r = maxRadius + 1;\n\n    while (r--) {\n      var points = getPointsAtRadius(maxRadius - r);\n\n      if (settings.shuffle) {\n        points = [].concat(points);\n        shuffleArray(points);\n      } // Try to fit the words by looking at each point.\n      // array.some() will stop and return true\n      // when putWordAtPoint() returns true.\n\n\n      for (var i = 0; i < points.length; i++) {\n        var res = tryToPutWordAtPoint(points[i], info, word, weight, maxRadius - r, rotateDeg, attributes, id);\n\n        if (res) {\n          return res;\n        }\n      } // var drawn = points.some(tryToPutWordAtPoint);\n      // if (drawn) {\n      //   // leave putWord() and return true\n      //   return true;\n      // }\n\n    } // we tried all distances but text won't fit, return null\n\n\n    return null;\n  };\n  /* Send DOM event to all elements. Will stop sending event and return\n     if the previous one is canceled (for cancelable events). */\n\n\n  var sendEvent = function sendEvent(type, cancelable, detail) {\n    if (cancelable) {\n      return !elements.some(function (el) {\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(type, true, cancelable, detail || {});\n        return !el.dispatchEvent(evt);\n      }, this);\n    } else {\n      elements.forEach(function (el) {\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(type, true, cancelable, detail || {});\n        el.dispatchEvent(evt);\n      }, this);\n    }\n  };\n\n  var getInteractionItemById = function getInteractionItemById(id) {\n    for (var i = 0; i < interactionItems.length; i++) {\n      var find = interactionItems[i];\n\n      if (interactionItems[i].id === id) {\n        return find;\n      }\n    }\n\n    return undefined;\n  };\n\n  var twiceRender;\n  /* Start drawing on a canvas */\n\n  var start = function start(selected) {\n    if (selected !== undefined) {\n      // re-refresh canvas with selected\n      // work in canvas only for now\n      if (settings.selected !== selected && elements[0].getContext) {\n        settings.selected = selected;\n        var ctx = elements[0].getContext('2d'); // draw background\n\n        ctx.fillStyle = settings.backgroundColor;\n        ctx.clearRect(0, 0, elements[0].width, elements[0].height);\n        ctx.fillRect(0, 0, elements[0].width, elements[0].height); // draw text\n\n        for (var i_1 = 0; i_1 < interactionItems.length; i_1++) {\n          var find = interactionItems[i_1];\n\n          if (!twiceRender || twiceRender && get(find, ['info', 'item', 'twiceRender'])) {\n            /**\n             * 词云图词量较少的时候，重新渲染一次词汇，放大词云图效果\n             * 这里先临时解决，后续还是需要优化词云图算法来解决\n             */\n            drawText(find.gx, find.gy, find.info, find.word, find.weight, find.distance, find.theta, find.rotateDeg, find.attributes, find.id, true);\n          }\n        }\n      }\n\n      return;\n    } // For dimensions, clearCanvas etc.,\n    // we only care about the first element.\n\n\n    var canvas = elements[0];\n\n    if (canvas.getContext) {\n      ngx = Math.ceil(canvas.width / g);\n      ngy = Math.ceil(canvas.height / g);\n    } else {\n      var rect = canvas.getBoundingClientRect();\n      ngx = Math.ceil(rect.width / g);\n      ngy = Math.ceil(rect.height / g);\n    } // Sending a wordcloudstart event which cause the previous loop to stop.\n    // Do nothing if the event is canceled.\n\n\n    if (!sendEvent('wordcloudstart', true)) {\n      return;\n    } // Determine the center of the word cloud\n\n\n    center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / (isCardioid ? 4 : 2)]; // Maxium radius to look for space\n\n    maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n    /* Clear the canvas only if the clearCanvas is set,\n       if not, update the grid to the current canvas state */\n\n    grid = [];\n    var gx, gy, i;\n\n    if (!canvas.getContext || settings.clearCanvas) {\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          ctx.fillStyle = settings.backgroundColor;\n          ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n        } else {\n          el.textContent = '';\n          el.style.backgroundColor = settings.backgroundColor;\n          el.style.position = 'relative';\n        }\n      });\n      /* fill the grid with empty state */\n\n      gx = ngx;\n\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n\n        while (gy--) {\n          grid[gx][gy] = true;\n        }\n      }\n    } else {\n      /* Determine bgPixel by creating\n         another canvas and fill the specified background color. */\n      var bctx = document.createElement('canvas').getContext('2d');\n      bctx.fillStyle = settings.backgroundColor;\n      bctx.fillRect(0, 0, 1, 1);\n      var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n      /* Read back the pixels of the canvas we got to tell which part of the\n         canvas is empty.\n         (no clearCanvas only works with a canvas, not divs) */\n\n      var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n      gx = ngx;\n      var x, y;\n\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n\n        while (gy--) {\n          y = g;\n\n          singleGridLoop: while (y--) {\n            x = g;\n\n            while (x--) {\n              i = 4;\n\n              while (i--) {\n                if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                  grid[gx][gy] = false;\n                  break singleGridLoop;\n                }\n              }\n            }\n          }\n\n          if (grid[gx][gy] !== false) {\n            grid[gx][gy] = true;\n          }\n        }\n      }\n\n      imageData = bctx = bgPixel = undefined;\n    } // fill the infoGrid with empty state if we need it\n\n\n    if (settings.onWordCloudHover || settings.onWordCloudClick) {\n      interactive = true;\n      /* fill the grid with empty state */\n\n      gx = ngx + 1;\n\n      while (gx--) {\n        infoGrid[gx] = [];\n      }\n\n      if (settings.onWordCloudHover) {\n        canvas.addEventListener('mousemove', wordcloudhover);\n      }\n\n      if (settings.onWordCloudClick) {\n        canvas.addEventListener('click', wordcloudclick);\n        canvas.addEventListener('touchstart', wordcloudclick);\n        canvas.addEventListener('touchend', function (e) {\n          e.preventDefault();\n        });\n        canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n\n      canvas.addEventListener('wordcloudstart', function stopInteraction() {\n        canvas.removeEventListener('wordcloudstart', stopInteraction);\n        canvas.removeEventListener('mousemove', wordcloudhover);\n        canvas.removeEventListener('click', wordcloudclick);\n        hovered = undefined;\n      });\n    }\n\n    if (!settings.animatable) {\n      if (options.maskImage) {\n        /** 修复颜色透明，还留有 maskImage 的情况 */\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          }\n        });\n      }\n\n      var renderedWords = [];\n\n      for (var i_2 = 0; i_2 < settings.data.length; i_2++) {\n        var response = putWord(settings.data[i_2]);\n\n        if (response) {\n          renderedWords.push(response);\n        }\n      }\n\n      if (renderedWords.length === settings.data.length) {\n        if (!twiceRender) {\n          elements.forEach(function (el) {\n            if (el.getContext) {\n              var ctx = el.getContext('2d');\n              ctx.fillStyle = settings.backgroundColor;\n              ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n              ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            }\n          });\n          /* fill the grid with empty state */\n\n          gx = ngx;\n\n          while (gx--) {\n            grid[gx] = [];\n            gy = ngy;\n\n            while (gy--) {\n              grid[gx][gy] = true;\n            }\n          }\n\n          twiceRender = true;\n\n          for (var i_3 = 0; i_3 < settings.data.length; i_3++) {\n            putWord(__assign(__assign({}, settings.data[i_3]), {\n              twiceRender: twiceRender\n            }));\n          }\n        }\n      }\n    } else {\n      i = 0;\n      var loopingFunction, stoppingFunction;\n\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n      var timer = loopingFunction(function loop() {\n        if (i >= settings.data.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n\n        escapeTime = new Date().getTime();\n        var drawn = putWord(settings.data[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.data[i],\n          drawn: drawn\n        });\n\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    }\n  }; // All set, start the drawing\n\n\n  start();\n};\n\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\nexport default WordCloud;","map":{"version":3,"sources":["../../../src/plots/word-cloud/wordcloud2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Create By Bruce Too\n * On 2020-02-14\n */\n/* eslint-disable unicorn/no-abusive-eslint-disable */\n/* eslint-disable */\n// @ts-nocheck\n\n// TODO rewrite with typescript @brucetoo\n\n/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n\n'use strict';\n\nimport { get, isNil } from '@antv/util';\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate() {\n    return (\n      window.msSetImmediate ||\n      window.webkitSetImmediate ||\n      window.mozSetImmediate ||\n      window.oSetImmediate ||\n      (function setupSetZeroTimeout() {\n        if (!window.postMessage || !window.addEventListener) {\n          return null;\n        }\n\n        var callbacks = [undefined];\n        var message = 'zero-timeout-message';\n\n        // Like setTimeout, but only takes a function argument.  There's\n        // no time argument (always zero) and no arguments (you have to\n        // use a closure).\n        var setZeroTimeout = function setZeroTimeout(callback) {\n          var id = callbacks.length;\n          callbacks.push(callback);\n          window.postMessage(message + id.toString(36), '*');\n\n          return id;\n        };\n\n        window.addEventListener(\n          'message',\n          function setZeroTimeoutMessage(evt) {\n            // Skipping checking event source, retarded IE confused this window\n            // object with another in the presence of iframe\n            if (\n              typeof evt.data !== 'string' ||\n              evt.data.substr(0, message.length) !== message /* ||\n            evt.source !== window */\n            ) {\n              return;\n            }\n\n            evt.stopImmediatePropagation();\n\n            var id = parseInt(evt.data.substr(message.length), 36);\n            if (!callbacks[id]) {\n              return;\n            }\n\n            callbacks[id]();\n            callbacks[id] = undefined;\n          },\n          true\n        );\n\n        /* specify clearImmediate() here since we need the scope */\n        window.clearImmediate = function clearZeroTimeout(id) {\n          if (!callbacks[id]) {\n            return;\n          }\n\n          callbacks[id] = undefined;\n        };\n\n        return setZeroTimeout;\n      })() ||\n      // fallback\n      function setImmediateFallback(fn) {\n        window.setTimeout(fn, 0);\n      }\n    );\n  })();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate() {\n    return (\n      window.msClearImmediate ||\n      window.webkitClearImmediate ||\n      window.mozClearImmediate ||\n      window.oClearImmediate ||\n      // \"clearZeroTimeout\" is implement on the previous block ||\n      // fallback\n      function clearImmediateFallback(timer) {\n        window.clearTimeout(timer);\n      }\n    );\n  })();\n}\n\n// Check if WordCloud can run on this browser\nvar isSupported = (function isSupported() {\n  var canvas = document.createElement('canvas');\n  if (!canvas || !canvas.getContext) {\n    return false;\n  }\n\n  var ctx = canvas.getContext('2d');\n  if (!ctx.getImageData) {\n    return false;\n  }\n  if (!ctx.fillText) {\n    return false;\n  }\n\n  if (!Array.prototype.some) {\n    return false;\n  }\n  if (!Array.prototype.push) {\n    return false;\n  }\n\n  return true;\n})();\n\n// Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\nvar minFontSize = (function getMinFontSize() {\n  if (!isSupported) {\n    return;\n  }\n\n  var ctx = document.createElement('canvas').getContext('2d');\n\n  // start from 20\n  var size = 20;\n\n  // two sizes to measure\n  var hanWidth, mWidth;\n\n  while (size) {\n    ctx.font = size.toString(10) + 'px sans-serif';\n    if (ctx.measureText('\\uFF37').width === hanWidth && ctx.measureText('m').width === mWidth) {\n      return size + 1;\n    }\n\n    hanWidth = ctx.measureText('\\uFF37').width;\n    mWidth = ctx.measureText('m').width;\n\n    size--;\n  }\n\n  return 0;\n})();\n\n// Based on http://jsfromhell.com/array/shuffle\nvar shuffleArray = function shuffleArray(arr) {\n  for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) {}\n  return arr;\n};\n\nvar WordCloud = function WordCloud(elements, options) {\n  if (!isSupported) {\n    return;\n  }\n\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  elements.forEach(function (el, i) {\n    if (typeof el === 'string') {\n      elements[i] = document.getElementById(el);\n      if (!elements[i]) {\n        throw 'The element id specified is not found.';\n      }\n    } else if (!el.tagName && !el.appendChild) {\n      throw 'You must pass valid HTML elements, or ID of the element.';\n    }\n  });\n\n  /* Default values to be overwritten by options object */\n  var settings = {\n    data: [],\n    fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n    fontWeight: 'normal',\n    color: 'random-dark',\n\n    minFontSize: minFontSize, // browser's min font size default\n    maxFontSize: 60, // max font size default is 60\n\n    clearCanvas: true,\n    backgroundColor: '#fff', // opaque white = rgba(255, 255, 255, 1)\n\n    gridSize: 8,\n    drawOutOfBound: false,\n    origin: null,\n\n    drawMask: false,\n    maskColor: 'rgba(255,0,0,0.3)',\n    maskGapWidth: 0.3,\n\n    wait: 0,\n    abortThreshold: 0, // disabled\n    abort: function noop() {},\n\n    minRotation: -Math.PI / 2,\n    maxRotation: Math.PI / 2,\n    rotateRatio: 0.5,\n    rotationSteps: 1,\n\n    shuffle: true,\n\n    shape: 'circle',\n    ellipticity: 1,\n\n    active: true,\n    animatable: true,\n    selected: -1,\n    shadowColor: '#333',\n    shadowBlur: 10,\n    fontScale: 1.2,\n    classes: null,\n\n    onWordCloudHover: null,\n    onWordCloudClick: null,\n  };\n\n  const interactionItems = [];\n\n  if (options) {\n    for (var key in options) {\n      if (key === 'wordStyle') {\n        for (let fontKey in options[key]) {\n          if (fontKey in settings) {\n            settings[fontKey] = options[key][fontKey];\n          }\n        }\n      } else {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n  }\n\n  if (settings.minFontSize < minFontSize) {\n    // can't less than browse's min font size\n    settings.minFontSize = minFontSize;\n  }\n\n  if (settings.minFontSize > settings.maxFontSize) {\n    console.error('minSize cant bigger than maxSize');\n    return;\n  }\n\n  let maxWeight = 0;\n  for (let i = 0; i < settings.data.length; i++) {\n    if (maxWeight < settings.data[i].weight) {\n      maxWeight = settings.data[i].weight;\n    }\n  }\n\n  var getRealFontSize = function getRealFontSize(weight) {\n    const fontSize = Math.min(\n      Math.max(settings.minFontSize, (settings.maxFontSize * weight) / maxWeight),\n      settings.maxFontSize\n    );\n    if (twiceRender) {\n      return fontSize * settings.fontScale;\n    }\n    return fontSize;\n  };\n\n  var isCardioid = false;\n  /* Convert shape into a function */\n  if (typeof settings.shape !== 'function') {\n    switch (settings.shape) {\n      case 'circle':\n      /* falls through */\n      default:\n        // 'circle' is the default and a shortcut in the code loop.\n        settings.shape = 'circle';\n        break;\n\n      case 'cardioid':\n        // https://baike.baidu.com/item/%E5%BF%83%E8%84%8F%E7%BA%BF/10323843?fromtitle=%E5%BF%83%E5%BD%A2%E7%BA%BF&fromid=10018818\n        settings.shape = function shapeCardioid(theta) {\n          return 1 - Math.sin(theta);\n        };\n        isCardioid = true;\n        break;\n\n      /*\n      To work out an X-gon, one has to calculate \"m\",\n      where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n      http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n      2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n      Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n      where t' equals to mod(t, 2PI/X);\n      */\n\n      case 'diamond':\n        settings.shape = function shapeSquare(theta) {\n          const thetaPrime = theta % ((2 * Math.PI) / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n        break;\n      case 'square':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n        // +0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          const thetaPrime = (theta + Math.PI / 4) % ((2 * Math.PI) / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'triangle-forward':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n        // %29%29%2C+t+%3D+0+..+2*PI\n        settings.shape = function shapeTriangle(theta) {\n          const thetaPrime = theta % ((2 * Math.PI) / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'triangle-backward':\n        settings.shape = function shapeTriangle(theta) {\n          const thetaPrime = (theta + Math.PI) % ((2 * Math.PI) / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'triangle':\n      case 'triangle-up':\n        settings.shape = function shapeTriangle(theta) {\n          const thetaPrime = (theta + (Math.PI * 3) / 2) % ((2 * Math.PI) / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n      case 'triangle-down':\n        settings.shape = function shapeTriangle(theta) {\n          const thetaPrime = (theta + (Math.PI * 5) / 2) % ((2 * Math.PI) / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'pentagon':\n        settings.shape = function shapePentagon(theta) {\n          const thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 5);\n          return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'star':\n        settings.shape = function shapeStar(theta) {\n          const thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 10);\n          if (((theta + 0.955) % ((2 * Math.PI) / 5)) - (2 * Math.PI) / 10 >= 0) {\n            return (\n              1 / (Math.cos((2 * Math.PI) / 10 - thetaPrime) + 3.07768 * Math.sin((2 * Math.PI) / 10 - thetaPrime))\n            );\n          } else {\n            return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n          }\n        };\n        break;\n    }\n  }\n\n  /* Make sure gridSize is a whole number and is not smaller than 4px */\n  settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n  /* shorthand */\n  var g = settings.gridSize;\n  var maskRectWidth = g - settings.maskGapWidth;\n\n  /* normalize rotation settings */\n  var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n  var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n  var rotationSteps = settings.rotationSteps;\n\n  /* information/object available to all functions, set when start() */\n  var grid, // 2d array containing filling information\n    ngx,\n    ngy, // width and height of the grid\n    center, // position of the center of the cloud\n    maxRadius;\n\n  /* timestamp for measuring each putWord() action */\n  var escapeTime;\n\n  /* function for getting the color of the text */\n  var getTextColor;\n  function random_hsl_color(min, max) {\n    return (\n      'hsl(' +\n      (Math.random() * 360).toFixed() +\n      ',' +\n      (Math.random() * 30 + 70).toFixed() +\n      '%,' +\n      (Math.random() * (max - min) + min).toFixed() +\n      '%)'\n    );\n  }\n  switch (settings.color) {\n    case 'random-dark':\n      getTextColor = function getRandomDarkColor() {\n        return random_hsl_color(10, 50);\n      };\n      break;\n\n    case 'random-light':\n      getTextColor = function getRandomLightColor() {\n        return random_hsl_color(50, 90);\n      };\n      break;\n\n    default:\n      if (typeof settings.color === 'function') {\n        getTextColor = settings.color;\n      }\n      break;\n  }\n\n  /* function for getting the classes of the text */\n  var getTextClasses = null;\n  if (typeof settings.classes === 'function') {\n    getTextClasses = settings.classes;\n  }\n\n  /* Interactive */\n  var interactive = false;\n  var infoGrid = [];\n  var hovered;\n\n  var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n    var canvas = evt.currentTarget;\n    var rect = canvas.getBoundingClientRect();\n    var clientX;\n    var clientY;\n    /** Detect if touches are available */\n    if (evt.touches) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n    var eventX = clientX - rect.left;\n    var eventY = clientY - rect.top;\n\n    var x = Math.floor((eventX * (canvas.width / rect.width || 1)) / g);\n    var y = Math.floor((eventY * (canvas.height / rect.height || 1)) / g);\n\n    return infoGrid && infoGrid[x] && infoGrid[x][y];\n  };\n\n  var defaultHoverAction = function defaultHoverAction(item, dimension, evt, start) {\n    if (item) {\n      start(item.id);\n    } else {\n      start(-1);\n    }\n  };\n\n  var wordcloudhover = function wordcloudhover(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n    if (hovered === info) {\n      return;\n    }\n\n    if (twiceRender && info && info.item && !get(info, ['item', 'twiceRender'])) {\n      return;\n    }\n    if (!info) {\n      settings.onWordCloudHover(undefined, undefined, evt, start);\n      if (settings.active) {\n        defaultHoverAction(undefined, undefined, evt, start);\n      }\n      return;\n    }\n\n    settings.onWordCloudHover(info.item, info.dimension, evt, start);\n    if (settings.active) {\n      defaultHoverAction(info.item, info.dimension, evt, start);\n    }\n    hovered = info;\n  };\n\n  var wordcloudclick = function wordcloudclick(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n    if (!info) {\n      return;\n    }\n\n    settings.onWordCloudClick(info.item, info.dimension, evt);\n    evt.preventDefault();\n  };\n\n  /* Get points on the grid for a given radius away from the center */\n  var pointsAtRadius = [];\n  var getPointsAtRadius = function getPointsAtRadius(radius) {\n    if (pointsAtRadius[radius]) {\n      return pointsAtRadius[radius];\n    }\n\n    // Look for these number of points on each radius\n    var T = radius * 8;\n\n    // Getting all the points at this radius\n    var t = T;\n    var points = [];\n\n    if (radius === 0) {\n      points.push([center[0], center[1], 0]);\n    }\n\n    while (t--) {\n      // distort the radius to put the cloud in shape\n      var rx = 1;\n      if (settings.shape !== 'circle') {\n        rx = settings.shape((t / T) * 2 * Math.PI); // 0 to 1\n      }\n\n      // Push [x, y, t]; t is used solely for getTextColor()\n      points.push([\n        center[0] + radius * rx * Math.cos((-t / T) * 2 * Math.PI),\n        center[1] + radius * rx * Math.sin((-t / T) * 2 * Math.PI) * settings.ellipticity,\n        (t / T) * 2 * Math.PI,\n      ]);\n    }\n\n    pointsAtRadius[radius] = points;\n    return points;\n  };\n\n  /* Return true if we had spent too much time */\n  var exceedTime = function exceedTime() {\n    return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n  };\n\n  /* Get the deg of rotation according to settings, and luck. */\n  var getRotateDeg = function getRotateDeg() {\n    if (settings.rotateRatio === 0) {\n      return 0;\n    }\n\n    if (Math.random() > settings.rotateRatio) {\n      return 0;\n    }\n\n    if (rotationRange === 0) {\n      return minRotation;\n    }\n\n    // return minRotation + Math.round(Math.random() * rotationRange / rotationSteps) * rotationSteps;\n\n    if (rotationSteps > 0) {\n      // Min rotation + zero or more steps * span of one step\n      return minRotation + (Math.floor(Math.random() * rotationSteps) * rotationRange) / rotationSteps;\n    } else {\n      return minRotation + Math.random() * rotationRange;\n    }\n  };\n\n  var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n    // calculate the acutal font size\n    // fontSize === 0 means wants the text skipped,\n    // and size < minSize means we cannot draw the text\n    var debug = false;\n    var fontSize = getRealFontSize(weight);\n    if (fontSize <= 0) {\n      return false;\n    }\n\n    // Scale factor here is to make sure fillText is not limited by\n    // the minium font size set by browser.\n    // It will always be 1 or 2n.\n    var mu = 1;\n    if (fontSize < minFontSize) {\n      mu = (function calculateScaleFactor() {\n        var mu = 2;\n        while (mu * fontSize < minFontSize) {\n          mu += 2;\n        }\n        return mu;\n      })();\n    }\n\n    var fcanvas = document.createElement('canvas');\n    var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n\n    fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n    // Estimate the dimension of the text with measureText().\n    var fw = fctx.measureText(word).width / mu;\n    var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText('\\uFF37').width) / mu;\n\n    // Create a boundary box that is larger than our estimates,\n    // so text don't get cut of (it sill might)\n    var boxWidth = fw + fh * 2;\n    var boxHeight = fh * 3;\n    var fgw = Math.ceil(boxWidth / g);\n    var fgh = Math.ceil(boxHeight / g);\n    boxWidth = fgw * g;\n    boxHeight = fgh * g;\n\n    // Calculate the proper offsets to make the text centered at\n    // the preferred position.\n\n    // This is simply half of the width.\n    var fillTextOffsetX = -fw / 2;\n    // Instead of moving the box to the exact middle of the preferred\n    // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n    // vertical centered.\n    var fillTextOffsetY = -fh * 0.4;\n\n    // Calculate the actual dimension of the canvas, considering the rotation.\n    var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n    var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n    var width = cgw * g;\n    var height = cgh * g;\n\n    fcanvas.setAttribute('width', width);\n    fcanvas.setAttribute('height', height);\n\n    if (debug) {\n      // Attach fcanvas to the DOM\n      document.body.appendChild(fcanvas);\n      // Save it's state so that we could restore and draw the grid correctly.\n      fctx.save();\n    }\n\n    // Scale the canvas with |mu|.\n    fctx.scale(1 / mu, 1 / mu);\n    fctx.translate((width * mu) / 2, (height * mu) / 2);\n    fctx.rotate(-rotateDeg);\n\n    // Once the width/height is set, ctx info will be reset.\n    // Set it again here.\n    fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n    // Fill the text into the fcanvas.\n    // XXX: We cannot because textBaseline = 'top' here because\n    // Firefox and Chrome uses different default line-height for canvas.\n    // Please read https://bugzil.la/737852#c6.\n    // Here, we use textBaseline = 'middle' and draw the text at exactly\n    // 0.5 * fontSize lower.\n    fctx.fillStyle = '#000';\n    fctx.textBaseline = 'middle';\n    fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu);\n\n    // Get the pixels of the text\n    var imageData;\n    try {\n      imageData = fctx.getImageData(0, 0, width, height).data;\n    } catch (e) {\n      // data not long type\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    if (debug) {\n      // Draw the box of the original estimation\n      fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n      fctx.restore();\n    }\n\n    // Read the pixels and save the information to the occupied array\n    var occupied = [];\n    var gx = cgw,\n      gy,\n      x,\n      y;\n    var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n    while (gx--) {\n      gy = cgh;\n      while (gy--) {\n        y = g;\n        singleGridLoop: {\n          while (y--) {\n            x = g;\n            while (x--) {\n              if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                occupied.push([gx, gy]);\n\n                if (gx < bounds[3]) {\n                  bounds[3] = gx;\n                }\n                if (gx > bounds[1]) {\n                  bounds[1] = gx;\n                }\n                if (gy < bounds[0]) {\n                  bounds[0] = gy;\n                }\n                if (gy > bounds[2]) {\n                  bounds[2] = gy;\n                }\n\n                if (debug) {\n                  fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                  fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                }\n                break singleGridLoop;\n              }\n            }\n          }\n          if (debug) {\n            fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n          }\n        }\n      }\n    }\n\n    if (debug) {\n      // real bounds\n      fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n      fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n    }\n\n    // Return information needed to create the text on the real canvas\n    return {\n      mu: mu,\n      occupied: occupied,\n      bounds: bounds,\n      gw: cgw,\n      gh: cgh,\n      fillTextOffsetX: fillTextOffsetX,\n      fillTextOffsetY: fillTextOffsetY,\n      fillTextWidth: fw,\n      fillTextHeight: fh,\n      fontSize: fontSize,\n    };\n  };\n\n  /* Determine if there is room available in the given dimension */\n  var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n    // Go through the occupied points,\n    // return false if the space is not available.\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        if (!settings.drawOutOfBound) {\n          return false;\n        }\n        continue;\n      }\n\n      if (!grid[px][py]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /* Actually draw the text on the grid */\n  var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, id, refresh) {\n    var fontSize = info.fontSize;\n    var color = settings.color;\n    var classes = settings.classes;\n    if (!refresh) {\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      }\n\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\n      } else {\n        classes = settings.classes;\n      }\n    } else {\n      const find = getInteractionItemById(id);\n      color = find ? find.color : settings.color;\n    }\n\n    var dimension;\n    var bounds = info.bounds;\n    dimension = {\n      x: (gx + bounds[3]) * g,\n      y: (gy + bounds[0]) * g,\n      w: (bounds[1] - bounds[3] + 1) * g,\n      h: (bounds[2] - bounds[0] + 1) * g,\n    };\n\n    elements.forEach(function (el) {\n      if (el.getContext) {\n        var ctx = el.getContext('2d');\n        var mu = info.mu;\n\n        // Save the current state before messing it\n        ctx.save();\n        const font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        ctx.scale(1 / mu, 1 / mu);\n\n        ctx.font = font;\n        ctx.fillStyle = color;\n\n        // Translate the canvas position to the origin coordinate of where\n        // the text should be put.\n        let transX = (gx + info.gw / 2) * g * mu;\n        let transY = (gy + info.gh / 2) * g * mu;\n        ctx.translate(transX, transY);\n        if (rotateDeg !== 0) {\n          ctx.rotate(-rotateDeg);\n        }\n\n        // Finally, fill the text.\n\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n        ctx.textBaseline = 'middle';\n        if (settings.selected === id) {\n          ctx.shadowColor = settings.shadowColor;\n          ctx.shadowBlur = settings.shadowBlur;\n        }\n        ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu);\n\n        // The below box is always matches how <span>s are positioned\n        // ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n        //   info.fillTextWidth, info.fillTextHeight);\n\n        if (!refresh) {\n          interactionItems.push({\n            gx: gx,\n            gy: gy,\n            info: info,\n            word: word,\n            weight: weight,\n            distance: distance,\n            theta: theta,\n            rotateDeg: rotateDeg,\n            attributes: attributes,\n            id: id,\n            color: color,\n          });\n        }\n        // Restore the state.\n        ctx.restore();\n      } else {\n        // drawText on DIV element\n        var span = document.createElement('span');\n        var transformRule = '';\n        transformRule = 'rotate(' + (-rotateDeg / Math.PI) * 180 + 'deg) ';\n        if (info.mu !== 1) {\n          transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n        }\n        var styleRules = {\n          position: 'absolute',\n          display: 'block',\n          font: settings.fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n          left: (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n          top: (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n          width: info.fillTextWidth + 'px',\n          height: info.fillTextHeight + 'px',\n          lineHeight: fontSize + 'px',\n          whiteSpace: 'nowrap',\n          transform: transformRule,\n          webkitTransform: transformRule,\n          msTransform: transformRule,\n          transformOrigin: '50% 40%',\n          webkitTransformOrigin: '50% 40%',\n          msTransformOrigin: '50% 40%',\n        };\n        if (color) {\n          styleRules.color = color;\n        }\n        span.textContent = word;\n        for (var cssProp in styleRules) {\n          span.style[cssProp] = styleRules[cssProp];\n        }\n        if (attributes) {\n          for (var attribute in attributes) {\n            span.setAttribute(attribute, attributes[attribute]);\n          }\n        }\n        if (classes) {\n          span.className += classes;\n        }\n        el.appendChild(span);\n      }\n    });\n  };\n\n  /* Help function to updateGrid */\n  var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n    if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n      return;\n    }\n\n    grid[x][y] = false;\n\n    if (drawMask) {\n      var ctx = elements[0].getContext('2d');\n      ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n    }\n\n    if (interactive) {\n      infoGrid[x][y] = { item: item, dimension: dimension };\n    }\n  };\n\n  /* Update the filling information of the given space with occupied points.\n     Draw the mask on the canvas if necessary. */\n  var updateGrid = function updateGrid(gx, gy, gw, gh, info) {\n    var occupied = info.occupied;\n    var drawMask = settings.drawMask;\n    var ctx;\n    if (drawMask) {\n      ctx = elements[0].getContext('2d');\n      ctx.save();\n      ctx.fillStyle = settings.maskColor;\n    }\n\n    var dimension;\n    if (interactive) {\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g,\n      };\n    }\n\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        continue;\n      }\n\n      // save item's color from info\n      const find = getInteractionItemById(info.item.id);\n      if (find) {\n        info.item.color = find.color;\n      }\n      fillGridAt(px, py, drawMask, dimension, info.item);\n    }\n\n    if (drawMask) {\n      ctx.restore();\n    }\n  };\n\n  var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy, info, word, weight, distance, rotateDeg, attributes, id) {\n    var gx = Math.floor(gxy[0] - info.gw / 2);\n    var gy = Math.floor(gxy[1] - info.gh / 2);\n    var gw = info.gw;\n    var gh = info.gh;\n\n    // If we cannot fit the text at this position, return false\n    // and go to the next position.\n    if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n      return false;\n    }\n\n    // Actually put the text on the canvas\n    drawText(gx, gy, info, word, weight, distance, gxy[2], rotateDeg, attributes, id, false);\n\n    // Mark the spaces on the grid as filled\n    updateGrid(gx, gy, gw, gh, info);\n\n    return {\n      gx: gx,\n      gy: gy,\n      rot: rotateDeg,\n      info: info,\n    };\n  };\n\n  /* putWord() processes each item on the list,\n     calculate it's size and determine it's position, and actually\n     put it on the canvas. */\n  var putWord = function putWord(item) {\n    var word, weight, attributes, id;\n    if (Array.isArray(item)) {\n      word = item[0];\n      weight = item[1];\n    } else {\n      word = item.word;\n      weight = item.weight;\n      attributes = item.attributes;\n      id = item.id;\n    }\n    var rotateDeg = isNil(item.rotateDeg) ? getRotateDeg() : item.rotateDeg;\n\n    // get info needed to put the text onto the canvas\n    var info = getTextInfo(word, weight, rotateDeg);\n    if (info) {\n      info['item'] = item;\n    }\n\n    // not getting the info means we shouldn't be drawing this one.\n    if (!info) {\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    // If drawOutOfBound is set to false,\n    // skip the loop if we have already know the bounding box of\n    // word is larger than the canvas.\n    if (!settings.drawOutOfBound) {\n      var bounds = info.bounds;\n      if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n        return false;\n      }\n    }\n\n    // Determine the position to put the text by\n    // start looking for the nearest points\n    var r = maxRadius + 1;\n    while (r--) {\n      var points = getPointsAtRadius(maxRadius - r);\n\n      if (settings.shuffle) {\n        points = [].concat(points);\n        shuffleArray(points);\n      }\n\n      // Try to fit the words by looking at each point.\n      // array.some() will stop and return true\n      // when putWordAtPoint() returns true.\n      for (var i = 0; i < points.length; i++) {\n        var res = tryToPutWordAtPoint(points[i], info, word, weight, maxRadius - r, rotateDeg, attributes, id);\n        if (res) {\n          return res;\n        }\n      }\n\n      // var drawn = points.some(tryToPutWordAtPoint);\n      // if (drawn) {\n      //   // leave putWord() and return true\n      //   return true;\n      // }\n    }\n    // we tried all distances but text won't fit, return null\n    return null;\n  };\n\n  /* Send DOM event to all elements. Will stop sending event and return\n     if the previous one is canceled (for cancelable events). */\n  var sendEvent = function sendEvent(type, cancelable, detail) {\n    if (cancelable) {\n      return !elements.some(function (el) {\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(type, true, cancelable, detail || {});\n        return !el.dispatchEvent(evt);\n      }, this);\n    } else {\n      elements.forEach(function (el) {\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(type, true, cancelable, detail || {});\n        el.dispatchEvent(evt);\n      }, this);\n    }\n  };\n\n  var getInteractionItemById = function getInteractionItemById(id) {\n    for (let i = 0; i < interactionItems.length; i++) {\n      const find = interactionItems[i];\n      if (interactionItems[i].id === id) {\n        return find;\n      }\n    }\n    return undefined;\n  };\n  var twiceRender;\n  /* Start drawing on a canvas */\n  var start = function start(selected?) {\n    if (selected !== undefined) {\n      // re-refresh canvas with selected\n      // work in canvas only for now\n      if (settings.selected !== selected && elements[0].getContext) {\n        settings.selected = selected;\n        const ctx = elements[0].getContext('2d');\n        // draw background\n        ctx.fillStyle = settings.backgroundColor;\n        ctx.clearRect(0, 0, elements[0].width, elements[0].height);\n        ctx.fillRect(0, 0, elements[0].width, elements[0].height);\n        // draw text\n        for (let i = 0; i < interactionItems.length; i++) {\n          const find = interactionItems[i];\n          if (!twiceRender || (twiceRender && get(find, ['info', 'item', 'twiceRender']))) {\n            /**\n             * 词云图词量较少的时候，重新渲染一次词汇，放大词云图效果\n             * 这里先临时解决，后续还是需要优化词云图算法来解决\n             */\n            drawText(\n              find.gx,\n              find.gy,\n              find.info,\n              find.word,\n              find.weight,\n              find.distance,\n              find.theta,\n              find.rotateDeg,\n              find.attributes,\n              find.id,\n              true\n            );\n          }\n        }\n      }\n      return;\n    }\n    // For dimensions, clearCanvas etc.,\n    // we only care about the first element.\n    var canvas = elements[0];\n\n    if (canvas.getContext) {\n      ngx = Math.ceil(canvas.width / g);\n      ngy = Math.ceil(canvas.height / g);\n    } else {\n      var rect = canvas.getBoundingClientRect();\n      ngx = Math.ceil(rect.width / g);\n      ngy = Math.ceil(rect.height / g);\n    }\n\n    // Sending a wordcloudstart event which cause the previous loop to stop.\n    // Do nothing if the event is canceled.\n    if (!sendEvent('wordcloudstart', true)) {\n      return;\n    }\n\n    // Determine the center of the word cloud\n    center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / (isCardioid ? 4 : 2)];\n\n    // Maxium radius to look for space\n    maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n    /* Clear the canvas only if the clearCanvas is set,\n       if not, update the grid to the current canvas state */\n    grid = [];\n\n    var gx, gy, i;\n    if (!canvas.getContext || settings.clearCanvas) {\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          ctx.fillStyle = settings.backgroundColor;\n          ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n        } else {\n          el.textContent = '';\n          el.style.backgroundColor = settings.backgroundColor;\n          el.style.position = 'relative';\n        }\n      });\n\n      /* fill the grid with empty state */\n      gx = ngx;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          grid[gx][gy] = true;\n        }\n      }\n    } else {\n      /* Determine bgPixel by creating\n         another canvas and fill the specified background color. */\n      var bctx = document.createElement('canvas').getContext('2d');\n\n      bctx.fillStyle = settings.backgroundColor;\n      bctx.fillRect(0, 0, 1, 1);\n      var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n      /* Read back the pixels of the canvas we got to tell which part of the\n         canvas is empty.\n         (no clearCanvas only works with a canvas, not divs) */\n      var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n\n      gx = ngx;\n      var x, y;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          y = g;\n          singleGridLoop: while (y--) {\n            x = g;\n            while (x--) {\n              i = 4;\n              while (i--) {\n                if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                  grid[gx][gy] = false;\n                  break singleGridLoop;\n                }\n              }\n            }\n          }\n          if (grid[gx][gy] !== false) {\n            grid[gx][gy] = true;\n          }\n        }\n      }\n\n      imageData = bctx = bgPixel = undefined;\n    }\n\n    // fill the infoGrid with empty state if we need it\n    if (settings.onWordCloudHover || settings.onWordCloudClick) {\n      interactive = true;\n\n      /* fill the grid with empty state */\n      gx = ngx + 1;\n      while (gx--) {\n        infoGrid[gx] = [];\n      }\n\n      if (settings.onWordCloudHover) {\n        canvas.addEventListener('mousemove', wordcloudhover);\n      }\n\n      if (settings.onWordCloudClick) {\n        canvas.addEventListener('click', wordcloudclick);\n        canvas.addEventListener('touchstart', wordcloudclick);\n        canvas.addEventListener('touchend', function (e) {\n          e.preventDefault();\n        });\n        canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n\n      canvas.addEventListener('wordcloudstart', function stopInteraction() {\n        canvas.removeEventListener('wordcloudstart', stopInteraction);\n\n        canvas.removeEventListener('mousemove', wordcloudhover);\n        canvas.removeEventListener('click', wordcloudclick);\n        hovered = undefined;\n      });\n    }\n\n    if (!settings.animatable) {\n      if (options.maskImage) {\n        /** 修复颜色透明，还留有 maskImage 的情况 */\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          }\n        });\n      }\n      const renderedWords = [];\n      for (let i = 0; i < settings.data.length; i++) {\n        const response = putWord(settings.data[i]);\n        if (response) {\n          renderedWords.push(response);\n        }\n      }\n      if (renderedWords.length === settings.data.length) {\n        if (!twiceRender) {\n          elements.forEach(function (el) {\n            if (el.getContext) {\n              var ctx = el.getContext('2d');\n              ctx.fillStyle = settings.backgroundColor;\n              ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n              ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            }\n          });\n          /* fill the grid with empty state */\n          gx = ngx;\n          while (gx--) {\n            grid[gx] = [];\n            gy = ngy;\n            while (gy--) {\n              grid[gx][gy] = true;\n            }\n          }\n          twiceRender = true;\n          for (let i = 0; i < settings.data.length; i++) {\n            putWord({\n              ...settings.data[i],\n              twiceRender,\n            });\n          }\n        }\n      }\n    } else {\n      i = 0;\n      var loopingFunction, stoppingFunction;\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n\n      var timer = loopingFunction(function loop() {\n        if (i >= settings.data.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n\n          return;\n        }\n        escapeTime = new Date().getTime();\n        var drawn = putWord(settings.data[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.data[i],\n          drawn: drawn,\n        });\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    }\n  };\n\n  // All set, start the drawing\n  start();\n};\n\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\n\nexport default WordCloud;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}