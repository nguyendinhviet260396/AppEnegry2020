{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { every, each, groupBy, findIndex, uniq, map, size } from '@antv/util';\nimport { registerLabelComponent } from '../../../components/label/base';\nimport { ORIGIN, FIELD_ORIGIN } from '../../../dependents';\nimport ColumnLabel from './label';\nimport { getOverlapArea, moveInPanel, checkShapeOverlap } from '../../../util/view';\nimport BBox from '../../../util/bbox';\nimport { isContrastColorWhite } from '../../../util/color';\n/** 自动模式的 Column 数据标签，会根据图形和数据标签自动优化数据标签布局和样式等 */\n\nvar ColumnAutoLabel =\n/** @class */\nfunction (_super) {\n  __extends(ColumnAutoLabel, _super);\n\n  function ColumnAutoLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ColumnAutoLabel.prototype.getPosition = function (element) {\n    var offset = this.getDefaultOffset();\n    var value = this.getValue(element);\n    var bbox = this.getElementShapeBBox(element);\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxY = bbox.maxY,\n        width = bbox.width;\n    var _a = this.options,\n        offsetX = _a.offsetX,\n        offsetY = _a.offsetY;\n    var x = minX + width / 2 + offsetX;\n    var dir = value > 0 ? -1 : 1;\n    var root = value > 0 ? minY : maxY;\n    var y = root + offset * dir + offsetY; // 默认全部先设置为 top\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /** 默认的 fill 取自用户配置或主题配置 */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ColumnAutoLabel.prototype.getTextFill = function (element) {\n    var style = this.options.style;\n    return style.fill;\n  };\n  /** 默认不描边 */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ColumnAutoLabel.prototype.getTextStroke = function (element) {\n    return undefined;\n  };\n  /** 默认无处理：在 layout 阶段处理 */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ColumnAutoLabel.prototype.adjustLabel = function (label, element) {// empty\n  };\n  /** 自动布局所有的数据标签 */\n\n\n  ColumnAutoLabel.prototype.layoutLabels = function (geometry, labels) {\n    if (this.shouldInShapeLabels(labels)) {\n      this.inShapeLabels(geometry, labels);\n    }\n\n    this.autoHideLabels(geometry, labels);\n  };\n  /** 判断是否可以把数据标签放置在柱子内部 */\n\n\n  ColumnAutoLabel.prototype.shouldInShapeLabels = function (labels) {\n    var _this = this;\n\n    return every(labels, function (label) {\n      var labelBBox = label.getBBox();\n      var element = label.get('element');\n\n      var bbox = _this.getElementShapeBBox(element);\n\n      return bbox.width >= labelBBox.width;\n    });\n  };\n  /** 内置数据标签，并自动设置颜色描边等属性 */\n\n\n  ColumnAutoLabel.prototype.inShapeLabels = function (geometry, labels) {\n    var _this = this;\n\n    var coordinateBBox = this.getCoordinateBBox();\n    var xField = geometry.getXYFields()[0];\n    var _a = this.options,\n        darkStyle = _a.darkStyle,\n        lightStyle = _a.lightStyle;\n    var groupedLabels = groupBy(labels, function (label) {\n      return label.get(ORIGIN)[FIELD_ORIGIN][xField];\n    });\n    each(labels, function (label) {\n      var curGroup = groupedLabels[label.get(ORIGIN)[FIELD_ORIGIN][xField]] || [];\n      var element = label.get('element');\n      var shape = element.shape;\n      var fillWhite = isContrastColorWhite(shape.attr('fill'));\n\n      var shapeBBox = _this.getElementShapeBBox(element);\n\n      var labelBBox = BBox.fromBBoxObject(label.getBBox()); // 如果 Column 本身就不可见，直接隐藏对应的 label\n\n      if (getOverlapArea(coordinateBBox, shapeBBox) <= 0) {\n        label.set('visible', false);\n      }\n\n      if (labelBBox.height > shapeBBox.height) {\n        // 处理放不下的情况\n        var idx = findIndex(curGroup, function (item) {\n          return item === label;\n        });\n\n        if (idx !== 0) {\n          label.set('visible', false);\n        }\n      } else {\n        // 数据标签展示在图形中央\n        label.attr({\n          y: shapeBBox.y + shapeBBox.height / 2,\n          textBaseline: 'middle'\n        });\n        var overflow = labelBBox.width > shapeBBox.width || labelBBox.height > shapeBBox.height;\n\n        if (overflow) {\n          // 出现了溢出情况，添加描边\n          label.attr({\n            stroke: lightStyle === null || lightStyle === void 0 ? void 0 : lightStyle.stroke\n          });\n        } else {\n          // 放置在柱形内部，颜色取反\n          label.attr({\n            fill: fillWhite ? lightStyle === null || lightStyle === void 0 ? void 0 : lightStyle.fill : darkStyle === null || darkStyle === void 0 ? void 0 : darkStyle.fill,\n            fillOpacity: fillWhite ? lightStyle === null || lightStyle === void 0 ? void 0 : lightStyle.fillOpacity : darkStyle === null || darkStyle === void 0 ? void 0 : darkStyle.fillOpacity,\n            stroke: undefined\n          });\n        }\n      }\n    });\n  };\n  /** 数据标签防重叠抽样 */\n\n\n  ColumnAutoLabel.prototype.autoHideLabels = function (geometry, labels) {\n    var coordinateBBox = this.getCoordinateBBox();\n    var filteredLabels = this.filterLabels(labels);\n    var xField = geometry.getXYFields()[0];\n    var dones = [];\n    var todo = [];\n    var groupedLabels = groupBy(filteredLabels, function (label) {\n      return label.get(ORIGIN)[FIELD_ORIGIN][xField];\n    });\n    var xValues = uniq(map(filteredLabels, function (label) {\n      return label.get(ORIGIN)[FIELD_ORIGIN][xField];\n    }));\n    var xValue;\n\n    if (size(xValues) > 0) {\n      // 第一组\n      xValue = xValues.shift();\n      each(groupedLabels[xValue], function (label) {\n        return todo.push(label);\n      });\n    }\n\n    if (size(xValues) > 0) {\n      // 最后一组\n      xValue = xValues.pop();\n      each(groupedLabels[xValue], function (label) {\n        return todo.push(label);\n      });\n    }\n\n    each(xValues.reverse(), function (val) {\n      // 其他组\n      each(groupedLabels[val], function (label) {\n        return todo.push(label);\n      });\n    });\n\n    while (todo.length > 0) {\n      var cur = todo.shift();\n\n      if (cur.get('visible')) {\n        moveInPanel(cur, coordinateBBox);\n\n        if (checkShapeOverlap(cur, dones)) {\n          cur.set('visible', false);\n        } else {\n          dones.push(cur);\n        }\n      }\n    }\n  };\n  /** 抽样数据标签，设置最大数量的数据标签，其他的统一隐藏 */\n\n\n  ColumnAutoLabel.prototype.filterLabels = function (labels) {\n    var MAX_CNT = 500; // 最多显示 500 个数据标签\n\n    var filteredLabels = [];\n    var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n    each(labels, function (label, idx) {\n      if (idx % pages === 0) {\n        filteredLabels.push(label);\n      } else {\n        label.set('visible', false);\n      }\n    });\n    return filteredLabels;\n  };\n\n  return ColumnAutoLabel;\n}(ColumnLabel);\n\nexport default ColumnAutoLabel;\nregisterLabelComponent('column-auto', ColumnAutoLabel);","map":{"version":3,"sources":["../../../../src/plots/column/component/label-auto.ts"],"names":[],"mappings":"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","sourcesContent":["import { every, each, groupBy, findIndex, uniq, map, size } from '@antv/util';\nimport { registerLabelComponent } from '../../../components/label/base';\nimport { IShape, Geometry, Element, ORIGIN, FIELD_ORIGIN } from '../../../dependents';\nimport ColumnLabel from './label';\nimport { getOverlapArea, moveInPanel, checkShapeOverlap } from '../../../util/view';\nimport BBox from '../../../util/bbox';\nimport { isContrastColorWhite } from '../../../util/color';\nimport { IColumnAutoLabel } from '../interface';\n\n/** 自动模式的 Column 数据标签，会根据图形和数据标签自动优化数据标签布局和样式等 */\nexport default class ColumnAutoLabel extends ColumnLabel<IColumnAutoLabel> {\n  protected getPosition(element: Element): { x: number; y: number } {\n    const offset = this.getDefaultOffset();\n    const value = this.getValue(element);\n    const bbox = this.getElementShapeBBox(element);\n    const { minX, minY, maxY, width } = bbox;\n    const { offsetX, offsetY } = this.options;\n    const x = minX + width / 2 + offsetX;\n    const dir = value > 0 ? -1 : 1;\n    const root = value > 0 ? minY : maxY;\n    const y = root + offset * dir + offsetY;\n\n    // 默认全部先设置为 top\n    return { x, y };\n  }\n\n  /** 默认的 fill 取自用户配置或主题配置 */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected getTextFill(element: Element) {\n    const { style } = this.options;\n\n    return style.fill;\n  }\n\n  /** 默认不描边 */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected getTextStroke(element: Element) {\n    return undefined;\n  }\n\n  /** 默认无处理：在 layout 阶段处理 */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected adjustLabel(label: IShape, element: Element): void {\n    // empty\n  }\n\n  /** 自动布局所有的数据标签 */\n  protected layoutLabels(geometry: Geometry, labels: IShape[]): void {\n    if (this.shouldInShapeLabels(labels)) {\n      this.inShapeLabels(geometry, labels);\n    }\n    this.autoHideLabels(geometry, labels);\n  }\n\n  /** 判断是否可以把数据标签放置在柱子内部 */\n  protected shouldInShapeLabels(labels: IShape[]): boolean {\n    return every(labels, (label) => {\n      const labelBBox = label.getBBox();\n      const element: Element = label.get('element');\n      const bbox = this.getElementShapeBBox(element);\n\n      return bbox.width >= labelBBox.width;\n    });\n  }\n\n  /** 内置数据标签，并自动设置颜色描边等属性 */\n  protected inShapeLabels(geometry: Geometry, labels: IShape[]) {\n    const coordinateBBox = this.getCoordinateBBox();\n    const [xField] = geometry.getXYFields();\n    const { darkStyle, lightStyle } = this.options;\n    const groupedLabels = groupBy(labels, (label) => label.get(ORIGIN)[FIELD_ORIGIN][xField]);\n    each(labels, (label: IShape) => {\n      const curGroup = groupedLabels[label.get(ORIGIN)[FIELD_ORIGIN][xField]] || [];\n      const element: Element = label.get('element');\n      const { shape } = element;\n      const fillWhite = isContrastColorWhite(shape.attr('fill'));\n      const shapeBBox = this.getElementShapeBBox(element);\n      const labelBBox = BBox.fromBBoxObject(label.getBBox());\n\n      // 如果 Column 本身就不可见，直接隐藏对应的 label\n      if (getOverlapArea(coordinateBBox, shapeBBox) <= 0) {\n        label.set('visible', false);\n      }\n      if (labelBBox.height > shapeBBox.height) {\n        // 处理放不下的情况\n        const idx = findIndex(curGroup, (item) => item === label);\n        if (idx !== 0) {\n          label.set('visible', false);\n        }\n      } else {\n        // 数据标签展示在图形中央\n        label.attr({\n          y: shapeBBox.y + shapeBBox.height / 2,\n          textBaseline: 'middle',\n        });\n        const overflow = labelBBox.width > shapeBBox.width || labelBBox.height > shapeBBox.height;\n        if (overflow) {\n          // 出现了溢出情况，添加描边\n          label.attr({\n            stroke: lightStyle?.stroke,\n          });\n        } else {\n          // 放置在柱形内部，颜色取反\n          label.attr({\n            fill: fillWhite ? lightStyle?.fill : darkStyle?.fill,\n            fillOpacity: fillWhite ? lightStyle?.fillOpacity : darkStyle?.fillOpacity,\n            stroke: undefined,\n          });\n        }\n      }\n    });\n  }\n\n  /** 数据标签防重叠抽样 */\n  protected autoHideLabels(geometry: Geometry, labels: IShape[]) {\n    const coordinateBBox = this.getCoordinateBBox();\n    const filteredLabels = this.filterLabels(labels);\n    const [xField] = geometry.getXYFields();\n    const dones: IShape[] = [];\n    const todo: IShape[] = [];\n    const groupedLabels = groupBy(filteredLabels, (label) => label.get(ORIGIN)[FIELD_ORIGIN][xField]);\n    const xValues = uniq(map(filteredLabels, (label: IShape) => label.get(ORIGIN)[FIELD_ORIGIN][xField]));\n    let xValue;\n\n    if (size(xValues) > 0) {\n      // 第一组\n      xValue = xValues.shift();\n      each(groupedLabels[xValue], (label) => todo.push(label));\n    }\n    if (size(xValues) > 0) {\n      // 最后一组\n      xValue = xValues.pop();\n      each(groupedLabels[xValue], (label) => todo.push(label));\n    }\n    each(xValues.reverse(), (val) => {\n      // 其他组\n      each(groupedLabels[val], (label) => todo.push(label));\n    });\n\n    while (todo.length > 0) {\n      const cur = todo.shift();\n      if (cur.get('visible')) {\n        moveInPanel(cur, coordinateBBox);\n        if (checkShapeOverlap(cur, dones)) {\n          cur.set('visible', false);\n        } else {\n          dones.push(cur);\n        }\n      }\n    }\n  }\n\n  /** 抽样数据标签，设置最大数量的数据标签，其他的统一隐藏 */\n  private filterLabels(labels: IShape[]): IShape[] {\n    const MAX_CNT = 500; // 最多显示 500 个数据标签\n    const filteredLabels = [];\n    const pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n    each(labels, (label, idx) => {\n      if (idx % pages === 0) {\n        filteredLabels.push(label);\n      } else {\n        label.set('visible', false);\n      }\n    });\n\n    return filteredLabels;\n  }\n}\n\nregisterLabelComponent('column-auto', ColumnAutoLabel);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}